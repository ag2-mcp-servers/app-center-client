# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T15:41:50+00:00

from __future__ import annotations

from datetime import datetime as datetime_aliased
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, PositiveInt, RootModel, conint, constr

from . import Crash as Crash_1


class Resource(BaseModel):
    path: Optional[str] = None
    rel: Optional[str] = None


class Field1AccountTestExportGetResponse(BaseModel):
    resources: Optional[List[Resource]] = None


class Field1AccountTestExportAccountsGetResponse(BaseModel):
    id: Optional[UUID] = None


class Field1AccountTestExportFeatureFlagsGetResponse(BaseModel):
    name: Optional[str] = None
    target_id: Optional[UUID] = None


class Origin(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class Organizations(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin = Field(..., description='The creation origin of this organization')
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class Field1AdministeredOrgsGetResponse(BaseModel):
    organizations: Organizations


class Code(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error(BaseModel):
    code: Code
    message: str


class Field1AdministeredOrgsGetResponseModel(BaseModel):
    error: Error


class ScopeEnum(Enum):
    all = 'all'
    viewer = 'viewer'


class Field1ApiTokensGetResponseItem(BaseModel):
    created_at: str = Field(..., description='The creation time')
    description: Optional[str] = Field(None, description='The description of the token')
    id: str = Field(..., description='The unique id (UUID) of the api token')
    scope: Optional[List[ScopeEnum]] = Field(
        None, description='The scope for this token.'
    )


class Field1ApiTokensGetResponse(RootModel[List[Field1ApiTokensGetResponseItem]]):
    root: List[Field1ApiTokensGetResponseItem]


class Field1ApiTokensGetResponseModel(BaseModel):
    error: Error


class Field1ApiTokensPostRequest(BaseModel):
    description: Optional[str] = Field(None, description='The description of the token')
    scope: Optional[List[ScopeEnum]] = Field(
        None, description='The scope for this token.'
    )


class Field1ApiTokensPostResponse(BaseModel):
    api_token: str = Field(
        ..., description='The api token generated will not be accessible again'
    )
    created_at: str = Field(..., description='The creation time')
    description: Optional[str] = Field(None, description='The description of the token')
    id: str = Field(..., description='The unique id (UUID) of the api token')
    scope: Optional[List[ScopeEnum]] = Field(
        None, description='The scope for this token.'
    )


class Field1ApiTokensPostResponseModel(BaseModel):
    error: Error


class Field1ApiTokensApiTokenIdDeleteResponse(BaseModel):
    error: Error


class Os(Enum):
    Android = 'Android'
    iOS = 'iOS'
    macOS = 'macOS'
    Tizen = 'Tizen'
    tvOS = 'tvOS'
    Windows = 'Windows'
    Linux = 'Linux'
    Custom = 'Custom'


class Type(Enum):
    org = 'org'
    user = 'user'


class Owner(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type = Field(..., description="The owner type. Can either be 'org' or 'user'")


class AzureSubscription(BaseModel):
    is_billable: Optional[bool] = Field(
        None, description='If the subscription can be used for billing'
    )
    is_billing: Optional[bool] = Field(
        None, description='If the subscription is used for billing'
    )
    is_microsoft_internal: Optional[bool] = Field(
        None, description='If the subscription is internal Microsoft subscription'
    )
    subscription_id: UUID = Field(..., description='The azure subscription id')
    subscription_name: str = Field(
        ..., description='The name of the azure subscription'
    )
    tenant_id: UUID = Field(
        ..., description='The tenant id of the azure subscription belongs to'
    )


class MemberPermission(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'
    tester = 'tester'


class Origin48Model(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class Platform(Enum):
    Java = 'Java'
    Objective_C_Swift = 'Objective-C-Swift'
    UWP = 'UWP'
    Cordova = 'Cordova'
    React_Native = 'React-Native'
    Unity = 'Unity'
    Electron = 'Electron'
    Xamarin = 'Xamarin'
    WPF = 'WPF'
    WinForms = 'WinForms'
    Unknown = 'Unknown'
    Custom = 'Custom'


class Field1AppsGetResponseItem(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model = Field(..., description='The creation origin of this app')
    platform: Platform = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1AppsGetResponse(RootModel[List[Field1AppsGetResponseItem]]):
    root: List[Field1AppsGetResponseItem]


class Field1AppsGetResponseModel(BaseModel):
    error: Error


class Platform13Model(Enum):
    Java = 'Java'
    Objective_C_Swift = 'Objective-C-Swift'
    UWP = 'UWP'
    Cordova = 'Cordova'
    React_Native = 'React-Native'
    Xamarin = 'Xamarin'
    Unity = 'Unity'
    Electron = 'Electron'
    WPF = 'WPF'
    WinForms = 'WinForms'
    Custom = 'Custom'


class Field1AppsPostRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='A short text describing the app'
    )
    display_name: str = Field(
        ...,
        description='The descriptive name of the app. This can contain any characters',
    )
    name: Optional[str] = Field(None, description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    platform: Platform13Model = Field(..., description='The platform of the app')
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )


class Platform13Model1(Enum):
    Java = 'Java'
    Objective_C_Swift = 'Objective-C-Swift'
    UWP = 'UWP'
    Cordova = 'Cordova'
    React_Native = 'React-Native'
    Unity = 'Unity'
    Electron = 'Electron'
    Xamarin = 'Xamarin'
    WPF = 'WPF'
    WinForms = 'WinForms'
    Unknown = 'Unknown'
    Custom = 'Custom'


class Field1AppsPostResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model = Field(..., description='The creation origin of this app')
    platform: Platform13Model1 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1AppsPostResponseModel(BaseModel):
    error: Error


class Field1AppsOwnerNameAppNameDeleteResponse(BaseModel):
    error: Error


class Field1AppsOwnerNameAppNameGetResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model = Field(..., description='The creation origin of this app')
    platform: Platform13Model1 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1AppsOwnerNameAppNameGetResponseModel(BaseModel):
    error: Error


class Field1AppsOwnerNameAppNamePatchRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='A short text describing the app'
    )
    display_name: Optional[str] = Field(None, description='The display name of the app')
    icon_asset_id: Optional[UUID] = Field(
        None, description="The uuid for the icon's asset id from ACFUS"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    name: Optional[str] = Field(None, description='The name of the app used in URLs')
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release type value that starts with a capital letter but is otherwise lowercase',
    )


class Field1AppsOwnerNameAppNamePatchResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model = Field(..., description='The creation origin of this app')
    platform: Platform13Model1 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1AppsOwnerNameAppNamePatchResponseModel(BaseModel):
    error: Error


class DailyItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class MonthlyItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class WeeklyItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class Field1AppsOwnerNameAppNameAnalyticsActiveDeviceCountsGetResponse(BaseModel):
    daily: Optional[List[DailyItem]] = Field(
        None, description='The active device count for each interval.'
    )
    monthly: Optional[List[MonthlyItem]] = Field(
        None,
        description="The active device count for each interval with a month's retention.",
    )
    weekly: Optional[List[WeeklyItem]] = Field(
        None,
        description="The active device count for each interval with a week's retention.",
    )


class Code8Model(Enum):
    integer_400 = 400
    integer_403 = 403
    integer_500 = 500


class Error8Model(BaseModel):
    code: Optional[Code8Model] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed.'
    )


class Field1AppsOwnerNameAppNameAnalyticsActiveDeviceCountsGetResponseModel(BaseModel):
    error: Optional[Error8Model] = None


class State(Enum):
    Calculating = 'Calculating'
    Ready = 'Ready'
    Disabled = 'Disabled'


class Value(BaseModel):
    definition: Optional[str] = Field(
        None, description='Audience definition in OData format.'
    )
    description: Optional[str] = Field(None, description='Audience description.')
    estimated_count: Optional[int] = Field(None, description='Estimated audience size.')
    name: Optional[str] = Field(None, description='Audience name.')
    state: Optional[State] = Field(None, description='Audience state.')


class Field1AppsOwnerNameAppNameAnalyticsAudiencesGetResponse(BaseModel):
    nextLink: Optional[str] = None
    values: List[Value] = Field(..., description='List of audiences.')


class Code8Model1(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error8Model1(BaseModel):
    code: Code8Model1
    message: str


class Field1AppsOwnerNameAppNameAnalyticsAudiencesGetResponseModel(BaseModel):
    error: Error8Model1


class CustomProperties(Enum):
    string = 'string'
    number = 'number'
    boolean = 'boolean'
    date_time = 'date_time'


class Field1AppsOwnerNameAppNameAnalyticsAudiencesDefinitionTestPostRequest(BaseModel):
    custom_properties: Optional[Dict[str, CustomProperties]] = Field(
        None, description='Custom properties used in the definition.'
    )
    definition: constr(max_length=2000) = Field(
        ..., description='Audience definition in OData format.'
    )
    description: Optional[constr(max_length=128)] = Field(
        None, description='Audience description.'
    )
    enabled: Optional[bool] = True


class Field1AppsOwnerNameAppNameAnalyticsAudiencesDefinitionTestPostResponse(BaseModel):
    custom_properties: Optional[Dict[str, CustomProperties]] = Field(
        None, description='Custom properties used in the definition.'
    )
    definition: Optional[str] = Field(
        None, description='Audience definition in OData format.'
    )
    estimated_count: Optional[int] = Field(None, description='Estimated audience size.')
    estimated_total_count: Optional[int] = Field(
        None, description='Estimated total audience size.'
    )


class Field1AppsOwnerNameAppNameAnalyticsAudiencesDefinitionTestPostResponseModel(
    BaseModel
):
    error: Error8Model1


class Values(Enum):
    string = 'string'
    number = 'number'
    boolean = 'boolean'
    date_time = 'date_time'


class Field1AppsOwnerNameAppNameAnalyticsAudiencesMetadataCustomPropertiesGetResponse(
    BaseModel
):
    values: Dict[str, Values] = Field(..., description='List of device properties.')


class Field1AppsOwnerNameAppNameAnalyticsAudiencesMetadataCustomPropertiesGetResponseModel(
    BaseModel
):
    error: Error8Model1


class Field1AppsOwnerNameAppNameAnalyticsAudiencesMetadataDevicePropertiesGetResponse(
    BaseModel
):
    values: Dict[str, Values] = Field(..., description='List of device properties.')


class Field1AppsOwnerNameAppNameAnalyticsAudiencesMetadataDevicePropertiesGetResponseModel(
    BaseModel
):
    error: Error8Model1


class Field1AppsOwnerNameAppNameAnalyticsAudiencesMetadataDevicePropertiesPropertyNameValuesGetResponse(
    BaseModel
):
    values: List[str] = Field(..., description='List of device property values.')


class Field1AppsOwnerNameAppNameAnalyticsAudiencesMetadataDevicePropertiesPropertyNameValuesGetResponseModel(
    BaseModel
):
    error: Error8Model1


class Field1AppsOwnerNameAppNameAnalyticsAudiencesAudienceNameDeleteResponse(BaseModel):
    error: Error8Model1


class Field1AppsOwnerNameAppNameAnalyticsAudiencesAudienceNameGetResponse(BaseModel):
    definition: Optional[str] = Field(
        None, description='Audience definition in OData format.'
    )
    description: Optional[str] = Field(None, description='Audience description.')
    estimated_count: Optional[int] = Field(None, description='Estimated audience size.')
    name: Optional[str] = Field(None, description='Audience name.')
    state: Optional[State] = Field(None, description='Audience state.')
    custom_properties: Optional[Dict[str, CustomProperties]] = Field(
        None, description='Custom properties used in the definition.'
    )
    enabled: Optional[bool] = True
    estimated_total_count: Optional[int] = Field(
        None, description='Estimated total audience size.'
    )
    timestamp: Optional[datetime_aliased] = Field(
        None, description='Date the audience was last refreshed.'
    )


class Field1AppsOwnerNameAppNameAnalyticsAudiencesAudienceNameGetResponseModel(
    BaseModel
):
    error: Error8Model1


class Field1AppsOwnerNameAppNameAnalyticsAudiencesAudienceNameHeadResponse(BaseModel):
    error: Error8Model1


class Field1AppsOwnerNameAppNameAnalyticsAudiencesAudienceNamePutRequest(BaseModel):
    custom_properties: Optional[Dict[str, CustomProperties]] = Field(
        None, description='Custom properties used in the definition.'
    )
    definition: constr(max_length=2000) = Field(
        ..., description='Audience definition in OData format.'
    )
    description: Optional[constr(max_length=128)] = Field(
        None, description='Audience description.'
    )
    enabled: Optional[bool] = True


class Field1AppsOwnerNameAppNameAnalyticsAudiencesAudienceNamePutResponse(BaseModel):
    definition: Optional[str] = Field(
        None, description='Audience definition in OData format.'
    )
    description: Optional[str] = Field(None, description='Audience description.')
    estimated_count: Optional[int] = Field(None, description='Estimated audience size.')
    name: Optional[str] = Field(None, description='Audience name.')
    state: Optional[State] = Field(None, description='Audience state.')
    custom_properties: Optional[Dict[str, CustomProperties]] = Field(
        None, description='Custom properties used in the definition.'
    )
    enabled: Optional[bool] = True
    estimated_total_count: Optional[int] = Field(
        None, description='Estimated total audience size.'
    )
    timestamp: Optional[datetime_aliased] = Field(
        None, description='Date the audience was last refreshed.'
    )


class Field1AppsOwnerNameAppNameAnalyticsAudiencesAudienceNamePutResponseModel(
    BaseModel
):
    error: Error8Model1


class Crash(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class Field1AppsOwnerNameAppNameAnalyticsCrashCountsGetResponse(BaseModel):
    count: Optional[int] = Field(None, description='Total crash count.')
    crashes: Optional[List[Crash]] = Field(
        None, description='The total crash count for day.'
    )


class Code8Model2(Enum):
    integer_400 = 400
    integer_403 = 403
    integer_500 = 500


class Error8Model2(BaseModel):
    code: Optional[Code8Model2] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed.'
    )


class Field1AppsOwnerNameAppNameAnalyticsCrashCountsGetResponseModel(BaseModel):
    error: Optional[Error8Model2] = None


class CrashGroup(BaseModel):
    app_version: Optional[str] = None
    crash_group_id: Optional[str] = None


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsPostRequest(BaseModel):
    crash_groups: List[CrashGroup] = Field(..., min_length=1)


class Overall(BaseModel):
    crash_count: Optional[int] = None
    device_count: Optional[int] = None


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsPostResponseItem(BaseModel):
    app_version: Optional[str] = None
    crash_group_id: Optional[str] = None
    overall: Optional[Overall] = None


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsPostResponse(
    RootModel[List[Field1AppsOwnerNameAppNameAnalyticsCrashGroupsPostResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameAnalyticsCrashGroupsPostResponseItem] = Field(
        ...,
        description='List of crash groups with overall crashes count and affected users.',
    )


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsPostResponseModel(BaseModel):
    error: Optional[Error8Model2] = None


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsCrashGroupIdCrashCountsGetResponse(
    BaseModel
):
    count: Optional[int] = Field(None, description='Total crash count.')
    crashes: Optional[List[Crash]] = Field(
        None, description='The total crash count for day.'
    )


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsCrashGroupIdCrashCountsGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model2] = None


class Model(BaseModel):
    crash_count: Optional[int] = Field(None, description='Count of model.')
    model_name: Optional[str] = Field(None, description="Model's name.")


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsCrashGroupIdModelsGetResponse(
    BaseModel
):
    crash_count: Optional[int] = None
    models: Optional[List[Model]] = None


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsCrashGroupIdModelsGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model2] = None


class OperatingSystem(BaseModel):
    crash_count: Optional[int] = Field(None, description='Count of OS.')
    operating_system_name: Optional[str] = Field(None, description='OS name.')


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsCrashGroupIdOperatingSystemsGetResponse(
    BaseModel
):
    crash_count: Optional[int] = None
    operating_systems: Optional[List[OperatingSystem]] = None


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsCrashGroupIdOperatingSystemsGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model2] = None


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsCrashGroupIdOverallGetResponse(
    BaseModel
):
    crash_count: Optional[int] = None
    device_count: Optional[int] = None


class Field1AppsOwnerNameAppNameAnalyticsCrashGroupsCrashGroupIdOverallGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model2] = None


class DailyPercentage(BaseModel):
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')
    percentage: Optional[float] = Field(None, description='Percentage of the object.')


class Field1AppsOwnerNameAppNameAnalyticsCrashfreeDevicePercentagesGetResponse(
    BaseModel
):
    average_percentage: Optional[float] = Field(None, description='Average percentage.')
    daily_percentages: Optional[List[DailyPercentage]] = Field(
        None, description='The crash-free percentage per day.'
    )


class Field1AppsOwnerNameAppNameAnalyticsCrashfreeDevicePercentagesGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model2] = None


class Release(BaseModel):
    release: str = Field(..., description='Release Id.\n')
    distribution_group: Optional[str] = Field(
        None, description='Distribution group Id.\n'
    )


class Field1AppsOwnerNameAppNameAnalyticsDistributionReleaseCountsPostRequest(
    BaseModel
):
    releases: List[Release] = Field(..., min_length=1)


class Count(BaseModel):
    distribution_group: Optional[str] = Field(
        None, description='Distribution group queried.\n'
    )
    release_id: str
    total_count: int = Field(..., description='Total count of downloads.\n')
    unique_count: int = Field(
        ..., description='Count of unique downloads against user id.\n'
    )


class Field1AppsOwnerNameAppNameAnalyticsDistributionReleaseCountsPostResponse(
    BaseModel
):
    counts: List[Count]
    total: Optional[int] = None


class Code8Model3(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error8Model3(BaseModel):
    code: Code8Model3
    message: str


class Field1AppsOwnerNameAppNameAnalyticsDistributionReleaseCountsPostResponseModel(
    BaseModel
):
    error: Error8Model3


class Code8Model4(Enum):
    integer_400 = 400
    integer_403 = 403
    integer_500 = 500


class Error8Model4(BaseModel):
    code: Optional[Code8Model4] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed.'
    )


class Field1AppsOwnerNameAppNameAnalyticsEventLogsEventNameDeleteResponse(BaseModel):
    error: Optional[Error8Model4] = None


class Event(BaseModel):
    count: Optional[int] = None
    count_per_device: Optional[float] = None
    count_per_session: Optional[float] = None
    device_count: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    previous_count: Optional[int] = Field(
        None, description='The event count of previous time range of the event.'
    )
    previous_device_count: Optional[int] = Field(
        None, description='The device count of previous time range of the event.'
    )


class Field1AppsOwnerNameAppNameAnalyticsEventsGetResponse(BaseModel):
    events: Optional[List[Event]] = None
    total: Optional[int] = Field(None, description='The total count of events.')
    total_devices: Optional[int] = Field(
        None, description='The active device over this period.'
    )


class Field1AppsOwnerNameAppNameAnalyticsEventsGetResponseModel(BaseModel):
    error: Optional[Error8Model4] = None


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNameDeleteResponse(BaseModel):
    error: Optional[Error8Model4] = None


class CountPerDeviceItem(BaseModel):
    count: Optional[float] = Field(None, description='Decimal count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNameCountPerDeviceGetResponse(
    BaseModel
):
    avg_count_per_device: Optional[float] = None
    count_per_device: Optional[List[CountPerDeviceItem]] = None
    previous_avg_count_per_device: Optional[float] = None


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNameCountPerDeviceGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model4] = None


class CountPerSessionItem(BaseModel):
    count: Optional[float] = Field(None, description='Decimal count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNameCountPerSessionGetResponse(
    BaseModel
):
    avg_count_per_session: Optional[float] = None
    count_per_session: Optional[List[CountPerSessionItem]] = None
    previous_avg_count_per_session: Optional[float] = None


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNameCountPerSessionGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model4] = None


class DevicesCountItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNameDeviceCountGetResponse(
    BaseModel
):
    devices_count: Optional[List[DevicesCountItem]] = None
    previous_total_devices_with_event: Optional[int] = None
    total_devices: Optional[int] = None
    total_devices_with_event: Optional[int] = None


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNameDeviceCountGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model4] = None


class CountItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNameEventCountGetResponse(
    BaseModel
):
    count: Optional[List[CountItem]] = None
    previous_total_count: Optional[int] = None
    total_count: Optional[int] = None


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNameEventCountGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model4] = None


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNamePropertiesGetResponse(
    BaseModel
):
    event_properties: Optional[List[str]] = None


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNamePropertiesGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model4] = None


class Value8Model(BaseModel):
    count: Optional[int] = Field(
        None, description='The count of the the event property value.'
    )
    name: Optional[str] = Field(None, description='The event property value name.')
    previous_count: Optional[int] = Field(
        None,
        description='The count of previous time range of the event property value.',
    )


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNamePropertiesEventPropertyNameCountsGetResponse(
    BaseModel
):
    total: Optional[int] = Field(None, description='The total property value counts.')
    values: Optional[List[Value8Model]] = Field(
        None, description='The event property values.'
    )


class Field1AppsOwnerNameAppNameAnalyticsEventsEventNamePropertiesEventPropertyNameCountsGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model4] = None


class Device(BaseModel):
    app_build: str = Field(..., description="The app's build number, e.g. 42.\n")
    app_namespace: Optional[str] = Field(
        None,
        description='The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.\n',
    )
    app_version: str = Field(..., description='Application version name, e.g. 1.1.0\n')
    carrier_code: Optional[str] = Field(
        None, description='Carrier country code (for mobile devices).\n'
    )
    carrier_country: Optional[str] = Field(None, description='Carrier country.\n')
    carrier_name: Optional[str] = Field(
        None, description='Carrier name (for mobile devices).\n'
    )
    live_update_deployment_key: Optional[str] = Field(
        None,
        description='Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.\n',
    )
    live_update_package_hash: Optional[str] = Field(
        None,
        description='Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.\n',
    )
    live_update_release_label: Optional[str] = Field(
        None,
        description="Label that is used to identify application code 'version' released via Live Update beacon running on device\n",
    )
    locale: str = Field(..., description='Language code (example: en_US).\n')
    model: Optional[str] = Field(None, description='Device model (example: iPad2,3).\n')
    oem_name: Optional[str] = Field(
        None, description='Device manufacturer (example: HTC).\n'
    )
    os_api_level: Optional[int] = Field(
        None, description='API level when applicable like in Android (example: 15).\n'
    )
    os_build: Optional[str] = Field(
        None, description='OS build code (example: LMY47X).\n'
    )
    os_name: str = Field(
        ...,
        description='OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.\n',
    )
    os_version: str = Field(..., description='OS version (example: 9.3.0).\n')
    screen_size: Optional[str] = Field(
        None, description='Screen size of the device in pixels (example: 640x480).\n'
    )
    sdk_name: str = Field(
        ...,
        description='Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".\n',
    )
    sdk_version: str = Field(
        ...,
        description='Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".\n',
    )
    time_zone_offset: conint(ge=-840, le=840) = Field(
        ...,
        description='The offset in minutes from UTC for the device time zone, including daylight savings time.\n',
    )
    wrapper_runtime_version: Optional[str] = Field(
        None,
        description='Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.\n',
    )
    wrapper_sdk_name: Optional[str] = Field(
        None,
        description='Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".\n',
    )
    wrapper_sdk_version: Optional[str] = Field(
        None,
        description='Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.\n',
    )


class Type84Model(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class Log(BaseModel):
    account_id: Optional[str] = Field(
        None, description='Account ID of the authenticated user.\n'
    )
    auth_provider: Optional[str] = Field(None, description='Auth service provider.\n')
    device: Device = Field(..., description='Device characteristics.')
    event_id: Optional[str] = Field(None, description='Event ID.\n')
    event_name: Optional[str] = Field(None, description='Event name.\n')
    install_id: UUID = Field(..., description='Install ID.\n')
    message_id: Optional[str] = Field(None, description='Message ID.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='event specific properties.\n'
    )
    session_id: Optional[UUID] = Field(None, description='Session ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type84Model = Field(..., description='Log type.\n')


class Field1AppsOwnerNameAppNameAnalyticsGenericLogFlowGetResponse(BaseModel):
    exceeded_max_limit: Optional[bool] = Field(
        None,
        description='indicates if the number of available logs are more than the max allowed return limit(100).',
    )
    last_received_log_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='the timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.',
    )
    logs: List[Log] = Field(..., description='the list of logs', min_length=0)


class Code8Model5(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error8Model5(BaseModel):
    code: Code8Model5
    message: str


class Field1AppsOwnerNameAppNameAnalyticsGenericLogFlowGetResponseModel(BaseModel):
    error: Error8Model5


class Language(BaseModel):
    count: Optional[int] = Field(None, description='Count current of language.')
    language_name: Optional[str] = Field(None, description="Language's name.")
    previous_count: Optional[int] = Field(
        None, description='Count of previous lanugage.'
    )


class Field1AppsOwnerNameAppNameAnalyticsLanguagesGetResponse(BaseModel):
    languages: Optional[List[Language]] = None
    total: Optional[int] = None


class Code8Model6(Enum):
    integer_400 = 400
    integer_403 = 403
    integer_500 = 500


class Error8Model6(BaseModel):
    code: Optional[Code8Model6] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed.'
    )


class Field1AppsOwnerNameAppNameAnalyticsLanguagesGetResponseModel(BaseModel):
    error: Optional[Error8Model6] = None


class Log6Model(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type84Model = Field(..., description='Log type.\n')


class Field1AppsOwnerNameAppNameAnalyticsLogFlowGetResponse(BaseModel):
    exceeded_max_limit: Optional[bool] = Field(
        None,
        description='indicates if the number of available logs are more than the max allowed return limit(100).',
    )
    last_received_log_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='the timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.',
    )
    logs: List[Log6Model] = Field(..., description='the list of logs', min_length=0)


class Code8Model7(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error8Model7(BaseModel):
    code: Code8Model7
    message: str


class Field1AppsOwnerNameAppNameAnalyticsLogFlowGetResponseModel(BaseModel):
    error: Error8Model7


class Model7Model(BaseModel):
    count: Optional[int] = Field(None, description='Count current of model.')
    model_name: Optional[str] = Field(None, description="Model's name.")
    previous_count: Optional[int] = Field(None, description='Count of previous model.')


class Field1AppsOwnerNameAppNameAnalyticsModelsGetResponse(BaseModel):
    models: Optional[List[Model7Model]] = None
    total: Optional[int] = None


class Code8Model8(Enum):
    integer_400 = 400
    integer_403 = 403
    integer_500 = 500


class Error8Model8(BaseModel):
    code: Optional[Code8Model8] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed.'
    )


class Field1AppsOwnerNameAppNameAnalyticsModelsGetResponseModel(BaseModel):
    error: Optional[Error8Model8] = None


class Ose(BaseModel):
    count: Optional[int] = Field(None, description='Count current of OS.')
    os_name: Optional[str] = Field(None, description='OS name.')
    previous_count: Optional[int] = Field(None, description='Count of previous OS.')


class Field1AppsOwnerNameAppNameAnalyticsOsesGetResponse(BaseModel):
    oses: Optional[List[Ose]] = None
    total: Optional[int] = None


class Field1AppsOwnerNameAppNameAnalyticsOsesGetResponseModel(BaseModel):
    error: Optional[Error8Model8] = None


class Place(BaseModel):
    code: Optional[str] = Field(None, description='The place code.')
    count: Optional[int] = Field(None, description='The count of the this place.')
    previous_count: Optional[int] = Field(
        None, description='The count of previous time range of the place.'
    )


class Field1AppsOwnerNameAppNameAnalyticsPlacesGetResponse(BaseModel):
    places: Optional[List[Place]] = None
    total: Optional[int] = None


class Field1AppsOwnerNameAppNameAnalyticsPlacesGetResponseModel(BaseModel):
    error: Optional[Error8Model8] = None


class Field1AppsOwnerNameAppNameAnalyticsSessionCountsGetResponseItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class Field1AppsOwnerNameAppNameAnalyticsSessionCountsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameAnalyticsSessionCountsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameAnalyticsSessionCountsGetResponseItem]


class Code8Model9(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error8Model9(BaseModel):
    code: Code8Model9
    message: str


class Field1AppsOwnerNameAppNameAnalyticsSessionCountsGetResponseModel(BaseModel):
    error: Error8Model9


class DistributionItem(BaseModel):
    bucket: Optional[str] = Field(None, description='The bucket name.')
    count: Optional[int] = Field(
        None, description='The count of sessions in current bucket.'
    )


class Field1AppsOwnerNameAppNameAnalyticsSessionDurationsDistributionGetResponse(
    BaseModel
):
    average_duration: Optional[str] = Field(
        None, description='The average session duration for current time range.'
    )
    distribution: Optional[List[DistributionItem]] = Field(
        None, description='The count of sessions in these buckets.'
    )
    previous_average_duration: Optional[str] = Field(
        None,
        description='The previous average session duration for previous time range.',
    )


class Code8Model10(Enum):
    integer_400 = 400
    integer_403 = 403
    integer_500 = 500


class Error8Model10(BaseModel):
    code: Optional[Code8Model10] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed.'
    )


class Field1AppsOwnerNameAppNameAnalyticsSessionDurationsDistributionGetResponseModel(
    BaseModel
):
    error: Optional[Error8Model10] = None


class SessionsPerUserItem(BaseModel):
    count: Optional[float] = Field(None, description='Count.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class Field1AppsOwnerNameAppNameAnalyticsSessionsPerDeviceGetResponse(BaseModel):
    average_sessions_per_user: Optional[float] = Field(
        None, description='Average seesion per user.'
    )
    previous_average_sessions_per_user: Optional[float] = Field(
        None, description='Previous average session per user.'
    )
    previous_total_count: Optional[int] = Field(
        None, description='Previous total count.'
    )
    sessions_per_user: Optional[List[SessionsPerUserItem]] = Field(
        None, description='The session count for each interval per device.'
    )
    total_count: Optional[int] = Field(
        None, description='Total session per device count.'
    )


class Field1AppsOwnerNameAppNameAnalyticsSessionsPerDeviceGetResponseModel(BaseModel):
    error: Optional[Error8Model10] = None


class Version(BaseModel):
    count: Optional[int] = Field(None, description='Version count.')
    previous_count: Optional[int] = Field(
        None, description='The count of previous time range of the version.'
    )
    version: Optional[str] = Field(None, description='Version.')


class Field1AppsOwnerNameAppNameAnalyticsVersionsGetResponse(BaseModel):
    total: Optional[int] = Field(None, description='The total count of versions.')
    versions: Optional[List[Version]] = Field(
        None, description='List of version count.'
    )


class Field1AppsOwnerNameAppNameAnalyticsVersionsGetResponseModel(BaseModel):
    error: Optional[Error8Model10] = None


class Field1AppsOwnerNameAppNameApiTokensGetResponseItem(BaseModel):
    created_at: str = Field(..., description='The creation time')
    description: Optional[str] = Field(None, description='The description of the token')
    id: str = Field(..., description='The unique id (UUID) of the api token')
    scope: Optional[List[ScopeEnum]] = Field(
        None, description='The scope for this token.'
    )


class Field1AppsOwnerNameAppNameApiTokensGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameApiTokensGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameApiTokensGetResponseItem]


class Code8Model11(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error8Model11(BaseModel):
    code: Code8Model11
    message: str


class Field1AppsOwnerNameAppNameApiTokensGetResponseModel(BaseModel):
    error: Error8Model11


class Field1AppsOwnerNameAppNameApiTokensPostRequest(BaseModel):
    description: Optional[str] = Field(None, description='The description of the token')
    scope: Optional[List[ScopeEnum]] = Field(
        None, description='The scope for this token.'
    )


class Field1AppsOwnerNameAppNameApiTokensPostResponse(BaseModel):
    api_token: str = Field(
        ..., description='The api token generated will not be accessible again'
    )
    created_at: str = Field(..., description='The creation time')
    description: Optional[str] = Field(None, description='The description of the token')
    id: str = Field(..., description='The unique id (UUID) of the api token')
    scope: Optional[List[ScopeEnum]] = Field(
        None, description='The scope for this token.'
    )


class Field1AppsOwnerNameAppNameApiTokensPostResponseModel(BaseModel):
    error: Error8Model11


class Field1AppsOwnerNameAppNameApiTokensApiTokenIdDeleteResponse(BaseModel):
    error: Error8Model11


class Field1AppsOwnerNameAppNameAppleMappingDeleteResponse(BaseModel):
    code: Code8Model11
    message: str


class Field1AppsOwnerNameAppNameAppleMappingGetResponse(BaseModel):
    app_id: Optional[str] = Field(
        None, description='ID of the apple application in Mobile Center'
    )
    apple_id: Optional[str] = Field(
        None, description='ID of the apple application in apple store'
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.',
    )
    team_identifier: Optional[str] = Field(
        None, description='ID of the Team associated with the app in apple store'
    )


class Field1AppsOwnerNameAppNameAppleMappingGetResponseModel(BaseModel):
    code: Code8Model11
    message: str


class Field1AppsOwnerNameAppNameAppleMappingPostRequest(BaseModel):
    apple_id: Optional[str] = Field(
        None,
        description='ID of the apple application in apple store, takes precedence over bundle_identifier when both are provided',
    )
    bundle_identifier: Optional[str] = Field(
        None, description='Bundle Identifier of the apple package'
    )
    service_connection_id: str = Field(
        ...,
        description='Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.',
    )
    team_identifier: str = Field(
        ..., description='ID of the Team associated with the app in apple store'
    )


class Field1AppsOwnerNameAppNameAppleMappingPostResponse(BaseModel):
    app_id: Optional[str] = Field(
        None, description='ID of the apple application in Mobile Center'
    )
    apple_id: Optional[str] = Field(
        None, description='ID of the apple application in apple store'
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.',
    )
    team_identifier: Optional[str] = Field(
        None, description='ID of the Team associated with the app in apple store'
    )


class Field1AppsOwnerNameAppNameAppleMappingPostResponseModel(BaseModel):
    code: Code8Model11
    message: str


class Field1AppsOwnerNameAppNameAppleTestFlightGroupsGetResponseItem(BaseModel):
    appleId: Optional[float] = Field(None, description='apple id of the group.')
    id: Optional[str] = Field(None, description='id of the group.')
    name: Optional[str] = Field(None, description='name of the group.')
    providerId: Optional[float] = Field(None, description='provider id of the group.')


class Field1AppsOwnerNameAppNameAppleTestFlightGroupsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameAppleTestFlightGroupsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameAppleTestFlightGroupsGetResponseItem]


class Field1AppsOwnerNameAppNameAppleTestFlightGroupsGetResponseModel(BaseModel):
    code: Code8Model11
    message: str


class Type84Model1(Enum):
    org = 'org'
    user = 'user'


class Field1AppsOwnerNameAppNameAvatarDeleteResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model = Field(..., description='The creation origin of this app')
    platform: Platform13Model1 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1AppsOwnerNameAppNameAvatarDeleteResponseModel(BaseModel):
    error: Error8Model11


class Field1AppsOwnerNameAppNameAvatarPostRequest(BaseModel):
    avatar: Optional[bytes] = Field(
        None, description='The image for an app avatar to upload.'
    )


class Field1AppsOwnerNameAppNameAvatarPostResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model = Field(..., description='The creation origin of this app')
    platform: Platform13Model1 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1AppsOwnerNameAppNameAvatarPostResponseModel(BaseModel):
    error: Error8Model11


class Field1AppsOwnerNameAppNameAzureSubscriptionsGetResponseItem(BaseModel):
    is_billable: Optional[bool] = Field(
        None, description='If the subscription can be used for billing'
    )
    is_billing: Optional[bool] = Field(
        None, description='If the subscription is used for billing'
    )
    is_microsoft_internal: Optional[bool] = Field(
        None, description='If the subscription is internal Microsoft subscription'
    )
    subscription_id: UUID = Field(..., description='The azure subscription id')
    subscription_name: str = Field(
        ..., description='The name of the azure subscription'
    )
    tenant_id: UUID = Field(
        ..., description='The tenant id of the azure subscription belongs to'
    )


class Field1AppsOwnerNameAppNameAzureSubscriptionsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameAzureSubscriptionsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameAzureSubscriptionsGetResponseItem]


class Field1AppsOwnerNameAppNameAzureSubscriptionsGetResponseModel(BaseModel):
    error: Error8Model11


class Field1AppsOwnerNameAppNameAzureSubscriptionsPostRequest(BaseModel):
    subscription_id: UUID = Field(..., description='The azure subscription id')


class Field1AppsOwnerNameAppNameAzureSubscriptionsPostResponse(BaseModel):
    error: Error8Model11


class Field1AppsOwnerNameAppNameAzureSubscriptionsAzureSubscriptionIdDeleteResponse(
    BaseModel
):
    error: Error8Model11


class AzureSubscriptionState(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'
    NotSet = 'NotSet'


class PaymentSource(Enum):
    None_ = 'None'
    AppCenter = 'AppCenter'
    GitHub = 'GitHub'
    Xtc = 'Xtc'


class Service(Enum):
    Build = 'Build'
    Test = 'Test'


class Plan(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class ByAccount(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan] = Field(None, description='Billing Plan')


class CurrentBillingPeriod(BaseModel):
    byAccount: Optional[ByAccount] = Field(
        None, description='Selection of a billing plan'
    )
    endTime: Optional[str] = Field(None, description='Exclusive end of the period.')
    startTime: Optional[str] = Field(None, description='Inclusive start of the period')


class BuildService(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class TestService(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class BillingPlans(BaseModel):
    buildService: Optional[BuildService] = Field(
        None, description='Billing Plans for a single service'
    )
    testService: Optional[TestService] = Field(
        None, description='Billing Plans for a single service'
    )


class CurrentUsagePeriod(BaseModel):
    byAccount: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    byApp: Optional[Dict[str, Dict[str, float]]] = Field(
        None, description='A collection of  named numeric values grouped by app'
    )
    endTime: Optional[str] = Field(
        None, description='Exclusive end time of the usage period.'
    )
    startTime: Optional[str] = Field(
        None, description='Inclusive start time of the usage period'
    )


class BuildService7Model(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class TestService7Model(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class Usage(BaseModel):
    buildService: Optional[BuildService7Model] = Field(
        None, description='Resource usage for a single Mobile Center service'
    )
    testService: Optional[TestService7Model] = Field(
        None, description='Resource usage for a single Mobile Center service'
    )


class Field1AppsOwnerNameAppNameBillingAggregatedGetResponse(BaseModel):
    azureSubscriptionId: Optional[str] = Field(
        None,
        description='Unique identifier for the Azure subscription used for billing',
    )
    azureSubscriptionState: Optional[AzureSubscriptionState] = Field(
        None, description='State of the Azure subscription used for billing'
    )
    billingPlans: Optional[BillingPlans] = Field(
        None, description='Billing Plans section in the Billing Information'
    )
    id: Optional[str] = Field(None, description='ID of the user or organization')
    timestamp: Optional[str] = Field(
        None, description='The ISO 8601 datetime of last modification'
    )
    usage: Optional[Usage] = Field(
        None, description='Usage section in the Billing Information'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Information schema'
    )


class Code8Model12(Enum):
    integer_400 = 400
    integer_403 = 403
    integer_500 = 500


class Error8Model12(BaseModel):
    code: Optional[Code8Model12] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed'
    )


class Field1AppsOwnerNameAppNameBillingAggregatedGetResponseModel(BaseModel):
    error: Optional[Error8Model12] = None


class LastBuild(BaseModel):
    buildNumber: str = Field(..., description='The build number')
    finishTime: Optional[str] = Field(
        None, description='The time the build was finished'
    )
    id: PositiveInt = Field(..., description='The build ID')
    lastChangedDate: Optional[str] = Field(
        None, description='The time the build status was last changed'
    )
    queueTime: str = Field(..., description='The time the build was queued')
    result: str = Field(..., description='The build result')
    sourceBranch: str = Field(..., description='The source branch name')
    sourceVersion: str = Field(..., description='The source SHA')
    startTime: Optional[str] = Field(None, description='The time the build was started')
    status: str = Field(..., description='The build status')


class Field1AppsOwnerNameAppNameBranchesGetResponseItem(BaseModel):
    configured: bool
    lastBuild: Optional[LastBuild] = None


class Field1AppsOwnerNameAppNameBranchesGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameBranchesGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameBranchesGetResponseItem] = Field(
        ..., description='A collection of branch status'
    )


class Field1AppsOwnerNameAppNameBranchesGetResponseModel(BaseModel):
    code: str
    id: str
    message: str


class Field1AppsOwnerNameAppNameBranchesBranchBuildsGetResponseItem(BaseModel):
    buildNumber: str = Field(..., description='The build number')
    finishTime: Optional[str] = Field(
        None, description='The time the build was finished'
    )
    id: PositiveInt = Field(..., description='The build ID')
    lastChangedDate: Optional[str] = Field(
        None, description='The time the build status was last changed'
    )
    queueTime: str = Field(..., description='The time the build was queued')
    result: str = Field(..., description='The build result')
    sourceBranch: str = Field(..., description='The source branch name')
    sourceVersion: str = Field(..., description='The source SHA')
    startTime: Optional[str] = Field(None, description='The time the build was started')
    status: str = Field(..., description='The build status')


class Field1AppsOwnerNameAppNameBranchesBranchBuildsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameBranchesBranchBuildsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameBranchesBranchBuildsGetResponseItem] = Field(
        ..., description='A list of builds'
    )


class Field1AppsOwnerNameAppNameBranchesBranchBuildsPostRequest(BaseModel):
    debug: Optional[bool] = Field(None, description='Run build in debug mode')
    sourceVersion: Optional[str] = Field(
        None,
        description='Version to build which represents the full Git commit reference',
    )


class Field1AppsOwnerNameAppNameBranchesBranchBuildsPostResponse(BaseModel):
    buildNumber: str = Field(..., description='The build number')
    finishTime: Optional[str] = Field(
        None, description='The time the build was finished'
    )
    id: PositiveInt = Field(..., description='The build ID')
    lastChangedDate: Optional[str] = Field(
        None, description='The time the build status was last changed'
    )
    queueTime: str = Field(..., description='The time the build was queued')
    result: str = Field(..., description='The build result')
    sourceBranch: str = Field(..., description='The source branch name')
    sourceVersion: str = Field(..., description='The source SHA')
    startTime: Optional[str] = Field(None, description='The time the build was started')
    status: str = Field(..., description='The build status')


class Field1AppsOwnerNameAppNameBranchesBranchConfigDeleteRequest(BaseModel):
    pass


class Field1AppsOwnerNameAppNameBranchesBranchConfigDeleteResponse(BaseModel):
    message: str


class BuildNumberFormat(Enum):
    buildId = 'buildId'
    timestamp = 'timestamp'


class ArtifactVersioning(BaseModel):
    buildNumberFormat: Optional[BuildNumberFormat] = None


class Android(BaseModel):
    automaticSigning: Optional[bool] = Field(
        None, description='Whether to apply automatic signing or not'
    )
    buildVariant: Optional[str] = Field(
        None, description='The Android build variant to build', examples=['release']
    )
    gradleWrapperPath: Optional[str] = Field(
        None,
        description='Path to the Gradle wrapper script',
        examples=['android/gradlew'],
    )
    isRoot: Optional[bool] = Field(
        None, description='Whether it is the root module or not'
    )
    keyAlias: Optional[str] = Field(None, description='The key alias')
    keyPassword: Optional[str] = Field(None, description='The key password')
    keystoreEncoded: Optional[str] = Field(
        None, description='The keystore encoded value'
    )
    keystoreFilename: Optional[str] = Field(
        None, description='The name of the keystore file'
    )
    keystorePassword: Optional[str] = Field(
        None, description='The password of the keystore'
    )
    module: Optional[str] = Field(
        None, description='The Gradle module to build', examples=['app']
    )
    runLint: Optional[bool] = Field(
        None, description='Whether to run lint checks during the build (default)'
    )
    runTests: Optional[bool] = Field(
        True, description='Whether to run unit tests during the build (default)'
    )


class Javascript(BaseModel):
    packageJsonPath: Optional[str] = Field(
        None,
        description='Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"',
    )
    reactNativeVersion: Optional[str] = Field(
        None, description='Version of React Native from package.json files'
    )
    runTests: Optional[bool] = Field(
        None,
        description='Whether to run Jest unit tests, via npm test, during the build',
    )


class Xamarin(BaseModel):
    args: Optional[str] = None
    configuration: Optional[str] = None
    isSimBuild: Optional[bool] = None
    monoVersion: Optional[str] = None
    p12File: Optional[str] = None
    p12Pwd: Optional[str] = None
    provProfile: Optional[str] = None
    sdkBundle: Optional[str] = None
    slnPath: Optional[str] = None
    symlink: Optional[str] = Field(
        None,
        description='Symlink of the SDK Bundle and Mono installation.\nThe build will use the associated Mono bundled with related Xamarin SDK. If both symlink and monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink is passed, the current stable Mono version will be configured for building.\n',
    )


class AppExtensionProvisioningProfileFile(BaseModel):
    fileId: Optional[str] = Field(None, description='File id from secure file storage')
    fileName: Optional[str] = Field(
        None, description='Name of uploaded provisioning profile'
    )
    targetBundleIdentifier: Optional[str] = Field(
        None, description='Target the provisioning profile is used to sign'
    )
    uploadId: Optional[str] = Field(
        None, description='Upload id to App Center File Upload Store'
    )


class Xcode(BaseModel):
    appExtensionProvisioningProfileFiles: Optional[
        List[AppExtensionProvisioningProfileFile]
    ] = None
    archiveConfiguration: Optional[str] = Field(
        None, description='The build configuration of the target to archive'
    )
    automaticSigning: Optional[bool] = None
    cartfilePath: Optional[str] = Field(
        None, description='Path to Carthage file, if present'
    )
    certificateEncoded: Optional[str] = None
    certificateFileId: Optional[str] = None
    certificateFilename: Optional[str] = None
    certificatePassword: Optional[str] = None
    certificateUploadId: Optional[str] = None
    forceLegacyBuildSystem: Optional[bool] = Field(
        None,
        description='Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.\nBy default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.\n',
    )
    podfilePath: Optional[str] = Field(
        None, description='Path to CococaPods file, if present'
    )
    projectOrWorkspacePath: Optional[str] = Field(
        None, description='Xcode project/workspace path'
    )
    provisioningProfileEncoded: Optional[str] = None
    provisioningProfileFileId: Optional[str] = None
    provisioningProfileFilename: Optional[str] = None
    provisioningProfileUploadId: Optional[str] = None
    scheme: Optional[str] = None
    targetToArchive: Optional[str] = Field(
        None, description='The target id of the selected scheme to archive'
    )
    teamId: Optional[str] = None
    xcodeProjectSha: Optional[str] = Field(
        None, description='The selected pbxproject hash to the repositroy'
    )
    xcodeVersion: Optional[str] = Field(
        None,
        description='Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default is latest stable version, at the time when the configuration is set.',
    )


class Toolsets(BaseModel):
    android: Optional[Android] = Field(
        None, description='Build configuration for Android projects'
    )
    javascript: Optional[Javascript] = Field(
        None,
        description='Build configuration when React Native, or other JavaScript tech, is part of the build steps',
    )
    xamarin: Optional[Xamarin] = Field(
        None, description='Build configuration for Xamarin projects'
    )
    xcode: Optional[Xcode] = Field(
        None, description='Build configuration when Xcode is part of the build steps'
    )


class Trigger(Enum):
    continous = 'continous'
    continuous = 'continuous'
    manual = 'manual'


class Field1AppsOwnerNameAppNameBranchesBranchConfigGetResponse(BaseModel):
    artifactVersioning: Optional[ArtifactVersioning] = Field(
        None,
        description='The versioning configuration for artifacts built for this branch',
    )
    badgeIsEnabled: Optional[bool] = None
    cloneFromBranch: Optional[str] = Field(
        None,
        description='A configured branch name to clone from. If provided, all other parameters will be ignored. Only supported in POST requests.',
    )
    signed: Optional[bool] = None
    testsEnabled: Optional[bool] = None
    toolsets: Optional[Toolsets] = Field(
        None, description='The branch build configuration for each toolset'
    )
    trigger: Optional[Trigger] = None
    id: int


class Field1AppsOwnerNameAppNameBranchesBranchConfigGetResponseModel(BaseModel):
    code: str
    id: str
    message: str


class Field1AppsOwnerNameAppNameBranchesBranchConfigPostRequest(BaseModel):
    artifactVersioning: Optional[ArtifactVersioning] = Field(
        None,
        description='The versioning configuration for artifacts built for this branch',
    )
    badgeIsEnabled: Optional[bool] = None
    cloneFromBranch: Optional[str] = Field(
        None,
        description='A configured branch name to clone from. If provided, all other parameters will be ignored. Only supported in POST requests.',
    )
    signed: Optional[bool] = None
    testsEnabled: Optional[bool] = None
    toolsets: Optional[Toolsets] = Field(
        None, description='The branch build configuration for each toolset'
    )
    trigger: Optional[Trigger] = None


class Field1AppsOwnerNameAppNameBranchesBranchConfigPostResponse(BaseModel):
    artifactVersioning: Optional[ArtifactVersioning] = Field(
        None,
        description='The versioning configuration for artifacts built for this branch',
    )
    badgeIsEnabled: Optional[bool] = None
    cloneFromBranch: Optional[str] = Field(
        None,
        description='A configured branch name to clone from. If provided, all other parameters will be ignored. Only supported in POST requests.',
    )
    signed: Optional[bool] = None
    testsEnabled: Optional[bool] = None
    toolsets: Optional[Toolsets] = Field(
        None, description='The branch build configuration for each toolset'
    )
    trigger: Optional[Trigger] = None
    id: int


class Field1AppsOwnerNameAppNameBranchesBranchConfigPutRequest(BaseModel):
    artifactVersioning: Optional[ArtifactVersioning] = Field(
        None,
        description='The versioning configuration for artifacts built for this branch',
    )
    badgeIsEnabled: Optional[bool] = None
    cloneFromBranch: Optional[str] = Field(
        None,
        description='A configured branch name to clone from. If provided, all other parameters will be ignored. Only supported in POST requests.',
    )
    signed: Optional[bool] = None
    testsEnabled: Optional[bool] = None
    toolsets: Optional[Toolsets] = Field(
        None, description='The branch build configuration for each toolset'
    )
    trigger: Optional[Trigger] = None


class Field1AppsOwnerNameAppNameBranchesBranchConfigPutResponse(BaseModel):
    artifactVersioning: Optional[ArtifactVersioning] = Field(
        None,
        description='The versioning configuration for artifacts built for this branch',
    )
    badgeIsEnabled: Optional[bool] = None
    cloneFromBranch: Optional[str] = Field(
        None,
        description='A configured branch name to clone from. If provided, all other parameters will be ignored. Only supported in POST requests.',
    )
    signed: Optional[bool] = None
    testsEnabled: Optional[bool] = None
    toolsets: Optional[Toolsets] = Field(
        None, description='The branch build configuration for each toolset'
    )
    trigger: Optional[Trigger] = None
    id: int


class Field1AppsOwnerNameAppNameBranchesBranchExportConfigGetResponse(BaseModel):
    yaml: Optional[str] = Field(None, description='Azure Pipelines YAML file')


class Field1AppsOwnerNameAppNameBranchesBranchExportConfigGetResponseModel(BaseModel):
    code: str
    id: str
    message: str


class SigningConfig(BaseModel):
    hasStoreFile: Optional[bool] = Field(
        None,
        description='Indicates if storeFile is specified in the signing configuration',
    )


class BuildConfiguration(BaseModel):
    name: str = Field(
        ..., description='Name of build configuration (the same as a build type name)'
    )
    signingConfig: Optional[SigningConfig] = Field(
        None, description='Android signing config. Null if not specified'
    )


class AndroidModule(BaseModel):
    buildConfigurations: Optional[List[BuildConfiguration]] = Field(
        None, description='The detected build configurations of the Android module'
    )
    buildTypes: Optional[List[str]] = Field(
        None, description='The detected build types of the Android module'
    )
    buildVariants: Optional[List[str]] = Field(
        None,
        description='The detected build variants of the Android module (matrix of product flavor + build type (debug|release))',
    )
    hasBundle: Optional[bool] = Field(
        None, description='Module contains bundle settings'
    )
    isRoot: Optional[bool] = Field(
        None, description='Whether the module is at the root level of the project'
    )
    name: str = Field(..., description='Name of the Android module')
    productFlavors: Optional[List[str]] = Field(
        None, description='The product flavors of the Android module'
    )


class Android4Model(BaseModel):
    androidModules: List[AndroidModule] = Field(
        ..., description='Android Gradle modules'
    )
    gradleWrapperPath: Optional[str] = Field(
        None, description='The path of the Gradle wrapper'
    )


class JavascriptSolution(BaseModel):
    packageJsonPath: str = Field(
        ..., description='The path to the detected package.json'
    )
    reactNativeVersion: Optional[str] = Field(
        None, description='Version of React Native from package.json files'
    )


class Javascript4Model(BaseModel):
    javascriptSolutions: Optional[List[JavascriptSolution]] = Field(
        None, description='The React Native solutions detected'
    )
    packageJsonPaths: List[str] = Field(
        ..., description='Paths for detected package.json files'
    )


class FrameworkProperties(BaseModel):
    configurations: Optional[List[str]] = None


class FrameworkType(Enum):
    Appium = 'Appium'
    Calabash = 'Calabash'
    Espresso = 'Espresso'
    UITest = 'UITest'
    Generated = 'Generated'


class Project(BaseModel):
    frameworkProperties: Optional[FrameworkProperties] = None
    frameworkType: FrameworkType
    path: str = Field(..., description='The path to the TestCloud project')


class Testcloud(BaseModel):
    projects: List[Project] = Field(..., description='The TestCloud projects detected')


class UwpSolution(BaseModel):
    configurations: List[str] = Field(
        ..., description='The possible configurations detected for the UWP solution'
    )
    path: str = Field(..., description='The path to the UWP solution')


class Uwp(BaseModel):
    uwpSolutions: List[UwpSolution] = Field(
        ..., description='The UWP solutions detected'
    )


class XamarinSolution(BaseModel):
    configurations: List[str] = Field(..., description='Solution configurations')
    defaultConfiguration: Optional[str] = Field(
        None, description='Solution default configuration'
    )
    path: str = Field(..., description='Path to solution')


class Xamarin4Model(BaseModel):
    xamarinSolutions: List[XamarinSolution] = Field(
        ..., description='Xamarin solutions for the toolset'
    )


class AppExtensionTarget(BaseModel):
    name: str = Field(..., description='App extension name')
    targetBundleIdentifier: str = Field(
        ..., description='App extension bundle identifier'
    )


class ArchiveProject(BaseModel):
    archiveTargetId: str = Field(..., description='The Id of the target to archive')
    projectName: str = Field(..., description='The project to archive container name')
    projectPath: Optional[str] = Field(
        None, description='Full path of the target project'
    )


class SharedScheme(BaseModel):
    archiveConfiguration: Optional[str] = Field(
        None, description='Build configuration set in Archive action'
    )
    archiveProject: Optional[ArchiveProject] = None
    hasTestAction: bool = Field(..., description='Does scheme have a test action?')
    name: str = Field(..., description='Scheme name')


class XcodeSchemeContainer(BaseModel):
    appExtensionTargets: Optional[List[AppExtensionTarget]] = Field(
        None, description='Information regarding project app extensions, if present'
    )
    cartfilePath: Optional[str] = Field(
        None, description='Path to Carthage file, if present'
    )
    path: str = Field(..., description='Path to project')
    podfilePath: Optional[str] = Field(
        None, description='Path to CocoaPods file, if present'
    )
    sharedSchemes: List[SharedScheme] = Field(..., description='Project schemes')
    workspaceProjectPaths: Optional[str] = Field(
        None, description='Related projects paths for xcworkspace'
    )
    xcodeProjectSha: Optional[str] = Field(
        None, description='repo object Id of the pbxproject'
    )


class Xcode4Model(BaseModel):
    xcodeSchemeContainers: List[XcodeSchemeContainer] = Field(
        ..., description='The Xcode scheme containers'
    )


class Field1AppsOwnerNameAppNameBranchesBranchToolsetProjectsGetResponse(BaseModel):
    android: Optional[Android4Model] = None
    buildscripts: Optional[Any] = Field(
        None,
        description='A collection of detected pre/post buildscripts for current platform toolset',
    )
    commit: Optional[str] = Field(
        None, description='The commit hash of the analyzed commit'
    )
    javascript: Optional[Javascript4Model] = None
    testcloud: Optional[Testcloud] = None
    uwp: Optional[Uwp] = None
    xamarin: Optional[Xamarin4Model] = None
    xcode: Optional[Xcode4Model] = None


class EventType(Enum):
    newCrashGroupCreated = 'newCrashGroupCreated'
    newAppReleased = 'newAppReleased'


class Type84Model2(Enum):
    github = 'github'
    vsts = 'vsts'
    jira = 'jira'


class Settings(BaseModel):
    callback_url: Optional[str] = None
    owner_name: str
    type: Type84Model2 = Field(..., description='type of bugtracker')


class State15Model(Enum):
    enabled = 'enabled'
    disabled = 'disabled'
    unauthorized = 'unauthorized'


class Field1AppsOwnerNameAppNameBugtrackerGetResponse(BaseModel):
    event_types: Optional[List[EventType]] = Field(
        None, description='Event types enabled for bugtracker'
    )
    settings: Optional[Settings] = Field(
        None, description='Bugtracker specific settings', discriminator='type'
    )
    state: Optional[State15Model] = Field(None, description='bugtracker state')
    token_id: Optional[str] = Field(None, description='ID of OAuth token')
    type: Optional[Type84Model2] = Field(None, description='type of bugtracker')


class Code8Model13(Enum):
    integer_400 = 400
    integer_404 = 404
    integer_409 = 409
    integer_500 = 500


class Field1AppsOwnerNameAppNameBugtrackerGetResponseModel(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    code: Code8Model13 = Field(
        ...,
        description='The status code return by the API. It can be 400 or 404 or 409 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed'
    )


class BugTrackerType(Enum):
    github = 'github'
    vsts = 'vsts'
    jira = 'jira'


class Field1AppsOwnerNameAppNameBugtrackerCrashGroupCrashGroupIdGetResponse(BaseModel):
    bug_tracker_type: Optional[BugTrackerType] = None
    event_type: Optional[str] = None
    id: Optional[str] = None
    mobile_center_id: Optional[str] = None
    repo_name: Optional[str] = None
    title: Optional[str] = None
    url: Optional[str] = None


class Field1AppsOwnerNameAppNameBugtrackerCrashGroupCrashGroupIdGetResponseModel(
    BaseModel
):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    code: Code8Model13 = Field(
        ...,
        description='The status code return by the API. It can be 400 or 404 or 409 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed'
    )


class Field1AppsOwnerNameAppNameBuildServiceStatusGetResponse(BaseModel):
    message: Optional[str] = None
    os: Optional[str] = None
    service: Optional[str] = None
    status: Optional[str] = None
    url: Optional[str] = None
    valid_until: Optional[int] = None


class Field1AppsOwnerNameAppNameBuildsBuildIdGetResponse(BaseModel):
    buildNumber: str = Field(..., description='The build number')
    finishTime: Optional[str] = Field(
        None, description='The time the build was finished'
    )
    id: PositiveInt = Field(..., description='The build ID')
    lastChangedDate: Optional[str] = Field(
        None, description='The time the build status was last changed'
    )
    queueTime: str = Field(..., description='The time the build was queued')
    result: str = Field(..., description='The build result')
    sourceBranch: str = Field(..., description='The source branch name')
    sourceVersion: str = Field(..., description='The source SHA')
    startTime: Optional[str] = Field(None, description='The time the build was started')
    status: str = Field(..., description='The build status')


class Status(Enum):
    cancelling = 'cancelling'


class Field1AppsOwnerNameAppNameBuildsBuildIdPatchRequest(BaseModel):
    status: Optional[Status] = Field(
        None, description='The build status; used to cancel builds'
    )


class Field1AppsOwnerNameAppNameBuildsBuildIdPatchResponse(BaseModel):
    buildNumber: str = Field(..., description='The build number')
    finishTime: Optional[str] = Field(
        None, description='The time the build was finished'
    )
    id: PositiveInt = Field(..., description='The build ID')
    lastChangedDate: Optional[str] = Field(
        None, description='The time the build status was last changed'
    )
    queueTime: str = Field(..., description='The time the build was queued')
    result: str = Field(..., description='The build result')
    sourceBranch: str = Field(..., description='The source branch name')
    sourceVersion: str = Field(..., description='The source SHA')
    startTime: Optional[str] = Field(None, description='The time the build was started')
    status: str = Field(..., description='The build status')


class Type84Model3(Enum):
    store = 'store'
    group = 'group'
    tester = 'tester'


class Destination(BaseModel):
    id: str
    type: Type84Model3


class Field1AppsOwnerNameAppNameBuildsBuildIdDistributePostRequest(BaseModel):
    destinations: Optional[List[Destination]] = Field(
        None,
        description='Array of objects {id:string, type:string} with "id" being the distribution group ID, store ID, or tester email, and "type" being "group", "store", or "tester"',
    )
    mandatoryUpdate: Optional[bool] = None
    notifyTesters: Optional[bool] = True
    releaseNotes: Optional[str] = Field(None, description='The release notes')


class Field1AppsOwnerNameAppNameBuildsBuildIdDistributePostResponse(BaseModel):
    status: Optional[str] = Field(None, description='Status of the Request')
    upload_id: Optional[str] = Field(None, description='A unique ID of the upload')


class Field1AppsOwnerNameAppNameBuildsBuildIdDownloadsDownloadTypeGetResponse(
    BaseModel
):
    uri: str = Field(..., description='Download URI')


class Field1AppsOwnerNameAppNameBuildsBuildIdLogsGetResponse(BaseModel):
    value: Optional[List[str]] = None


class Author(BaseModel):
    date: Optional[str] = Field(None, description='Date and time of the commit')
    email: Optional[str] = Field(None, description="Author's email")
    name: Optional[str] = Field(None, description='Author name')


class Commit(BaseModel):
    author: Optional[Author] = None
    message: Optional[str] = Field(None, description='Commit message')


class Field1AppsOwnerNameAppNameCommitsBatchGetResponseItem(BaseModel):
    sha: Optional[str] = Field(None, description='The commit SHA')
    url: Optional[str] = Field(None, description='The URL to the commit')
    commit: Optional[Commit] = None


class Field1AppsOwnerNameAppNameCommitsBatchGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameCommitsBatchGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameCommitsBatchGetResponseItem] = Field(
        ..., description='A list of commits'
    )


class Language18Model(Enum):
    JavaScript = 'JavaScript'
    CSharp = 'CSharp'
    Objective_C = 'Objective-C'
    Objective_Cpp = 'Objective-Cpp'
    Cpp = 'Cpp'
    C = 'C'
    Swift = 'Swift'
    Java = 'Java'
    Unknown = 'Unknown'


class ReasonFrame(BaseModel):
    app_code: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    class_method: Optional[bool] = Field(None, description='is a class method')
    class_name: Optional[str] = Field(None, description='name of the class')
    code_formatted: Optional[str] = Field(None, description='Formatted frame string')
    code_raw: Optional[str] = Field(None, description='Unformatted Frame string')
    exception_type: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    framework_name: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language18Model] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    method_params: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    os_exception_type: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class Status31Model(Enum):
    open = 'open'
    closed = 'closed'
    ignored = 'ignored'


class CrashGroup3Model(BaseModel):
    annotation: str
    app_version: str
    build: str
    count: int
    crash_group_id: str
    crash_reason: str
    display_id: str
    exception: Optional[str] = None
    fatal: bool = Field(..., description='Crash or handled exception')
    first_occurrence: datetime_aliased
    impacted_users: Optional[int] = None
    last_occurrence: datetime_aliased
    new_crash_group_id: str
    reason_frame: Optional[ReasonFrame] = Field(
        None, description='frame belonging to the reason of the crash'
    )
    status: Status31Model


class Field1AppsOwnerNameAppNameCrashGroupsGetResponse(BaseModel):
    continuation_token: Optional[str] = Field(
        None,
        description='Cassandra request continuation token. The token is used for pagination.',
    )
    crash_groups: List[CrashGroup3Model]
    limited_result_set: bool


class Field1AppsOwnerNameAppNameCrashGroupsGetResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdGetResponse(BaseModel):
    annotation: str
    app_version: str
    build: str
    count: int
    crash_group_id: str
    crash_reason: str
    display_id: str
    exception: Optional[str] = None
    fatal: bool = Field(..., description='Crash or handled exception')
    first_occurrence: datetime_aliased
    impacted_users: Optional[int] = None
    last_occurrence: datetime_aliased
    new_crash_group_id: str
    reason_frame: Optional[ReasonFrame] = Field(
        None, description='frame belonging to the reason of the crash'
    )
    status: Status31Model


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdGetResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdPatchRequest(BaseModel):
    annotation: Optional[str] = None
    status: Optional[Status31Model] = None


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdPatchResponse(BaseModel):
    annotation: str
    app_version: str
    build: str
    count: int
    crash_group_id: str
    crash_reason: str
    display_id: str
    exception: Optional[str] = None
    fatal: bool = Field(..., description='Crash or handled exception')
    first_occurrence: datetime_aliased
    impacted_users: Optional[int] = None
    last_occurrence: datetime_aliased
    new_crash_group_id: str
    reason_frame: Optional[ReasonFrame] = Field(
        None, description='frame belonging to the reason of the crash'
    )
    status: Status31Model


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdPatchResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdCrashesGetResponse(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdCrashesCrashIdDeleteResponse(
    BaseModel
):
    app_id: Optional[str] = None
    attachments_deleted: Optional[int] = None
    blobs_failed: Optional[int] = None
    blobs_succeeded: Optional[int] = None
    crash_group_id: Optional[str] = None
    crash_id: Optional[str] = None
    crashes_deleted: Optional[int] = None


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdCrashesCrashIdDeleteResponseModel(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdCrashesCrashIdGetResponse(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdCrashesCrashIdNativeGetResponse(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdCrashesCrashIdNativeDownloadGetResponse(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdCrashesCrashIdRawLocationGetResponse(
    BaseModel
):
    uri: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdCrashesCrashIdRawLocationGetResponseModel(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdCrashesCrashIdStacktraceGetResponse(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdStacktraceGetResponse(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameCrashesCrashIdAttachmentsGetResponseItem(BaseModel):
    app_id: str
    attachment_id: str
    blob_location: str
    content_type: str
    crash_id: str
    created_time: datetime_aliased
    file_name: str
    size: float


class Field1AppsOwnerNameAppNameCrashesCrashIdAttachmentsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameCrashesCrashIdAttachmentsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameCrashesCrashIdAttachmentsGetResponseItem]


class Field1AppsOwnerNameAppNameCrashesCrashIdAttachmentsGetResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameCrashesCrashIdAttachmentsAttachmentIdLocationGetResponse(
    BaseModel
):
    uri: str


class Field1AppsOwnerNameAppNameCrashesCrashIdAttachmentsAttachmentIdLocationGetResponseModel(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameCrashesCrashIdAttachmentsAttachmentIdTextGetResponse(
    BaseModel
):
    message: str


class Type84Model4(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class Log6Model1(BaseModel):
    account_id: Optional[str] = Field(
        None, description='Account ID of the authenticated user.\n'
    )
    auth_provider: Optional[str] = Field(None, description='Auth service provider.\n')
    device: Device = Field(..., description='Device characteristics.')
    event_id: Optional[str] = Field(None, description='Event ID.\n')
    event_name: Optional[str] = Field(None, description='Event name.\n')
    install_id: UUID = Field(..., description='Install ID.\n')
    message_id: Optional[str] = Field(None, description='Message ID.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='event specific properties.\n'
    )
    session_id: Optional[UUID] = Field(None, description='Session ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type84Model4 = Field(..., description='Log type.\n')


class Field1AppsOwnerNameAppNameCrashesCrashIdSessionLogsGetResponse(BaseModel):
    exceeded_max_limit: Optional[bool] = Field(
        None,
        description='indicates if the number of available logs are more than the max allowed return limit(100).',
    )
    last_received_log_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='the timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.',
    )
    logs: List[Log6Model1] = Field(..., description='the list of logs', min_length=0)


class Code8Model14(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error8Model13(BaseModel):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameCrashesCrashIdSessionLogsGetResponseModel(BaseModel):
    error: Error8Model13


class Features(BaseModel):
    crash_download_raw: Optional[bool] = Field(
        None, description='App supports download of raw crashes'
    )
    crashgroup_analytics_crashfreeusers: Optional[bool] = Field(
        None, description="App supports the 'crash free user' metric"
    )
    crashgroup_analytics_impactedusers: Optional[bool] = Field(
        None, description="App supports the 'impacted users' metric"
    )
    crashgroup_modify_annotation: Optional[bool] = Field(
        None, description='App supports modification of crashgroup annotation'
    )
    crashgroup_modify_status: Optional[bool] = Field(
        None, description='App supports modification of crashgroup status'
    )
    search: Optional[bool] = Field(None, description='App supports search API')


class Field1AppsOwnerNameAppNameCrashesInfoGetResponse(BaseModel):
    features: Features
    has_crashes: bool


class Field1AppsOwnerNameAppNameCrashesInfoGetResponseModel(BaseModel):
    message: str


class DiffPackageMap(BaseModel):
    size: float
    url: str


class ReleaseMethod(Enum):
    Upload = 'Upload'
    Promote = 'Promote'
    Rollback = 'Rollback'


class LatestRelease(BaseModel):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    blob_url: Optional[str] = None
    diff_package_map: Optional[Dict[str, DiffPackageMap]] = None
    label: Optional[str] = None
    original_deployment: Optional[str] = Field(None, description="Set on 'Promote'")
    original_label: Optional[str] = Field(
        None, description="Set on 'Promote' and 'Rollback'"
    )
    package_hash: Optional[str] = None
    release_method: Optional[ReleaseMethod] = Field(
        None, description='The release method is unknown if unspecified'
    )
    released_by: Optional[str] = None
    size: Optional[float] = None
    upload_time: Optional[int] = None


class Field1AppsOwnerNameAppNameDeploymentsGetResponseItem(BaseModel):
    key: Optional[str] = None
    latest_release: Optional[LatestRelease] = None
    name: str


class Field1AppsOwnerNameAppNameDeploymentsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameDeploymentsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameDeploymentsGetResponseItem]


class Field1AppsOwnerNameAppNameDeploymentsGetResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsPostRequest(BaseModel):
    key: Optional[str] = None
    latest_release: Optional[LatestRelease] = None
    name: str


class Field1AppsOwnerNameAppNameDeploymentsPostResponse(BaseModel):
    key: Optional[str] = None
    latest_release: Optional[LatestRelease] = None
    name: str


class Field1AppsOwnerNameAppNameDeploymentsPostResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameDeleteRequest(BaseModel):
    pass


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameDeleteResponse(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameGetResponse(BaseModel):
    key: Optional[str] = None
    latest_release: Optional[LatestRelease] = None
    name: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameGetResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNamePatchRequest(BaseModel):
    name: constr(min_length=1, max_length=1000)


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNamePatchResponse(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameMetricsGetResponseItem(
    BaseModel
):
    active: int
    downloaded: Optional[int] = None
    failed: Optional[int] = None
    installed: Optional[int] = None
    label: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameMetricsGetResponse(
    RootModel[
        List[Field1AppsOwnerNameAppNameDeploymentsDeploymentNameMetricsGetResponseItem]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameDeploymentsDeploymentNameMetricsGetResponseItem
    ]


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameMetricsGetResponseModel(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNamePromoteReleasePromoteDeploymentNamePostRequest(
    BaseModel
):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    label: Optional[str] = None


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNamePromoteReleasePromoteDeploymentNamePostResponse(
    BaseModel
):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    blob_url: Optional[str] = None
    diff_package_map: Optional[Dict[str, DiffPackageMap]] = None
    label: Optional[str] = None
    original_deployment: Optional[str] = Field(None, description="Set on 'Promote'")
    original_label: Optional[str] = Field(
        None, description="Set on 'Promote' and 'Rollback'"
    )
    package_hash: Optional[str] = None
    release_method: Optional[ReleaseMethod] = Field(
        None, description='The release method is unknown if unspecified'
    )
    released_by: Optional[str] = None
    size: Optional[float] = None
    upload_time: Optional[int] = None


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNamePromoteReleasePromoteDeploymentNamePostResponseModel(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesDeleteResponse(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesGetResponseItem(
    BaseModel
):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    blob_url: Optional[str] = None
    diff_package_map: Optional[Dict[str, DiffPackageMap]] = None
    label: Optional[str] = None
    original_deployment: Optional[str] = Field(None, description="Set on 'Promote'")
    original_label: Optional[str] = Field(
        None, description="Set on 'Promote' and 'Rollback'"
    )
    package_hash: Optional[str] = None
    release_method: Optional[ReleaseMethod] = Field(
        None, description='The release method is unknown if unspecified'
    )
    released_by: Optional[str] = None
    size: Optional[float] = None
    upload_time: Optional[int] = None


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesGetResponse(
    RootModel[
        List[Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesGetResponseItem]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesGetResponseItem
    ]


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesGetResponseModel(
    BaseModel
):
    message: str


class ReleaseUpload(BaseModel):
    id: UUID = Field(
        ...,
        description='The ID for the newly created upload. It is going to be required later in the process.',
    )
    token: str = Field(
        ..., description='The URL encoded token used for upload permissions.'
    )
    upload_domain: str = Field(
        ..., description='The URL domain used to upload the release.'
    )


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesPostRequest(BaseModel):
    deployment_name: Optional[str] = Field(
        None,
        description='This specifies which deployment you want to release the update to. Default is Staging.',
    )
    description: Optional[str] = Field(
        None, description='This provides an optional "change log" for the deployment.'
    )
    disabled: Optional[bool] = Field(
        None,
        description='This specifies whether an update should be downloadable by end users or not.',
    )
    mandatory: Optional[bool] = Field(
        None,
        description='This specifies whether the update should be considered mandatory or not (e.g. it includes a critical security fix).',
    )
    no_duplicate_release_error: Optional[bool] = Field(
        None,
        description='This specifies that if the update is identical to the latest release on the deployment, the CLI should generate a warning instead of an error.',
    )
    release_upload: ReleaseUpload = Field(
        ..., description='The upload metadata from the release initialization step.'
    )
    rollout: Optional[int] = Field(
        None,
        description='This specifies the percentage of users (as an integer between 1 and 100) that should be eligible to receive this update.',
    )
    target_binary_version: str = Field(
        ..., description='the binary version of the application'
    )


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesPostResponse(
    BaseModel
):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    blob_url: Optional[str] = None
    diff_package_map: Optional[Dict[str, DiffPackageMap]] = None
    label: Optional[str] = None
    original_deployment: Optional[str] = Field(None, description="Set on 'Promote'")
    original_label: Optional[str] = Field(
        None, description="Set on 'Promote' and 'Rollback'"
    )
    package_hash: Optional[str] = None
    release_method: Optional[ReleaseMethod] = Field(
        None, description='The release method is unknown if unspecified'
    )
    released_by: Optional[str] = None
    size: Optional[float] = None
    upload_time: Optional[int] = None


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesPostResponseModel(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesReleaseLabelPatchRequest(
    BaseModel
):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesReleaseLabelPatchResponse(
    BaseModel
):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    blob_url: Optional[str] = None
    diff_package_map: Optional[Dict[str, DiffPackageMap]] = None
    label: Optional[str] = None
    original_deployment: Optional[str] = Field(None, description="Set on 'Promote'")
    original_label: Optional[str] = Field(
        None, description="Set on 'Promote' and 'Rollback'"
    )
    package_hash: Optional[str] = None
    release_method: Optional[ReleaseMethod] = Field(
        None, description='The release method is unknown if unspecified'
    )
    released_by: Optional[str] = None
    size: Optional[float] = None
    upload_time: Optional[int] = None


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameReleasesReleaseLabelPatchResponseModel(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameRollbackReleasePostRequest(
    BaseModel
):
    label: Optional[str] = None


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameRollbackReleasePostResponse(
    BaseModel
):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    blob_url: Optional[str] = None
    diff_package_map: Optional[Dict[str, DiffPackageMap]] = None
    label: Optional[str] = None
    original_deployment: Optional[str] = Field(None, description="Set on 'Promote'")
    original_label: Optional[str] = Field(
        None, description="Set on 'Promote' and 'Rollback'"
    )
    package_hash: Optional[str] = None
    release_method: Optional[ReleaseMethod] = Field(
        None, description='The release method is unknown if unspecified'
    )
    released_by: Optional[str] = None
    size: Optional[float] = None
    upload_time: Optional[int] = None


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameRollbackReleasePostResponseModel(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameUploadsPostResponse(BaseModel):
    id: UUID = Field(
        ...,
        description='The ID for the newly created upload. It is going to be required later in the process.',
    )
    token: str = Field(
        ..., description='The URL encoded token used for upload permissions.'
    )
    upload_domain: str = Field(
        ..., description='The URL domain used to upload the release.'
    )


class Field1AppsOwnerNameAppNameDeploymentsDeploymentNameUploadsPostResponseModel(
    BaseModel
):
    message: str


class Image(BaseModel):
    full: Optional[str] = None
    thumb: Optional[str] = None


class Cpu(BaseModel):
    core: Optional[str] = None
    frequency: Optional[str] = None
    text: Optional[str] = None


class Full(BaseModel):
    frameUrl: Optional[str] = None
    height: Optional[float] = None
    screen: Optional[List[float]] = None
    width: Optional[float] = None


class Grid(BaseModel):
    frameUrl: Optional[str] = None
    height: Optional[float] = None
    screen: Optional[List[float]] = None
    width: Optional[float] = None


class DeviceFrame(BaseModel):
    full: Optional[Full] = None
    grid: Optional[Grid] = None


class Dimensions(BaseModel):
    depth: Optional[Dict[str, Any]] = None
    height: Optional[Dict[str, Any]] = None
    width: Optional[Dict[str, Any]] = None


class Memory(BaseModel):
    formattedSize: Optional[str] = None


class Resolution(BaseModel):
    height: Optional[str] = None
    ppi: Optional[str] = None
    width: Optional[str] = None


class ScreenSize(BaseModel):
    cm: Optional[str] = None
    in_: Optional[str] = Field(None, alias='in')


class Model7Model1(BaseModel):
    availabilityCount: Optional[float] = None
    cpu: Optional[Cpu] = Field(None, description='CPU data for device')
    deviceFrame: Optional[DeviceFrame] = None
    dimensions: Optional[Dimensions] = Field(
        None, description='Physical device dimensions'
    )
    formFactor: Optional[str] = None
    manufacturer: Optional[str] = None
    memory: Optional[Memory] = Field(None, description='Memory data for device')
    model: Optional[str] = None
    name: Optional[str] = None
    platform: Optional[str] = None
    releaseDate: Optional[str] = None
    resolution: Optional[Resolution] = Field(
        None, description='Device screen resolution'
    )
    screenRotation: Optional[float] = None
    screenSize: Optional[ScreenSize] = Field(
        None, description='Physical device screen dimensions'
    )


class Field1AppsOwnerNameAppNameDeviceConfigurationsGetResponseItem(BaseModel):
    id: Optional[UUID] = Field(
        None, description='The unique id of the device configuration'
    )
    image: Optional[Image] = None
    marketShare: Optional[float] = None
    model: Optional[Model7Model1] = None
    name: Optional[str] = Field(
        None, description='The name of the device model and OS version'
    )
    os: Optional[str] = None
    osName: Optional[str] = None
    tier: Optional[float] = Field(None, description='The tier')


class Field1AppsOwnerNameAppNameDeviceConfigurationsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameDeviceConfigurationsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameDeviceConfigurationsGetResponseItem]


class Field1AppsOwnerNameAppNameDeviceSelectionPostRequest(BaseModel):
    devices: List[str]


class Field1AppsOwnerNameAppNameDeviceSelectionPostResponse(BaseModel):
    shortId: str = Field(..., description='Identifier of the device selection')


class Field1AppsOwnerNameAppNameDeviceSelectionPostResponseModel(BaseModel):
    message: str = Field(
        ..., description='Human-readable message that describes the error'
    )
    status: str = Field(..., description='Status of the operation')


class Status31Model1(Enum):
    missing = 'missing'
    ignored = 'ignored'
    available = 'available'


class MissingSymbol(BaseModel):
    name: str = Field(..., description='symbol name')
    platform: Optional[str] = Field(None, description='symbol plarform')
    status: Status31Model1 = Field(..., description='symbol status')
    symbol_id: str = Field(..., description='symbol id')


class Status31Model2(Enum):
    active = 'active'
    pending = 'pending'
    closed = 'closed'


class Group(BaseModel):
    app_build: str = Field(..., description='application build')
    app_id: str = Field(..., description='application id')
    app_ver: str = Field(..., description='application version')
    crash_count: Optional[int] = Field(
        None, description='number of crashes that belong to this group'
    )
    error_count: Optional[int] = Field(
        None, description='number of errors that belong to this group'
    )
    last_modified: datetime_aliased = Field(
        ..., description='last update date for the group'
    )
    missing_symbols: List[MissingSymbol] = Field(
        ..., description='list of missing symbols'
    )
    status: Status31Model2 = Field(..., description='group status')
    symbol_group_id: str = Field(..., description='id of the symbol group')


class Field1AppsOwnerNameAppNameDiagnosticsSymbolGroupsGetResponse(BaseModel):
    groups: List[Group] = Field(
        ..., description='list of crash groups formed by missing symbols combination'
    )
    total_crash_count: int = Field(
        ..., description='total number of crashes for all the groups'
    )


class Field1AppsOwnerNameAppNameDiagnosticsSymbolGroupsGetResponseModel(BaseModel):
    code: str
    message: str


class Status31Model3(Enum):
    missing = 'missing'
    ignored = 'ignored'
    available = 'available'


class Status31Model4(Enum):
    active = 'active'
    pending = 'pending'
    closed = 'closed'


class Field1AppsOwnerNameAppNameDiagnosticsSymbolGroupsSymbolGroupIdGetResponse(
    BaseModel
):
    groups: List[Group] = Field(
        ..., description='list of crash groups formed by missing symbols combination'
    )
    total_crash_count: int = Field(
        ..., description='total number of crashes for all the groups'
    )


class Field1AppsOwnerNameAppNameDiagnosticsSymbolGroupsSymbolGroupIdGetResponseModel(
    BaseModel
):
    code: str
    message: str


class Field1AppsOwnerNameAppNameDiagnosticsSymbolGroupsInfoGetResponse(BaseModel):
    total_crash_count: int = Field(
        ..., description='total number of crashes for all missing symbol groups'
    )


class Field1AppsOwnerNameAppNameDiagnosticsSymbolGroupsInfoGetResponseModel(BaseModel):
    code: str
    message: str


class Origin48Model1(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class Field1AppsOwnerNameAppNameDistributionGroupsGetResponseItem(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin48Model1 = Field(
        ..., description='The creation origin of this distribution group'
    )


class Field1AppsOwnerNameAppNameDistributionGroupsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameDistributionGroupsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameDistributionGroupsGetResponseItem]


class Field1AppsOwnerNameAppNameDistributionGroupsGetResponseModel(BaseModel):
    error: Error8Model13


class Field1AppsOwnerNameAppNameDistributionGroupsPostRequest(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The display name of the distribution group. If not specified, the name will be used.',
    )
    name: str = Field(..., description='The name of the distribution group')


class Field1AppsOwnerNameAppNameDistributionGroupsPostResponse(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin48Model1 = Field(
        ..., description='The creation origin of this distribution group'
    )


class Field1AppsOwnerNameAppNameDistributionGroupsPostResponseModel(BaseModel):
    error: Error8Model13


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameDeleteResponse(
    BaseModel
):
    error: Error8Model13


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameGetResponse(
    BaseModel
):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin48Model1 = Field(
        ..., description='The creation origin of this distribution group'
    )


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameGetResponseModel(
    BaseModel
):
    error: Error8Model13


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNamePatchRequest(
    BaseModel
):
    is_public: Optional[bool] = Field(
        None, description='Whether the distribution group is public'
    )
    name: Optional[str] = Field(None, description='The name of the distribution group')


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNamePatchResponse(
    BaseModel
):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin48Model1 = Field(
        ..., description='The creation origin of this distribution group'
    )


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNamePatchResponseModel(
    BaseModel
):
    error: Error8Model13


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameDevicesGetResponseItem(
    BaseModel
):
    device_name: str = Field(
        ..., description='The device description, in the format "iPhone 7 Plus (A1784)"'
    )
    full_device_name: Optional[str] = Field(
        None, description='A combination of the device model name and the owner name.'
    )
    imei: Optional[str] = Field(
        None,
        description="The device's International Mobile Equipment Identity number. Always empty or undefined at present.",
    )
    model: str = Field(
        ..., description='The model identifier of the device, in the format iDeviceM,N'
    )
    os_build: str = Field(
        ..., description='The last known OS version running on the device'
    )
    os_version: str = Field(
        ..., description='The last known OS version running on the device'
    )
    owner_id: Optional[str] = Field(
        None, description='The user ID of the device owner.'
    )
    registered_at: Optional[str] = Field(
        None, description='Timestamp of when the device was registered in ISO format.'
    )
    serial: Optional[str] = Field(
        None,
        description="The device's serial number. Always empty or undefined at present.",
    )
    status: str = Field(..., description='The provisioning status of the device.')
    udid: str = Field(..., description='The Unique Device IDentifier of the device')


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameDevicesGetResponse(
    RootModel[
        List[
            Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameDevicesGetResponseItem
        ]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameDevicesGetResponseItem
    ]


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameDevicesGetResponseModel(
    BaseModel
):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameDevicesDownloadDevicesListGetResponse(
    BaseModel
):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersGetResponseItem(
    BaseModel
):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: Optional[UUID] = Field(None, description='The unique id (UUID) of the user')
    invite_pending: Optional[bool] = Field(
        None,
        description='Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".',
    )
    name: Optional[str] = Field(
        None, description='The unique name that is used to identify the user.'
    )


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersGetResponse(
    RootModel[
        List[
            Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersGetResponseItem
        ]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersGetResponseItem
    ]


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersGetResponseModel(
    BaseModel
):
    error: Error8Model13


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersPostRequest(
    BaseModel
):
    user_emails: Optional[List[str]] = Field(
        None, description='The list of emails of the users', min_length=1
    )


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersPostResponseItem(
    BaseModel
):
    code: Optional[str] = Field(None, description='The code of the result')
    invite_pending: Optional[bool] = Field(
        None,
        description='Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".',
    )
    message: Optional[str] = Field(None, description='The message of the result')
    status: int = Field(..., description='The status code of the result')
    user_email: Optional[str] = Field(None, description='The email of the user')


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersPostResponse(
    RootModel[
        List[
            Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersPostResponseItem
        ]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersPostResponseItem
    ]


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersPostResponseModel(
    BaseModel
):
    error: Error8Model13


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersBulkDeletePostRequest(
    BaseModel
):
    user_emails: Optional[List[str]] = Field(
        None, description='The list of emails of the users', min_length=1
    )


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersBulkDeletePostResponseItem(
    BaseModel
):
    code: Optional[str] = Field(None, description='The code of the result')
    message: Optional[int] = Field(None, description='The message of the result')
    status: int = Field(..., description='The status code of the result')
    user_email: Optional[str] = Field(None, description='The email of the user')


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersBulkDeletePostResponse(
    RootModel[
        List[
            Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersBulkDeletePostResponseItem
        ]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersBulkDeletePostResponseItem
    ]


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameMembersBulkDeletePostResponseModel(
    BaseModel
):
    error: Error8Model13


class Origin48Model2(Enum):
    hockeyapp = 'hockeyapp'
    appcenter = 'appcenter'


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameReleasesGetResponseItem(
    BaseModel
):
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    id: int = Field(..., description='ID identifying this unique release.')
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    mandatory_update: bool = Field(
        ...,
        description='A boolean which determines whether the release is a mandatory update or not.',
    )
    origin: Optional[Origin48Model2] = Field(None, description="The release's origin")
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameReleasesGetResponse(
    RootModel[
        List[
            Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameReleasesGetResponseItem
        ]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameReleasesGetResponseItem
    ] = Field(
        ...,
        description='Response for getting a list of releases in a distribution group',
    )


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameReleasesGetResponseModel(
    BaseModel
):
    code: Code8Model14
    message: str


class Build(BaseModel):
    branch_name: Optional[str] = Field(
        None, description='The branch name of the build producing the release'
    )
    commit_hash: Optional[str] = Field(
        None, description='The commit hash of the build producing the release'
    )
    commit_message: Optional[str] = Field(
        None, description='The commit message of the build producing the release'
    )


class DestinationType(Enum):
    group = 'group'
    store = 'store'
    tester = 'tester'


class Type84Model5(Enum):
    intune = 'intune'
    googleplay = 'googleplay'
    apple = 'apple'
    none = 'none'


class Destination8Model(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution group.',
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type84Model5] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )
    destination_type: Optional[DestinationType] = Field(
        None, description='Destination can be either store or group.'
    )
    display_name: Optional[str] = Field(
        None, description='Display name for the group or tester'
    )


class DistributionGroup(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )


class DistributionStore(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution store.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type84Model5] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )


class ProvisioningProfileType(Enum):
    adhoc = 'adhoc'
    enterprise = 'enterprise'
    other = 'other'


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameReleasesReleaseIdGetResponse(
    BaseModel
):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: str = Field(..., description="The app's display name.")
    app_icon_url: str = Field(..., description="A URL to the app's icon.")
    app_name: str = Field(
        ..., description="The app's name (extracted from the uploaded release)."
    )
    app_os: Optional[str] = Field(None, description="The app's OS.")
    build: Optional[Build] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    can_resign: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value determines if a release can be re-signed. When true, after a re-sign, the tester will be able to install the release from his registered devices. Will not be returned for non-iOS platforms.',
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned.<br>\n<b>tester</b>: The release distributed testers details will be returned.<br>\n',
    )
    destinations: Optional[List[Destination8Model]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    device_family: Optional[str] = Field(
        None, description="The release's device family."
    )
    distribution_groups: Optional[List[DistributionGroup]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    install_url: Optional[str] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    is_provisioning_profile_syncing: Optional[bool] = Field(
        None,
        description="A flag that determines whether the release's provisioning profile is still extracted or not.",
    )
    is_udid_provisioned: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value will hold the provisioning status of that UDID in this release. Will be ignored for non-iOS platforms.',
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    origin: Optional[Origin48Model2] = Field(None, description="The release's origin")
    package_hashes: Optional[List[str]] = Field(
        None, description='Hashes for the packages.'
    )
    provisioning_profile_expiry_date: Optional[str] = Field(
        None, description='expiration date of provisioning profile in UTC format.'
    )
    provisioning_profile_name: Optional[str] = Field(
        None, description="The release's provisioning profile name."
    )
    provisioning_profile_type: Optional[ProvisioningProfileType] = Field(
        None,
        description='The type of the provisioning profile for the requested app version.',
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    secondary_download_url: Optional[str] = Field(
        None,
        description='The URL that hosts the secondary binary for this release, such as the apk file for aab releases.',
    )
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[int] = Field(None, description="The release's size in bytes.")
    status: Optional[str] = Field(None, description='Status of the release.')
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameReleasesReleaseIdGetResponseModel(
    BaseModel
):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameResendInvitePostRequest(
    BaseModel
):
    user_emails: Optional[List[str]] = Field(
        None, description='The list of emails of the users', min_length=1
    )


class Field1AppsOwnerNameAppNameDistributionGroupsDistributionGroupNameResendInvitePostResponse(
    BaseModel
):
    error: Error8Model13


class AppCategory(BaseModel):
    id: Optional[str] = Field(None, description='ID for the category.')
    name: Optional[str] = Field(None, description='display name for the app category')


class TargetAudience(BaseModel):
    id: Optional[str] = Field(None, description='ID for the target audience/group.')
    name: Optional[str] = Field(
        None, description='display name for the target audience/group'
    )


class IntuneDetails(BaseModel):
    app_category: Optional[AppCategory] = None
    target_audience: Optional[TargetAudience] = None


class Track(Enum):
    production = 'production'
    alpha = 'alpha'
    beta = 'beta'
    testflight_internal = 'testflight-internal'
    testflight_external = 'testflight-external'


class Field1AppsOwnerNameAppNameDistributionStoresGetResponseItem(BaseModel):
    created_by: Optional[str] = Field(
        None, description='The ID of the principal that created the store.'
    )
    created_by_principal_type: Optional[str] = Field(
        None, description='The type of the principal that created the store.'
    )
    id: Optional[str] = Field(None, description='Store id')
    intune_details: Optional[IntuneDetails] = Field(
        None, description='Store details for intune'
    )
    name: Optional[str] = Field(None, description='Store Name')
    service_connection_id: Optional[str] = Field(
        None,
        description='Id for the shared service connection. In case of Apple / GooglePlay stores, this connection will be used to connect to the Apple / Google stores in App Center.',
    )
    track: Optional[Track] = Field(None, description='Store track')
    type: Optional[str] = Field(None, description='Store Type')


class Field1AppsOwnerNameAppNameDistributionStoresGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameDistributionStoresGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameDistributionStoresGetResponseItem]


class AppCategory6Model(BaseModel):
    name: Optional[str] = Field(None, description='display name for the app category')


class SecretJson(BaseModel):
    id_token: Optional[str] = Field(None, description='the id token of user')
    refresh_token: Optional[str] = Field(None, description='the refresh token for user')
    refresh_token_expiry: Optional[str] = Field(
        None, description='the expiry of refresh token'
    )


class TargetAudience6Model(BaseModel):
    name: Optional[str] = Field(
        None, description='display name for the target audience/group'
    )


class IntuneDetails3Model(BaseModel):
    app_category: Optional[AppCategory6Model] = None
    secret_json: Optional[SecretJson] = None
    target_audience: Optional[TargetAudience6Model] = None
    tenant_id: Optional[str] = Field(None, description='tenant id of the intune store')


class Type84Model6(Enum):
    googleplay = 'googleplay'
    apple = 'apple'
    intune = 'intune'


class Field1AppsOwnerNameAppNameDistributionStoresPostRequest(BaseModel):
    intune_details: Optional[IntuneDetails3Model] = None
    name: Optional[str] = Field(
        None,
        description='name of the store. In case of googleplay, and Apple store this is fixed to Production.',
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.',
    )
    track: Optional[Track] = Field(
        None,
        description='track of the store. Can be production, alpha & beta for googleplay. Can be production, testflight-internal & testflight-external for Apple Store.',
    )
    type: Optional[Type84Model6] = Field(None, description='store Type')


class AppCategory6Model1(BaseModel):
    id: Optional[str] = Field(None, description='ID for the category.')
    name: Optional[str] = Field(None, description='display name for the app category')


class TargetAudience6Model1(BaseModel):
    id: Optional[str] = Field(None, description='ID for the target audience/group.')
    name: Optional[str] = Field(
        None, description='display name for the target audience/group'
    )


class IntuneDetails3Model1(BaseModel):
    app_category: Optional[AppCategory6Model1] = None
    target_audience: Optional[TargetAudience6Model1] = None


class Field1AppsOwnerNameAppNameDistributionStoresPostResponse(BaseModel):
    created_by: Optional[str] = Field(
        None, description='The ID of the principal that created the store.'
    )
    created_by_principal_type: Optional[str] = Field(
        None, description='The type of the principal that created the store.'
    )
    id: Optional[str] = Field(None, description='Store id')
    intune_details: Optional[IntuneDetails3Model1] = Field(
        None, description='Store details for intune'
    )
    name: Optional[str] = Field(None, description='Store Name')
    service_connection_id: Optional[str] = Field(
        None,
        description='Id for the shared service connection. In case of Apple / GooglePlay stores, this connection will be used to connect to the Apple / Google stores in App Center.',
    )
    track: Optional[Track] = Field(None, description='Store track')
    type: Optional[str] = Field(None, description='Store Type')


class Field1AppsOwnerNameAppNameDistributionStoresPostResponseModel(BaseModel):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameDeleteResponse(BaseModel):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameGetResponse(BaseModel):
    created_by: Optional[str] = Field(
        None, description='The ID of the principal that created the store.'
    )
    created_by_principal_type: Optional[str] = Field(
        None, description='The type of the principal that created the store.'
    )
    id: Optional[str] = Field(None, description='Store id')
    intune_details: Optional[IntuneDetails3Model1] = Field(
        None, description='Store details for intune'
    )
    name: Optional[str] = Field(None, description='Store Name')
    service_connection_id: Optional[str] = Field(
        None,
        description='Id for the shared service connection. In case of Apple / GooglePlay stores, this connection will be used to connect to the Apple / Google stores in App Center.',
    )
    track: Optional[Track] = Field(None, description='Store track')
    type: Optional[str] = Field(None, description='Store Type')


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameGetResponseModel(BaseModel):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameDistributionStoresStoreNamePatchRequest(BaseModel):
    service_connection_id: str = Field(
        ..., description='Service connection id to updated.'
    )


class Field1AppsOwnerNameAppNameDistributionStoresStoreNamePatchResponse(BaseModel):
    code: Code8Model14
    message: str


class Type84Model7(Enum):
    intune = 'intune'
    googleplay = 'googleplay'


class DistributionStore5Model(BaseModel):
    id: Optional[str] = Field(
        None, description='ID identifying a unique distribution store.'
    )
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type84Model7] = Field(
        None,
        description='type of the distribution store currently stores type can be intune or googleplay.',
    )


class InstallUrl(Enum):
    group = 'group'
    store = 'store'


class Status31Model5(Enum):
    available = 'available'
    unavailable = 'unavailable'


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameLatestReleaseGetResponseItem(
    BaseModel
):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: Optional[str] = Field(None, description="The app's display name.")
    app_name: Optional[str] = Field(
        None, description="The app's name (extracted from the uploaded release)."
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    distribution_stores: Optional[List[DistributionStore5Model]] = Field(
        None,
        description='a list of distribution stores that are associated with this release.',
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: Optional[float] = Field(None, description='ID identifying this unique release.')
    install_url: Optional[InstallUrl] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    short_version: Optional[str] = Field(
        None,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[float] = Field(None, description="The release's size in bytes.")
    status: Optional[Status31Model5] = Field(
        None,
        description="OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>\nThe release state.<br>\n<b>available</b>: The uploaded release has been distributed.<br>\n<b>unavailable</b>: The uploaded release is not visible to the user. <br>\n",
    )
    uploaded_at: Optional[str] = Field(
        None, description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: Optional[str] = Field(
        None,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameLatestReleaseGetResponse(
    RootModel[
        List[
            Field1AppsOwnerNameAppNameDistributionStoresStoreNameLatestReleaseGetResponseItem
        ]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameDistributionStoresStoreNameLatestReleaseGetResponseItem
    ]


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameLatestReleaseGetResponseModel(
    BaseModel
):
    code: Code8Model14
    message: str


class Type84Model8(Enum):
    googleplay = 'googleplay'
    intune = 'intune'
    apple = 'apple'


class DistributionStore5Model1(BaseModel):
    id: Optional[str] = Field(
        None, description='ID identifying a unique distribution store.'
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution store.',
    )
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None,
        description='A status identifying the status of release in the distribution store.',
    )
    type: Optional[Type84Model8] = Field(
        None, description='A type identifying the type of distribution store.'
    )


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesGetResponseItem(
    BaseModel
):
    destination_type: Optional[DestinationType] = Field(
        None, description='Destination for this release.'
    )
    distribution_stores: Optional[List[DistributionStore5Model1]] = Field(
        None,
        description='a list of distribution stores that are associated with this release.',
    )
    id: Optional[float] = Field(None, description='ID identifying this unique release.')
    short_version: Optional[str] = Field(
        None,
        description="The release's short version.\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: Optional[str] = Field(
        None, description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: Optional[str] = Field(
        None,
        description="The release's version.\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesGetResponse(
    RootModel[
        List[
            Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesGetResponseItem
        ]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesGetResponseItem
    ]


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesGetResponseModel(
    BaseModel
):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdDeleteResponse(
    BaseModel
):
    code: Code8Model14
    message: str


class Type84Model9(Enum):
    intune = 'intune'
    googleplay = 'googleplay'


class DistributionStore5Model2(BaseModel):
    id: Optional[str] = Field(
        None, description='ID identifying a unique distribution store.'
    )
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type84Model9] = Field(
        None,
        description='type of the distribution store currently stores type can be intune or googleplay.',
    )


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdGetResponseItem(
    BaseModel
):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: Optional[str] = Field(None, description="The app's display name.")
    app_name: Optional[str] = Field(
        None, description="The app's name (extracted from the uploaded release)."
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    distribution_stores: Optional[List[DistributionStore5Model2]] = Field(
        None,
        description='a list of distribution stores that are associated with this release.',
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: Optional[float] = Field(None, description='ID identifying this unique release.')
    install_url: Optional[InstallUrl] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    short_version: Optional[str] = Field(
        None,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[float] = Field(None, description="The release's size in bytes.")
    status: Optional[Status31Model5] = Field(
        None,
        description="OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>\nThe release state.<br>\n<b>available</b>: The uploaded release has been distributed.<br>\n<b>unavailable</b>: The uploaded release is not visible to the user. <br>\n",
    )
    uploaded_at: Optional[str] = Field(
        None, description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: Optional[str] = Field(
        None,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdGetResponse(
    RootModel[
        List[
            Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdGetResponseItem
        ]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdGetResponseItem
    ]


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdGetResponseModel(
    BaseModel
):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdPublishErrorDetailsGetResponse(
    BaseModel
):
    is_log_available: Optional[bool] = Field(
        None, description='boolean property to tell if logs are available for download'
    )
    message: Optional[str] = Field(None, description='error Details')


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdPublishErrorDetailsGetResponseModel(
    BaseModel
):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdPublishLogsGetResponse(
    BaseModel
):
    code: Code8Model14
    message: str


class Status31Model6(BaseModel):
    status: Optional[str] = Field(None, description='status from store')
    storetype: Optional[str] = Field(None, description='store type')
    track: Optional[str] = Field(None, description='track information from store')
    version: Optional[str] = Field(None, description='version of the app from store')


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdRealtimestatusGetResponse(
    BaseModel
):
    app_id: Optional[str] = Field(None, description='app id')
    release_id: Optional[str] = Field(None, description='release id')
    status: Optional[Status31Model6] = Field(None, description='Status Data from store')


class Field1AppsOwnerNameAppNameDistributionStoresStoreNameReleasesReleaseIdRealtimestatusGetResponseModel(
    BaseModel
):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameErrorsAvailableAppBuildsGetResponse(BaseModel):
    appBuilds: Optional[List[str]] = None


class Field1AppsOwnerNameAppNameErrorsAvailableAppBuildsGetResponseModel(BaseModel):
    error: Error8Model13


class Field1AppsOwnerNameAppNameErrorsAvailableVersionsGetResponse(BaseModel):
    total_count: Optional[int] = Field(
        None, description='The full number of versions across all pages.'
    )
    versions: Optional[List[str]] = Field(
        None, description='List of available versions.'
    )


class Field1AppsOwnerNameAppNameErrorsAvailableVersionsGetResponseModel(BaseModel):
    error: Error8Model13


class Error8Model14(BaseModel):
    count: Optional[int] = Field(None, description='count of the object')
    datetime: Optional[str] = Field(None, description='the ISO 8601 datetime')


class Field1AppsOwnerNameAppNameErrorsErrorCountsPerDayGetResponse(BaseModel):
    count: Optional[int] = Field(None, description='total error count')
    errors: Optional[List[Error8Model14]] = Field(
        None, description='the total error count for day'
    )


class Error8Model15(BaseModel):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameErrorsErrorCountsPerDayGetResponseModel(BaseModel):
    error: Error8Model15


class ReasonFrame7Model(BaseModel):
    appCode: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    classMethod: Optional[bool] = Field(None, description='is a class method')
    className: Optional[str] = Field(None, description='name of the class')
    codeFormatted: Optional[str] = Field(None, description='Formatted frame string')
    codeRaw: Optional[str] = Field(None, description='Unformatted Frame string')
    exceptionType: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    frameworkName: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language18Model] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    methodParams: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    osExceptionType: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class State15Model1(Enum):
    open = 'open'
    closed = 'closed'
    ignored = 'ignored'


class ErrorGroup(BaseModel):
    appBuild: Optional[str] = None
    appVersion: str
    codeRaw: Optional[str] = None
    count: int
    deviceCount: int
    errorGroupId: str
    exceptionAppCode: Optional[bool] = None
    exceptionClassMethod: Optional[bool] = None
    exceptionClassName: Optional[str] = None
    exceptionFile: Optional[str] = None
    exceptionLine: Optional[str] = None
    exceptionMessage: Optional[str] = None
    exceptionMethod: Optional[str] = None
    exceptionType: Optional[str] = None
    firstOccurrence: datetime_aliased
    hidden: Optional[bool] = None
    lastOccurrence: datetime_aliased
    reasonFrames: Optional[List[ReasonFrame7Model]] = None
    annotation: Optional[str] = None
    state: State15Model1


class Field1AppsOwnerNameAppNameErrorsErrorGroupsGetResponse(BaseModel):
    errorGroups: Optional[List[ErrorGroup]] = None
    nextLink: Optional[str] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsGetResponseModel(BaseModel):
    error: Error8Model15


class Field1AppsOwnerNameAppNameErrorsErrorGroupsSearchGetResponse(BaseModel):
    errorGroups: Optional[List[ErrorGroup]] = None
    hasMoreResults: Optional[bool] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsSearchGetResponseModel(BaseModel):
    error: Error8Model15


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdGetResponse(BaseModel):
    annotation: Optional[str] = None
    state: State15Model1
    appBuild: Optional[str] = None
    appVersion: str
    codeRaw: Optional[str] = None
    count: int
    deviceCount: int
    errorGroupId: str
    exceptionAppCode: Optional[bool] = None
    exceptionClassMethod: Optional[bool] = None
    exceptionClassName: Optional[str] = None
    exceptionFile: Optional[str] = None
    exceptionLine: Optional[str] = None
    exceptionMessage: Optional[str] = None
    exceptionMethod: Optional[str] = None
    exceptionType: Optional[str] = None
    firstOccurrence: datetime_aliased
    hidden: Optional[bool] = None
    lastOccurrence: datetime_aliased
    reasonFrames: Optional[List[ReasonFrame7Model]] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdGetResponseModel(
    BaseModel
):
    error: Error8Model15


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdPatchRequest(BaseModel):
    annotation: Optional[str] = None
    state: State15Model1


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdPatchResponse(BaseModel):
    annotation: Optional[str] = None
    state: State15Model1
    appBuild: Optional[str] = None
    appVersion: str
    codeRaw: Optional[str] = None
    count: int
    deviceCount: int
    errorGroupId: str
    exceptionAppCode: Optional[bool] = None
    exceptionClassMethod: Optional[bool] = None
    exceptionClassName: Optional[str] = None
    exceptionFile: Optional[str] = None
    exceptionLine: Optional[str] = None
    exceptionMessage: Optional[str] = None
    exceptionMethod: Optional[str] = None
    exceptionType: Optional[str] = None
    firstOccurrence: datetime_aliased
    hidden: Optional[bool] = None
    lastOccurrence: datetime_aliased
    reasonFrames: Optional[List[ReasonFrame7Model]] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdPatchResponseModel(
    BaseModel
):
    error: Error8Model15


class Error8Model16(BaseModel):
    count: Optional[int] = Field(None, description='count of the object')
    datetime: Optional[str] = Field(None, description='the ISO 8601 datetime')


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorCountsPerDayGetResponse(
    BaseModel
):
    count: Optional[int] = Field(None, description='total error count')
    errors: Optional[List[Error8Model16]] = Field(
        None, description='the total error count for day'
    )


class Error8Model17(BaseModel):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorCountsPerDayGetResponseModel(
    BaseModel
):
    error: Error8Model17


class DailyPercentage2Model(BaseModel):
    datetime: Optional[str] = Field(None, description='the ISO 8601 datetime')
    percentage: Optional[float] = Field(None, description='percentage of the object')


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorfreeDevicePercentagesGetResponse(
    BaseModel
):
    averagePercentage: Optional[float] = Field(None, description='Average percentage')
    dailyPercentages: Optional[List[DailyPercentage2Model]] = Field(
        None, description='The error-free percentage per day.'
    )


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorfreeDevicePercentagesGetResponseModel(
    BaseModel
):
    error: Error8Model17


class Error8Model18(BaseModel):
    country: Optional[str] = None
    deviceName: Optional[str] = None
    errorId: Optional[str] = None
    hasAttachments: Optional[bool] = None
    hasBreadcrumbs: Optional[bool] = None
    language: Optional[str] = None
    osType: Optional[str] = None
    osVersion: Optional[str] = None
    timestamp: Optional[datetime_aliased] = None
    userId: Optional[str] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsGetResponse(
    BaseModel
):
    errors: Optional[List[Error8Model18]] = Field(None, description='Errors list.')
    nextLink: Optional[str] = None


class Error8Model19(BaseModel):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsGetResponseModel(
    BaseModel
):
    error: Error8Model19


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsLatestGetResponse(
    BaseModel
):
    country: Optional[str] = None
    deviceName: Optional[str] = None
    errorId: Optional[str] = None
    hasAttachments: Optional[bool] = None
    hasBreadcrumbs: Optional[bool] = None
    language: Optional[str] = None
    osType: Optional[str] = None
    osVersion: Optional[str] = None
    timestamp: Optional[datetime_aliased] = None
    userId: Optional[str] = None
    appLaunchTimestamp: Optional[datetime_aliased] = Field(
        None,
        description="Timestamp when the app was launched, example: '2017-03-13T18:05:42Z'.\n",
    )
    carrierName: Optional[str] = Field(
        None, description='Carrier name (for mobile devices).\n'
    )
    jailbreak: Optional[bool] = Field(
        None, description='Flag indicating if device is jailbroken\n'
    )
    name: Optional[str] = None
    properties: Optional[Dict[str, str]] = None
    reasonFrames: Optional[List[ReasonFrame7Model]] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsLatestGetResponseModel(
    BaseModel
):
    error: Error8Model19


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsErrorIdDeleteResponse(
    BaseModel
):
    appId: Optional[str] = None
    attachmentsDeleted: Optional[int] = None
    blobsFailed: Optional[int] = None
    blobsSucceeded: Optional[int] = None
    errorGroupId: Optional[str] = None
    errorId: Optional[str] = None
    errorsDeleted: Optional[int] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsErrorIdDeleteResponseModel(
    BaseModel
):
    error: Error8Model19


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsErrorIdGetResponse(
    BaseModel
):
    country: Optional[str] = None
    deviceName: Optional[str] = None
    errorId: Optional[str] = None
    hasAttachments: Optional[bool] = None
    hasBreadcrumbs: Optional[bool] = None
    language: Optional[str] = None
    osType: Optional[str] = None
    osVersion: Optional[str] = None
    timestamp: Optional[datetime_aliased] = None
    userId: Optional[str] = None
    appLaunchTimestamp: Optional[datetime_aliased] = Field(
        None,
        description="Timestamp when the app was launched, example: '2017-03-13T18:05:42Z'.\n",
    )
    carrierName: Optional[str] = Field(
        None, description='Carrier name (for mobile devices).\n'
    )
    jailbreak: Optional[bool] = Field(
        None, description='Flag indicating if device is jailbroken\n'
    )
    name: Optional[str] = None
    properties: Optional[Dict[str, str]] = None
    reasonFrames: Optional[List[ReasonFrame7Model]] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsErrorIdGetResponseModel(
    BaseModel
):
    error: Error8Model19


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsErrorIdDownloadGetResponse(
    BaseModel
):
    pass


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsErrorIdDownloadGetResponseModel(
    BaseModel
):
    error: Error8Model19


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsErrorIdLocationGetResponse(
    BaseModel
):
    uri: Optional[str] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsErrorIdLocationGetResponseModel(
    BaseModel
):
    error: Error8Model19


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdErrorsErrorIdStacktraceGetResponse(
    BaseModel
):
    error: Error8Model19


class Model7Model2(BaseModel):
    errorCount: Optional[int] = Field(None, description='count of errors in a model')
    modelCode: Optional[str] = Field(None, description='model code')
    modelName: Optional[str] = Field(None, description='model name')


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdModelsGetResponse(
    BaseModel
):
    errorCount: Optional[int] = None
    models: Optional[List[Model7Model2]] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdModelsGetResponseModel(
    BaseModel
):
    error: Error8Model19


class OperatingSystem2Model(BaseModel):
    errorCount: Optional[int] = Field(None, description='count of OS')
    operatingSystemName: Optional[str] = Field(None, description='OS name')


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdOperatingSystemsGetResponse(
    BaseModel
):
    errorCount: Optional[int] = None
    operatingSystems: Optional[List[OperatingSystem2Model]] = None


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdOperatingSystemsGetResponseModel(
    BaseModel
):
    error: Error8Model19


class Field1AppsOwnerNameAppNameErrorsErrorGroupsErrorGroupIdStacktraceGetResponse(
    BaseModel
):
    error: Error8Model19


class Field1AppsOwnerNameAppNameErrorsErrorfreeDevicePercentagesGetResponse(BaseModel):
    averagePercentage: Optional[float] = Field(None, description='Average percentage')
    dailyPercentages: Optional[List[DailyPercentage2Model]] = Field(
        None, description='The error-free percentage per day.'
    )


class Field1AppsOwnerNameAppNameErrorsErrorfreeDevicePercentagesGetResponseModel(
    BaseModel
):
    error: Error8Model19


class RetentionInDays(Enum):
    integer_28 = 28


class Field1AppsOwnerNameAppNameErrorsRetentionSettingsGetResponse(BaseModel):
    retention_in_days: RetentionInDays


class Field1AppsOwnerNameAppNameErrorsRetentionSettingsGetResponseModel(BaseModel):
    error: Error8Model19


class Error8Model20(BaseModel):
    country: Optional[str] = None
    deviceName: Optional[str] = None
    errorId: Optional[str] = None
    hasAttachments: Optional[bool] = None
    hasBreadcrumbs: Optional[bool] = None
    language: Optional[str] = None
    osType: Optional[str] = None
    osVersion: Optional[str] = None
    timestamp: Optional[datetime_aliased] = None
    userId: Optional[str] = None


class Field1AppsOwnerNameAppNameErrorsSearchGetResponse(BaseModel):
    errors: Optional[List[Error8Model20]] = None
    hasMoreResults: Optional[bool] = None


class Error8Model21(BaseModel):
    code: Code8Model14
    message: str


class Field1AppsOwnerNameAppNameErrorsSearchGetResponseModel(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameErrorsErrorIdAttachmentsGetResponseItem(BaseModel):
    appId: Optional[str] = None
    attachmentId: Optional[str] = None
    blobLocation: Optional[str] = None
    contentType: Optional[str] = None
    crashId: Optional[str] = None
    createdTime: Optional[datetime_aliased] = None
    fileName: Optional[str] = None
    size: Optional[int] = None


class Field1AppsOwnerNameAppNameErrorsErrorIdAttachmentsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameErrorsErrorIdAttachmentsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameErrorsErrorIdAttachmentsGetResponseItem]


class Field1AppsOwnerNameAppNameErrorsErrorIdAttachmentsGetResponseModel(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameErrorsErrorIdAttachmentsAttachmentIdLocationGetResponse(
    BaseModel
):
    uri: Optional[str] = None


class Field1AppsOwnerNameAppNameErrorsErrorIdAttachmentsAttachmentIdLocationGetResponseModel(
    BaseModel
):
    error: Error8Model21


class Field1AppsOwnerNameAppNameErrorsErrorIdAttachmentsAttachmentIdTextGetResponse(
    BaseModel
):
    content: Optional[str] = None


class Field1AppsOwnerNameAppNameErrorsErrorIdAttachmentsAttachmentIdTextGetResponseModel(
    BaseModel
):
    error: Error8Model21


class Type84Model10(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class Log6Model2(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    event_id: Optional[str] = Field(None, description='Event ID.\n')
    event_name: Optional[str] = Field(None, description='Event name.\n')
    install_id: UUID = Field(..., description='Install ID.\n')
    message_id: Optional[str] = Field(None, description='Message ID.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='event specific properties.\n'
    )
    session_id: Optional[UUID] = Field(None, description='Session ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type84Model10 = Field(..., description='Log type.\n')


class Field1AppsOwnerNameAppNameErrorsErrorIdSessionLogsGetResponse(BaseModel):
    exceeded_max_limit: Optional[bool] = Field(
        None,
        description='indicates if the number of available logs are more than the max allowed return limit(100).',
    )
    last_received_log_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='the timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.',
    )
    logs: List[Log6Model2] = Field(..., description='the list of logs', min_length=0)


class Field1AppsOwnerNameAppNameErrorsErrorIdSessionLogsGetResponseModel(BaseModel):
    error: Error8Model21


class ExportEntity(Enum):
    crashes = 'crashes'
    errors = 'errors'
    attachments = 'attachments'
    no_logs = 'no_logs'


class Type84Model11(Enum):
    blob_storage_connection_string = 'blob_storage_connection_string'
    application_insights_instrumentation_key = (
        'application_insights_instrumentation_key'
    )
    blob_storage_linked_subscription = 'blob_storage_linked_subscription'
    application_insights_linked_subscription = (
        'application_insights_linked_subscription'
    )


class ExportConfiguration(BaseModel):
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type84Model11 = Field(..., description='Type of export configuration')


class ExportType(Enum):
    BlobStorage = 'BlobStorage'
    AppInsights = 'AppInsights'


class State15Model2(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'
    Pending = 'Pending'
    Deleted = 'Deleted'
    Invalid = 'Invalid'


class Value8Model1(BaseModel):
    creation_time: str = Field(..., description='Creation time in ISO 8601 format')
    export_configuration: Optional[ExportConfiguration] = Field(
        None, description='Export configuration', discriminator='type'
    )
    export_entities: Optional[List[ExportEntity]] = None
    export_type: ExportType = Field(
        ..., description='Target resource type of export configuration'
    )
    id: str = Field(..., description='Export configuration id')
    last_run_time: Optional[str] = Field(
        None,
        description='Latest time in ISO 8601 format when export completed successfully',
    )
    resource_group: Optional[str] = Field(
        None, description='resource group for the storage account/App Insights resource'
    )
    resource_name: Optional[str] = Field(
        None, description='Storage accout or Appinsights resource name'
    )
    state: State15Model2 = Field(..., description='State of the export job')
    state_info: Optional[str] = Field(
        None, description='Additional information about export configuration state'
    )


class Field1AppsOwnerNameAppNameExportConfigurationsGetResponse(BaseModel):
    nextLink: Optional[str] = None
    total: Optional[int] = Field(None, description='the total count of exports')
    values: List[Value8Model1]


class Field1AppsOwnerNameAppNameExportConfigurationsGetResponseModel(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameExportConfigurationsPostRequest(BaseModel):
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type84Model11 = Field(..., description='Type of export configuration')


class Field1AppsOwnerNameAppNameExportConfigurationsPostResponse(BaseModel):
    creation_time: str = Field(..., description='Creation time in ISO 8601 format')
    export_configuration: Optional[ExportConfiguration] = Field(
        None, description='Export configuration', discriminator='type'
    )
    export_entities: Optional[List[ExportEntity]] = None
    export_type: ExportType = Field(
        ..., description='Target resource type of export configuration'
    )
    id: str = Field(..., description='Export configuration id')
    last_run_time: Optional[str] = Field(
        None,
        description='Latest time in ISO 8601 format when export completed successfully',
    )
    resource_group: Optional[str] = Field(
        None, description='resource group for the storage account/App Insights resource'
    )
    resource_name: Optional[str] = Field(
        None, description='Storage accout or Appinsights resource name'
    )
    state: State15Model2 = Field(..., description='State of the export job')
    state_info: Optional[str] = Field(
        None, description='Additional information about export configuration state'
    )


class Field1AppsOwnerNameAppNameExportConfigurationsPostResponseModel(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameExportConfigurationsExportConfigurationIdDeleteResponse(
    BaseModel
):
    error: Error8Model21


class Field1AppsOwnerNameAppNameExportConfigurationsExportConfigurationIdGetResponse(
    BaseModel
):
    creation_time: str = Field(..., description='Creation time in ISO 8601 format')
    export_configuration: Optional[ExportConfiguration] = Field(
        None, description='Export configuration', discriminator='type'
    )
    export_entities: Optional[List[ExportEntity]] = None
    export_type: ExportType = Field(
        ..., description='Target resource type of export configuration'
    )
    id: str = Field(..., description='Export configuration id')
    last_run_time: Optional[str] = Field(
        None,
        description='Latest time in ISO 8601 format when export completed successfully',
    )
    resource_group: Optional[str] = Field(
        None, description='resource group for the storage account/App Insights resource'
    )
    resource_name: Optional[str] = Field(
        None, description='Storage accout or Appinsights resource name'
    )
    state: State15Model2 = Field(..., description='State of the export job')
    state_info: Optional[str] = Field(
        None, description='Additional information about export configuration state'
    )


class Field1AppsOwnerNameAppNameExportConfigurationsExportConfigurationIdGetResponseModel(
    BaseModel
):
    error: Error8Model21


class Field1AppsOwnerNameAppNameExportConfigurationsExportConfigurationIdPatchRequest(
    BaseModel
):
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type84Model11 = Field(..., description='Type of export configuration')


class Field1AppsOwnerNameAppNameExportConfigurationsExportConfigurationIdPatchResponse(
    BaseModel
):
    creation_time: str = Field(..., description='Creation time in ISO 8601 format')
    export_configuration: Optional[ExportConfiguration] = Field(
        None, description='Export configuration', discriminator='type'
    )
    export_entities: Optional[List[ExportEntity]] = None
    export_type: ExportType = Field(
        ..., description='Target resource type of export configuration'
    )
    id: str = Field(..., description='Export configuration id')
    last_run_time: Optional[str] = Field(
        None,
        description='Latest time in ISO 8601 format when export completed successfully',
    )
    resource_group: Optional[str] = Field(
        None, description='resource group for the storage account/App Insights resource'
    )
    resource_name: Optional[str] = Field(
        None, description='Storage accout or Appinsights resource name'
    )
    state: State15Model2 = Field(..., description='State of the export job')
    state_info: Optional[str] = Field(
        None, description='Additional information about export configuration state'
    )


class Field1AppsOwnerNameAppNameExportConfigurationsExportConfigurationIdPatchResponseModel(
    BaseModel
):
    error: Error8Model21


class Field1AppsOwnerNameAppNameExportConfigurationsExportConfigurationIdDisablePostResponse(
    BaseModel
):
    error: Error8Model21


class Field1AppsOwnerNameAppNameExportConfigurationsExportConfigurationIdEnablePostResponse(
    BaseModel
):
    error: Error8Model21


class Field1AppsOwnerNameAppNameFileAssetPostRequest(BaseModel):
    pass


class Field1AppsOwnerNameAppNameFileAssetPostResponse(BaseModel):
    id: Optional[str] = None
    location: Optional[str] = None
    token: Optional[str] = None
    uploadDomain: Optional[str] = None
    uploadWindowLocation: Optional[str] = None
    urlEncodedToken: Optional[str] = None


class Field1AppsOwnerNameAppNameFileAssetPostResponseModel(BaseModel):
    code: str
    id: str
    message: str


class Type84Model12(Enum):
    org = 'org'
    user = 'user'


class Origin48Model3(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class App(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model3 = Field(..., description='The creation origin of this app')
    platform: Platform13Model1 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class DistributionGroup4Model(BaseModel):
    owner: Optional[Owner] = Field(
        None, description="The information about the app's owner"
    )


class InviteType(Enum):
    developer = 'developer'
    tester = 'tester'


class Permission(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'
    tester = 'tester'


class InvitedBy(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin48Model3 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission]] = Field(
        None, description='The permissions the user has for the app'
    )


class Field1AppsOwnerNameAppNameInvitationsGetResponse(BaseModel):
    app: App
    app_count: Optional[float] = Field(
        None, description='The number of apps in the group'
    )
    distribution_group: Optional[DistributionGroup4Model] = Field(
        None,
        description='The organization that owns the distribution group, if it exists',
    )
    email: str = Field(..., description='The email address of the invited user')
    id: UUID = Field(..., description='The unique ID (UUID) of the invitation')
    invite_type: InviteType = Field(..., description='The invitation type')
    invited_by: InvitedBy
    is_existing_user: bool = Field(
        ..., description='Indicates whether the invited user already exists'
    )
    permissions: Optional[List[Permission]] = Field(
        None, description='The permissions the user has for the app'
    )


class Field1AppsOwnerNameAppNameInvitationsGetResponseModel(BaseModel):
    error: Error8Model21


class Role(Enum):
    admin = 'admin'
    collaborator = 'collaborator'
    member = 'member'


class Field1AppsOwnerNameAppNameInvitationsPostRequest(BaseModel):
    role: Optional[Role] = Field(None, description="The user's role")
    user_email: str = Field(..., description="The user's email address")


class Field1AppsOwnerNameAppNameInvitationsPostResponse(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameInvitationsUserEmailDeleteResponse(BaseModel):
    error: Error8Model21


class Permission15Model(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'


class Field1AppsOwnerNameAppNameInvitationsUserEmailPatchRequest(BaseModel):
    permissions: List[Permission15Model] = Field(
        ..., description='The permissions the user has for the app in the invitation'
    )


class Field1AppsOwnerNameAppNameInvitationsUserEmailPatchResponse(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameInvitationsUserEmailPostRequest(BaseModel):
    role: Optional[Role] = Field(None, description='The role of the user to be added')


class Field1AppsOwnerNameAppNameInvitationsUserEmailPostResponse(BaseModel):
    error: Error8Model21


class DefaultValue(Enum):
    Disabled = 'Disabled'
    Individual = 'Individual'
    Daily = 'Daily'
    DailyAndIndividual = 'DailyAndIndividual'


class EventType7Model(Enum):
    crash_newCrashGroupCreated = 'crash_newCrashGroupCreated'


class Value8Model2(Enum):
    Disabled = 'Disabled'
    Individual = 'Individual'
    Daily = 'Daily'
    DailyAndIndividual = 'DailyAndIndividual'
    Default = 'Default'


class Setting(BaseModel):
    default_value: Optional[DefaultValue] = Field(
        None, description='Default frequency of event'
    )
    event_type: EventType7Model = Field(..., description='Event Name')
    value: Value8Model2 = Field(..., description='Frequency of event')


class Field1AppsOwnerNameAppNameNotificationsEmailSettingsGetResponse(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    eTag: Optional[str] = Field(None, description='The ETag of the entity')
    enabled: bool = Field(
        ..., description='Allows to forcefully disable emails on app or user level'
    )
    settings: List[Setting] = Field(
        ..., description='The settings the user has for the app'
    )
    userId: Optional[str] = Field(None, description='The unique id (UUID) of the user')
    appId: Optional[str] = Field(None, description='Application ID')
    user_enabled: bool = Field(
        ...,
        description='A flag indicating if settings are enabled at user/global level',
    )


class Code8Model15(Enum):
    integer_400 = 400
    integer_404 = 404
    integer_409 = 409
    integer_500 = 500


class Field1AppsOwnerNameAppNameNotificationsEmailSettingsGetResponseModel(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    code: Code8Model15 = Field(
        ...,
        description='The status code return by the API. It can be 400 or 404 or 409 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed'
    )


class Image3Model(BaseModel):
    thumb: Optional[str] = None


class Model7Model3(BaseModel):
    formFactor: Optional[str] = None
    manufacturer: Optional[str] = None
    name: Optional[str] = None
    releaseDate: Optional[str] = None


class DeviceConfiguration(BaseModel):
    id: Optional[UUID] = Field(
        None, description='The unique id of the device configuration'
    )
    image: Optional[Image3Model] = None
    model: Optional[Model7Model3] = None
    os: Optional[str] = None
    osName: Optional[str] = None


class Owner16Model(BaseModel):
    displayName: Optional[str] = Field(None, description='Display name of the account')
    id: str = Field(..., description='Account ID')
    name: str = Field(..., description='Name of the account')
    type: str = Field(..., description='Type of account')


class Field1AppsOwnerNameAppNameOwnerDeviceSetsGetResponseItem(BaseModel):
    deviceConfigurations: List[DeviceConfiguration]
    id: str = Field(..., description='Identifier of the device set')
    manufacturerCount: Optional[float] = Field(
        None,
        description="The number of manufacturers in the device set's device selection",
    )
    name: str = Field(..., description='Name of the device set')
    osVersionCount: Optional[float] = Field(
        None,
        description="The number of os versions in the device set's device selection",
    )
    owner: Owner16Model = Field(
        ..., description='The owner of a device set', title='Device Set Owner'
    )
    slug: Optional[str] = Field(None, description='Slug of the device set')


class Field1AppsOwnerNameAppNameOwnerDeviceSetsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameOwnerDeviceSetsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameOwnerDeviceSetsGetResponseItem]


class Field1AppsOwnerNameAppNameOwnerDeviceSetsPostRequest(BaseModel):
    devices: List[str] = Field(..., description='List of device IDs')
    name: str = Field(..., description='The name of the device set')


class Field1AppsOwnerNameAppNameOwnerDeviceSetsPostResponse(BaseModel):
    deviceConfigurations: List[DeviceConfiguration]
    id: str = Field(..., description='Identifier of the device set')
    manufacturerCount: Optional[float] = Field(
        None,
        description="The number of manufacturers in the device set's device selection",
    )
    name: str = Field(..., description='Name of the device set')
    osVersionCount: Optional[float] = Field(
        None,
        description="The number of os versions in the device set's device selection",
    )
    owner: Owner16Model = Field(
        ..., description='The owner of a device set', title='Device Set Owner'
    )
    slug: Optional[str] = Field(None, description='Slug of the device set')


class Field1AppsOwnerNameAppNameOwnerDeviceSetsPostResponseModel(BaseModel):
    message: str = Field(
        ..., description='Human-readable message that describes the error'
    )
    status: str = Field(..., description='Status of the operation')


class Field1AppsOwnerNameAppNameOwnerDeviceSetsIdGetResponse(BaseModel):
    deviceConfigurations: List[DeviceConfiguration]
    id: str = Field(..., description='Identifier of the device set')
    manufacturerCount: Optional[float] = Field(
        None,
        description="The number of manufacturers in the device set's device selection",
    )
    name: str = Field(..., description='Name of the device set')
    osVersionCount: Optional[float] = Field(
        None,
        description="The number of os versions in the device set's device selection",
    )
    owner: Owner16Model = Field(
        ..., description='The owner of a device set', title='Device Set Owner'
    )
    slug: Optional[str] = Field(None, description='Slug of the device set')


class Field1AppsOwnerNameAppNameOwnerDeviceSetsIdPutRequest(BaseModel):
    devices: List[str] = Field(..., description='List of device IDs')
    name: str = Field(..., description='The name of the device set')


class Field1AppsOwnerNameAppNameOwnerDeviceSetsIdPutResponse(BaseModel):
    deviceConfigurations: List[DeviceConfiguration]
    id: str = Field(..., description='Identifier of the device set')
    manufacturerCount: Optional[float] = Field(
        None,
        description="The number of manufacturers in the device set's device selection",
    )
    name: str = Field(..., description='Name of the device set')
    osVersionCount: Optional[float] = Field(
        None,
        description="The number of os versions in the device set's device selection",
    )
    owner: Owner16Model = Field(
        ..., description='The owner of a device set', title='Device Set Owner'
    )
    slug: Optional[str] = Field(None, description='Slug of the device set')


class Field1AppsOwnerNameAppNameOwnerDeviceSetsIdPutResponseModel(BaseModel):
    message: str = Field(
        ..., description='Human-readable message that describes the error'
    )
    status: str = Field(..., description='Status of the operation')


class Type84Model13(Enum):
    intune = 'intune'
    googleplay = 'googleplay'
    apple = 'apple'
    none = 'none'


class DistributionGroup4Model1(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution group.',
    )


class DistributionStore5Model3(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution store.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type84Model13] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution store.',
    )


class Origin48Model4(Enum):
    hockeyapp = 'hockeyapp'
    appcenter = 'appcenter'


class Field1AppsOwnerNameAppNameRecentReleasesGetResponseItem(BaseModel):
    build: Optional[Build] = Field(
        None, description='Build information for the release\n'
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>\n',
    )
    destinations: Optional[List[Destination8Model]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    distribution_groups: Optional[List[DistributionGroup4Model1]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore5Model3]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    file_extension: Optional[str] = Field(
        None, description='The file extension of the main (user-uploaded) package file.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    origin: Optional[Origin48Model4] = Field(None, description="The release's origin")
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1AppsOwnerNameAppNameRecentReleasesGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameRecentReleasesGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameRecentReleasesGetResponseItem]


class Field1AppsOwnerNameAppNameReleasesGetResponseItem(BaseModel):
    build: Optional[Build] = Field(
        None, description='Build information for the release\n'
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>\n',
    )
    destinations: Optional[List[Destination8Model]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    distribution_groups: Optional[List[DistributionGroup4Model1]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore5Model3]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    file_extension: Optional[str] = Field(
        None, description='The file extension of the main (user-uploaded) package file.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    origin: Optional[Origin48Model4] = Field(None, description="The release's origin")
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1AppsOwnerNameAppNameReleasesGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameReleasesGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameReleasesGetResponseItem]


class Field1AppsOwnerNameAppNameReleasesFilterByTesterGetResponseItem(BaseModel):
    build: Optional[Build] = Field(
        None, description='Build information for the release\n'
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>\n',
    )
    destinations: Optional[List[Destination8Model]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    distribution_groups: Optional[List[DistributionGroup4Model1]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore5Model3]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    file_extension: Optional[str] = Field(
        None, description='The file extension of the main (user-uploaded) package file.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    origin: Optional[Origin48Model4] = Field(None, description="The release's origin")
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1AppsOwnerNameAppNameReleasesFilterByTesterGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameReleasesFilterByTesterGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameReleasesFilterByTesterGetResponseItem]


class Code8Model16(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Field1AppsOwnerNameAppNameReleasesReleaseIdDeleteResponse(BaseModel):
    code: Code8Model16
    message: str


class DistributionGroup4Model2(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )


class DistributionStore5Model4(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution store.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type84Model13] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )


class Field1AppsOwnerNameAppNameReleasesReleaseIdGetResponse(BaseModel):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: str = Field(..., description="The app's display name.")
    app_icon_url: str = Field(..., description="A URL to the app's icon.")
    app_name: str = Field(
        ..., description="The app's name (extracted from the uploaded release)."
    )
    app_os: Optional[str] = Field(None, description="The app's OS.")
    build: Optional[Build] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    can_resign: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value determines if a release can be re-signed. When true, after a re-sign, the tester will be able to install the release from his registered devices. Will not be returned for non-iOS platforms.',
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned.<br>\n<b>tester</b>: The release distributed testers details will be returned.<br>\n',
    )
    destinations: Optional[List[Destination8Model]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    device_family: Optional[str] = Field(
        None, description="The release's device family."
    )
    distribution_groups: Optional[List[DistributionGroup4Model2]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore5Model4]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    install_url: Optional[str] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    is_provisioning_profile_syncing: Optional[bool] = Field(
        None,
        description="A flag that determines whether the release's provisioning profile is still extracted or not.",
    )
    is_udid_provisioned: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value will hold the provisioning status of that UDID in this release. Will be ignored for non-iOS platforms.',
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    origin: Optional[Origin48Model4] = Field(None, description="The release's origin")
    package_hashes: Optional[List[str]] = Field(
        None, description='Hashes for the packages.'
    )
    provisioning_profile_expiry_date: Optional[str] = Field(
        None, description='expiration date of provisioning profile in UTC format.'
    )
    provisioning_profile_name: Optional[str] = Field(
        None, description="The release's provisioning profile name."
    )
    provisioning_profile_type: Optional[ProvisioningProfileType] = Field(
        None,
        description='The type of the provisioning profile for the requested app version.',
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    secondary_download_url: Optional[str] = Field(
        None,
        description='The URL that hosts the secondary binary for this release, such as the apk file for aab releases.',
    )
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[int] = Field(None, description="The release's size in bytes.")
    status: Optional[str] = Field(None, description='Status of the release.')
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1AppsOwnerNameAppNameReleasesReleaseIdGetResponseModel(BaseModel):
    code: Code8Model16
    message: str


class Destination8Model1(BaseModel):
    id: Optional[str] = Field(
        None,
        description="Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.",
    )
    name: Optional[str] = Field(
        None,
        description="Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.",
    )


class Metadata(BaseModel):
    dsa_signature: Optional[str] = Field(
        None, description='dsa signature of the release for the sparkle feed.'
    )
    ed_signature: Optional[str] = Field(
        None, description='edDSA signature of the release for the sparkle feed.'
    )


class Field1AppsOwnerNameAppNameReleasesReleaseIdPatchRequest(BaseModel):
    build: Optional[Build] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    destination_id: Optional[str] = Field(
        None,
        description="OBSOLETE. Will be removed in future releases - use destinations instead. Id of a destination. The release will be associated with this destination. If the destination doesn't exist a 400 is returned. If both destination name and id are passed, the id is taking precedence.",
    )
    destination_name: Optional[str] = Field(
        None,
        description="OBSOLETE. Will be removed in future releases - use destinations instead. Name of a destination. The release will be associated with this destination. If the destination doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.",
    )
    destination_type: Optional[str] = Field(None, description='Not used anymore.')
    destinations: Optional[List[Destination8Model1]] = Field(
        None,
        description='Distribute this release under the following list of destinations (store groups or distribution groups).',
    )
    distribution_group_id: Optional[str] = Field(
        None,
        description="OBSOLETE. Will be removed in future releases - use destinations instead. Id of a distribution group. The release will be associated with this distribution group. If the distribution group doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.",
    )
    distribution_group_name: Optional[str] = Field(
        None,
        description="OBSOLETE. Will be removed in future releases - use destinations instead. Name of a distribution group. The release will be associated with this distribution group. If the distribution group doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.",
    )
    mandatory_update: Optional[bool] = Field(
        None,
        description='A boolean which determines whether this version should be a mandatory update or not.',
    )
    metadata: Optional[Metadata] = Field(
        None, description='An object containing all the release metadata.'
    )
    notify_testers: Optional[bool] = Field(
        True,
        description='A boolean which determines whether to notify testers of a new release, default to true.',
    )
    release_notes: Optional[str] = Field(
        None, description='Release notes for this release.'
    )


class Field1AppsOwnerNameAppNameReleasesReleaseIdPatchResponse(BaseModel):
    release_notes: Optional[str] = None


class Destination8Model2(BaseModel):
    code: Optional[str] = Field(
        None,
        description='Error Codes:<br>\n<b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not valid.<br>\n<b>store_release_bad_request</b>: Proper package release details for the store is not provided.<br>\n<b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid developer credentials.<br>\n<b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the release version and already existing version in the store.<br>\n<b>store_release_promotion</b>: Release already distributed, promoting a release is not supported.<br>\n<b>store_track_deactivated</b>: One or more tracks would be deactivated with this release. This is not supported yet.<br>\n<b>store_release_not_found</b>: App with the given package name is not found in the store.<br>\n<b>store_release_not_available</b>: The release is not available.<br>\n<b>internal_server_error</b>: Failed to distribute to a destination due to an internal server error.\n',
    )
    id: Optional[str] = None
    message: Optional[str] = None
    name: Optional[str] = None


class Field1AppsOwnerNameAppNameReleasesReleaseIdPatchResponseModel(BaseModel):
    code: Code8Model16
    message: str
    destinations: Optional[List[Destination8Model2]] = None
    mandatory_update: Optional[bool] = None
    release_notes: Optional[str] = None


class Field1AppsOwnerNameAppNameReleasesReleaseIdPatchResponseModel1(BaseModel):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdPutRequest(BaseModel):
    build: Optional[Build] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    enabled: Optional[bool] = Field(
        None, description='Toggle this release to be enable distribute/download or not.'
    )
    release_notes: Optional[str] = Field(
        None, description='Release notes for this release.'
    )


class Destination8Model3(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None


class Field1AppsOwnerNameAppNameReleasesReleaseIdPutResponse(BaseModel):
    destinations: Optional[List[Destination8Model3]] = None
    enabled: Optional[bool] = None
    mandatory_update: Optional[bool] = None
    provisioning_status_url: Optional[str] = None
    release_notes: Optional[str] = None


class Destination8Model4(BaseModel):
    code: Optional[str] = Field(
        None,
        description='Error Codes:<br>\n<b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not valid.<br>\n<b>store_release_bad_request</b>: Proper package release details for the store is not provided.<br>\n<b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid developer credentials.<br>\n<b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the release version and already existing version in the store.<br>\n<b>store_release_promotion</b>: Release already distributed, promoting a release is not supported.<br>\n<b>store_track_deactivated</b>: One or more tracks would be deactivated with this release. This is not supported yet.<br>\n<b>store_release_not_found</b>: App with the given package name is not found in the store.<br>\n<b>store_release_not_available</b>: The release is not available.<br>\n<b>internal_server_error</b>: Failed to distribute to a destination due to an internal server error.\n',
    )
    id: Optional[str] = None
    message: Optional[str] = None
    name: Optional[str] = None


class Field1AppsOwnerNameAppNameReleasesReleaseIdPutResponseModel(BaseModel):
    code: Code8Model16
    message: str
    destinations: Optional[List[Destination8Model4]] = None
    mandatory_update: Optional[bool] = None
    release_notes: Optional[str] = None


class Field1AppsOwnerNameAppNameReleasesReleaseIdPutResponseModel1(BaseModel):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdGroupsPostRequest(BaseModel):
    id: UUID = Field(..., description='Unique id of the release destination')
    mandatory_update: Optional[bool] = Field(
        None,
        description='Flag to mark the release for the provided destinations as mandatory',
    )
    notify_testers: Optional[bool] = Field(
        True, description='Flag to enable or disable notifications to testers'
    )


class Field1AppsOwnerNameAppNameReleasesReleaseIdGroupsPostResponse(BaseModel):
    id: str = Field(..., description='Unique id for the release destination')
    mandatory_update: bool = Field(
        ...,
        description='Flag to mark the release for the provided destinations as mandatory',
    )
    provisioning_status_url: Optional[str] = Field(
        None, description='The url to check provisioning status.'
    )


class Field1AppsOwnerNameAppNameReleasesReleaseIdGroupsPostResponseModel(BaseModel):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdGroupsGroupIdDeleteResponse(BaseModel):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdGroupsGroupIdPutRequest(BaseModel):
    mandatory_update: bool = Field(
        ..., description='Whether a release is mandatory for the given destination'
    )


class Field1AppsOwnerNameAppNameReleasesReleaseIdGroupsGroupIdPutResponse(BaseModel):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdProvisioningProfileGetResponse(
    BaseModel
):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdStoresPostRequest(BaseModel):
    id: UUID = Field(..., description='Unique id of the release destination')


class Field1AppsOwnerNameAppNameReleasesReleaseIdStoresPostResponse(BaseModel):
    id: str = Field(..., description='Unique id for the release destination')


class Field1AppsOwnerNameAppNameReleasesReleaseIdStoresPostResponseModel(BaseModel):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdStoresStoreIdDeleteResponse(BaseModel):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdTestersPostRequest(BaseModel):
    email: str = Field(..., description="Tester's email address")
    mandatory_update: Optional[bool] = Field(
        None,
        description='Flag to mark the release for the provided destinations as mandatory',
    )
    notify_testers: Optional[bool] = Field(
        True, description='Flag to enable or disable notifications to testers'
    )


class Field1AppsOwnerNameAppNameReleasesReleaseIdTestersPostResponse(BaseModel):
    id: str = Field(..., description='Unique id for the release destination')
    mandatory_update: bool = Field(
        ...,
        description='Flag to mark the release for the provided destinations as mandatory',
    )
    provisioning_status_url: Optional[str] = Field(
        None, description='The url to check provisioning status.'
    )


class Field1AppsOwnerNameAppNameReleasesReleaseIdTestersPostResponseModel(BaseModel):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdTestersTesterIdDeleteResponse(
    BaseModel
):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdTestersTesterIdPutRequest(BaseModel):
    mandatory_update: bool = Field(
        ..., description='Whether a release is mandatory for the given destination'
    )


class Field1AppsOwnerNameAppNameReleasesReleaseIdTestersTesterIdPutResponse(BaseModel):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameReleasesReleaseIdUpdateDevicesResignIdGetResponse(
    BaseModel
):
    error_code: Optional[str] = Field(
        None,
        description='Error code for any error that occured during the resigning operation.',
    )
    error_message: Optional[str] = Field(
        None,
        description='Error message for any error that occured during the resigning operation.',
    )
    status: str = Field(..., description='The status of the resign')


class Field1AppsOwnerNameAppNameReleasesReleaseIdUpdateDevicesResignIdGetResponseModel(
    BaseModel
):
    code: Code8Model16
    message: str


class Field1AppsOwnerNameAppNameRepoConfigDeleteResponse(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameRepoConfigDeleteResponseModel(BaseModel):
    code: str
    id: str
    message: str


class State15Model3(Enum):
    unauthorized = 'unauthorized'
    inactive = 'inactive'
    active = 'active'


class Field1AppsOwnerNameAppNameRepoConfigGetResponseItem(BaseModel):
    installation_id: Optional[str] = Field(
        None,
        description='The GitHub App Installation id. Required for repositories connected from GitHub App',
    )
    external_user_id: Optional[str] = Field(
        None,
        description='The external user id from the repository provider. Required for GitLab.com repositories',
    )
    repo_id: Optional[str] = Field(
        None,
        description='The repository id from the repository provider. Required for repositories connected from GitHub App and GitLab.com',
    )
    repo_url: str = Field(
        ...,
        description="The repository's git url, must be a HTTPS URL",
        examples=['https://github.com/foo/bar.git'],
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='The id of the service connection (private). Required for GitLab self-hosted repositories',
    )
    id: str = Field(..., description='Repository configuration identifier')
    state: State15Model3 = Field(..., description='State of the configuration')
    type: str = Field(..., description='Type of repository')
    user_email: Optional[str] = Field(
        None, description='Email of the user who linked the repository'
    )


class Field1AppsOwnerNameAppNameRepoConfigGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameRepoConfigGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameRepoConfigGetResponseItem] = Field(
        ..., description='A list of repo configurations'
    )


class Field1AppsOwnerNameAppNameRepoConfigGetResponseModel(BaseModel):
    code: str
    id: str
    message: str


class Field1AppsOwnerNameAppNameRepoConfigPostRequest(BaseModel):
    external_user_id: Optional[str] = Field(
        None,
        description='The external user id from the repository provider. Required for GitLab.com repositories',
    )
    repo_id: Optional[str] = Field(
        None,
        description='The repository id from the repository provider. Required for repositories connected from GitHub App and GitLab.com',
    )
    repo_url: str = Field(
        ...,
        description="The repository's git url, must be a HTTPS URL",
        examples=['https://github.com/foo/bar.git'],
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='The id of the service connection (private). Required for GitLab self-hosted repositories',
    )
    installation_id: Optional[str] = Field(
        None,
        description='The GitHub App Installation id. Required for repositories connected from GitHub App',
    )


class Field1AppsOwnerNameAppNameRepoConfigPostResponse(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameRepoConfigPostResponseModel(BaseModel):
    code: str
    id: str
    message: str


class Field1AppsOwnerNameAppNameSourceHostsSourceHostRepositoriesGetResponseItem(
    BaseModel
):
    clone_url: Optional[str] = Field(
        None, description='URL used to clone the repository'
    )
    name: Optional[str] = Field(None, description='The repository name')


class Field1AppsOwnerNameAppNameSourceHostsSourceHostRepositoriesGetResponse(
    RootModel[
        List[Field1AppsOwnerNameAppNameSourceHostsSourceHostRepositoriesGetResponseItem]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameSourceHostsSourceHostRepositoriesGetResponseItem
    ] = Field(..., description='A list of source repositories')


class Field1AppsOwnerNameAppNameSourceHostsSourceHostRepositoriesGetResponseModel(
    BaseModel
):
    code: str
    id: str
    message: str


class Field1AppsOwnerNameAppNameStoreServiceStatusGetResponse(BaseModel):
    service: Optional[str] = None
    status: Optional[str] = None
    valid_until: Optional[int] = None


class Field1AppsOwnerNameAppNameStoreServiceStatusGetResponseModel(BaseModel):
    code: Code8Model16
    message: str


class Tier(BaseModel):
    name: Optional[str] = Field(None, description='The name of the tier')


class Field1AppsOwnerNameAppNameSubscriptionsGetResponse(BaseModel):
    active: Optional[bool] = Field(
        None, description='Is the subscription currently active?'
    )
    concurrentDevicesLimit: Optional[int] = Field(
        None, description='Customer limits on concurrent devices'
    )
    daysLeft: Optional[float] = Field(
        None, description='The number of days left in the subscription'
    )
    endsAt: Optional[str] = Field(
        None, description='The date the subscription will end or ended'
    )
    id: Optional[UUID] = Field(None, description='Id of the subscription')
    runningDevices: Optional[int] = Field(
        None, description='Current device concurrency utilization'
    )
    startsAt: Optional[str] = Field(None, description='The date the subscription began')
    tier: Optional[Tier] = Field(None, title='Subscription Tier')


class Field1AppsOwnerNameAppNameSubscriptionsPostResponse(BaseModel):
    active: Optional[bool] = Field(
        None, description='Is the subscription currently active?'
    )
    concurrentDevicesLimit: Optional[int] = Field(
        None, description='Customer limits on concurrent devices'
    )
    daysLeft: Optional[float] = Field(
        None, description='The number of days left in the subscription'
    )
    endsAt: Optional[str] = Field(
        None, description='The date the subscription will end or ended'
    )
    id: Optional[UUID] = Field(None, description='Id of the subscription')
    runningDevices: Optional[int] = Field(
        None, description='Current device concurrency utilization'
    )
    startsAt: Optional[str] = Field(None, description='The date the subscription began')
    tier: Optional[Tier] = Field(None, title='Subscription Tier')


class Origin48Model5(Enum):
    User = 'User'
    System = 'System'


class Status32(Enum):
    created = 'created'
    committed = 'committed'
    aborted = 'aborted'
    processing = 'processing'
    indexed = 'indexed'
    failed = 'failed'


class SymbolType(Enum):
    Apple = 'Apple'
    JavaScript = 'JavaScript'
    Breakpad = 'Breakpad'
    AndroidProguard = 'AndroidProguard'
    UWP = 'UWP'


class SymbolsUploadedItem(BaseModel):
    platform: str = Field(..., description='The platform the symbol is associated with')
    symbol_id: str = Field(..., description='The symbol id of the symbol binary')


class User(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: Optional[str] = Field(None, description='The email of the user')


class Field1AppsOwnerNameAppNameSymbolUploadsGetResponseItem(BaseModel):
    app_id: str = Field(
        ..., description='The application that this symbol upload belongs to'
    )
    file_name: Optional[str] = Field(
        None, description='The file name for the symbol upload'
    )
    file_size: Optional[float] = Field(
        None,
        description='The size of the file in Mebibytes. This may be 0 until the status is indexed',
    )
    origin: Optional[Origin48Model5] = Field(
        None, description='The origin of the symbol upload'
    )
    status: Status32 = Field(
        ..., description='The current status for the symbol upload'
    )
    symbol_type: SymbolType = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    symbol_upload_id: str = Field(
        ..., description='The id for the current symbol upload'
    )
    symbols_uploaded: Optional[List[SymbolsUploadedItem]] = Field(
        None,
        description='The symbols found in the upload. This may be empty until the status is indexed',
    )
    timestamp: Optional[datetime_aliased] = Field(
        None,
        description='When the symbol upload was committed, or last transaction time if not committed',
    )
    user: Optional[User] = Field(
        None, description='User information of the one who intitiated the symbol upload'
    )


class Field1AppsOwnerNameAppNameSymbolUploadsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameSymbolUploadsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameSymbolUploadsGetResponseItem] = Field(
        ..., description='A set of symbol upload entities'
    )


class Field1AppsOwnerNameAppNameSymbolUploadsGetResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameSymbolUploadsPostRequest(BaseModel):
    build: Optional[str] = Field(
        None, description='The build number. Optional for Apple. Required for Android.'
    )
    client_callback: Optional[str] = Field(
        None,
        description='The callback URL that the client can optionally provide to get status updates for the current symbol upload',
    )
    file_name: Optional[str] = Field(
        None, description='The file name for the symbol upload'
    )
    symbol_type: SymbolType = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    version: Optional[str] = Field(
        None,
        description='The version number. Optional for Apple. Required for Android.',
    )


class Field1AppsOwnerNameAppNameSymbolUploadsPostResponse(BaseModel):
    expiration_date: datetime_aliased = Field(
        ..., description='Describes how long the upload_url is valid'
    )
    symbol_upload_id: str = Field(..., description='The id for the current upload')
    upload_url: str = Field(
        ..., description='The URL where the client needs to upload the symbol blob to'
    )


class Field1AppsOwnerNameAppNameSymbolUploadsPostResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameSymbolUploadsSymbolUploadIdDeleteResponse(BaseModel):
    app_id: str = Field(
        ..., description='The application that this symbol upload belongs to'
    )
    file_name: Optional[str] = Field(
        None, description='The file name for the symbol upload'
    )
    file_size: Optional[float] = Field(
        None,
        description='The size of the file in Mebibytes. This may be 0 until the status is indexed',
    )
    origin: Optional[Origin48Model5] = Field(
        None, description='The origin of the symbol upload'
    )
    status: Status32 = Field(
        ..., description='The current status for the symbol upload'
    )
    symbol_type: SymbolType = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    symbol_upload_id: str = Field(
        ..., description='The id for the current symbol upload'
    )
    symbols_uploaded: Optional[List[SymbolsUploadedItem]] = Field(
        None,
        description='The symbols found in the upload. This may be empty until the status is indexed',
    )
    timestamp: Optional[datetime_aliased] = Field(
        None,
        description='When the symbol upload was committed, or last transaction time if not committed',
    )
    user: Optional[User] = Field(
        None, description='User information of the one who intitiated the symbol upload'
    )


class Field1AppsOwnerNameAppNameSymbolUploadsSymbolUploadIdDeleteResponseModel(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameSymbolUploadsSymbolUploadIdGetResponse(BaseModel):
    app_id: str = Field(
        ..., description='The application that this symbol upload belongs to'
    )
    file_name: Optional[str] = Field(
        None, description='The file name for the symbol upload'
    )
    file_size: Optional[float] = Field(
        None,
        description='The size of the file in Mebibytes. This may be 0 until the status is indexed',
    )
    origin: Optional[Origin48Model5] = Field(
        None, description='The origin of the symbol upload'
    )
    status: Status32 = Field(
        ..., description='The current status for the symbol upload'
    )
    symbol_type: SymbolType = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    symbol_upload_id: str = Field(
        ..., description='The id for the current symbol upload'
    )
    symbols_uploaded: Optional[List[SymbolsUploadedItem]] = Field(
        None,
        description='The symbols found in the upload. This may be empty until the status is indexed',
    )
    timestamp: Optional[datetime_aliased] = Field(
        None,
        description='When the symbol upload was committed, or last transaction time if not committed',
    )
    user: Optional[User] = Field(
        None, description='User information of the one who intitiated the symbol upload'
    )


class Field1AppsOwnerNameAppNameSymbolUploadsSymbolUploadIdGetResponseModel(BaseModel):
    message: str


class Status33(Enum):
    committed = 'committed'
    aborted = 'aborted'


class Field1AppsOwnerNameAppNameSymbolUploadsSymbolUploadIdPatchRequest(BaseModel):
    status: Status33 = Field(
        ..., description='The desired operation for the symbol upload'
    )


class Status33Model(Enum):
    created = 'created'
    committed = 'committed'
    aborted = 'aborted'
    processing = 'processing'
    indexed = 'indexed'
    failed = 'failed'


class Field1AppsOwnerNameAppNameSymbolUploadsSymbolUploadIdPatchResponse(BaseModel):
    app_id: str = Field(
        ..., description='The application that this symbol upload belongs to'
    )
    file_name: Optional[str] = Field(
        None, description='The file name for the symbol upload'
    )
    file_size: Optional[float] = Field(
        None,
        description='The size of the file in Mebibytes. This may be 0 until the status is indexed',
    )
    origin: Optional[Origin48Model5] = Field(
        None, description='The origin of the symbol upload'
    )
    status: Status33Model = Field(
        ..., description='The current status for the symbol upload'
    )
    symbol_type: SymbolType = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    symbol_upload_id: str = Field(
        ..., description='The id for the current symbol upload'
    )
    symbols_uploaded: Optional[List[SymbolsUploadedItem]] = Field(
        None,
        description='The symbols found in the upload. This may be empty until the status is indexed',
    )
    timestamp: Optional[datetime_aliased] = Field(
        None,
        description='When the symbol upload was committed, or last transaction time if not committed',
    )
    user: Optional[User] = Field(
        None, description='User information of the one who intitiated the symbol upload'
    )


class Field1AppsOwnerNameAppNameSymbolUploadsSymbolUploadIdPatchResponseModel(
    BaseModel
):
    message: str


class Field1AppsOwnerNameAppNameSymbolUploadsSymbolUploadIdLocationGetResponse(
    BaseModel
):
    uri: str


class Field1AppsOwnerNameAppNameSymbolUploadsSymbolUploadIdLocationGetResponseModel(
    BaseModel
):
    message: str


class Origin48Model6(Enum):
    System = 'System'
    User = 'User'


class Status33Model1(Enum):
    available = 'available'
    ignored = 'ignored'


class Type84Model14(Enum):
    Apple = 'Apple'
    JavaScript = 'JavaScript'
    Breakpad = 'Breakpad'
    AndroidProguard = 'AndroidProguard'
    UWP = 'UWP'


class Field1AppsOwnerNameAppNameSymbolsGetResponseItem(BaseModel):
    alternate_symbol_ids: List[str] = Field(
        ..., description='The other symbols in the same file'
    )
    app_id: str = Field(..., description='The application that this symbol belongs to')
    build: Optional[str] = Field(
        None, description='The build number. Optional for Apple. Required for Android.'
    )
    origin: Origin48Model6 = Field(..., description='The origin of the symbol file')
    platform: str = Field(
        ..., description='The platform that this symbol is associated with'
    )
    status: Status33Model1 = Field(..., description='Whether the symbol is ignored.')
    symbol_id: str = Field(..., description='The unique id for this symbol (uuid)')
    symbol_upload_id: str = Field(
        ..., description='The id of the symbol upload this symbol belongs to.'
    )
    type: Type84Model14 = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    url: str = Field(
        ..., description='The path name of the symbol file in blob storage'
    )
    version: Optional[str] = Field(
        None,
        description='The version number. Optional for Apple. Required for Android.',
    )


class Field1AppsOwnerNameAppNameSymbolsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameSymbolsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameSymbolsGetResponseItem] = Field(
        ...,
        description='A response containing the list of symbols matching the specified filter (if any was provided)',
    )


class Field1AppsOwnerNameAppNameSymbolsGetResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameSymbolsSymbolIdGetResponse(BaseModel):
    alternate_symbol_ids: List[str] = Field(
        ..., description='The other symbols in the same file'
    )
    app_id: str = Field(..., description='The application that this symbol belongs to')
    build: Optional[str] = Field(
        None, description='The build number. Optional for Apple. Required for Android.'
    )
    origin: Origin48Model6 = Field(..., description='The origin of the symbol file')
    platform: str = Field(
        ..., description='The platform that this symbol is associated with'
    )
    status: Status33Model1 = Field(..., description='Whether the symbol is ignored.')
    symbol_id: str = Field(..., description='The unique id for this symbol (uuid)')
    symbol_upload_id: str = Field(
        ..., description='The id of the symbol upload this symbol belongs to.'
    )
    type: Type84Model14 = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    url: str = Field(
        ..., description='The path name of the symbol file in blob storage'
    )
    version: Optional[str] = Field(
        None,
        description='The version number. Optional for Apple. Required for Android.',
    )


class Field1AppsOwnerNameAppNameSymbolsSymbolIdGetResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameSymbolsSymbolIdIgnorePostResponse(BaseModel):
    alternate_symbol_ids: List[str] = Field(
        ..., description='The other symbols in the same file'
    )
    app_id: str = Field(..., description='The application that this symbol belongs to')
    build: Optional[str] = Field(
        None, description='The build number. Optional for Apple. Required for Android.'
    )
    origin: Origin48Model6 = Field(..., description='The origin of the symbol file')
    platform: str = Field(
        ..., description='The platform that this symbol is associated with'
    )
    status: Status33Model1 = Field(..., description='Whether the symbol is ignored.')
    symbol_id: str = Field(..., description='The unique id for this symbol (uuid)')
    symbol_upload_id: str = Field(
        ..., description='The id of the symbol upload this symbol belongs to.'
    )
    type: Type84Model14 = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    url: str = Field(
        ..., description='The path name of the symbol file in blob storage'
    )
    version: Optional[str] = Field(
        None,
        description='The version number. Optional for Apple. Required for Android.',
    )


class Field1AppsOwnerNameAppNameSymbolsSymbolIdIgnorePostResponseModel(BaseModel):
    message: str


class Field1AppsOwnerNameAppNameSymbolsSymbolIdLocationGetResponse(BaseModel):
    uri: str


class Field1AppsOwnerNameAppNameSymbolsSymbolIdLocationGetResponseModel(BaseModel):
    message: str


class Status33Model2(Enum):
    available = 'available'
    ignored = 'ignored'
    missing = 'missing'


class Field1AppsOwnerNameAppNameSymbolsSymbolIdStatusGetResponse(BaseModel):
    app_id: str = Field(..., description='The application that this symbol belongs to')
    status: Status33Model2 = Field(..., description='Whether the symbol is ignored.')
    symbol_id: str = Field(..., description='The unique id for this symbol (uuid)')


class Field1AppsOwnerNameAppNameSymbolsSymbolIdStatusGetResponseModel(BaseModel):
    message: str


class Permission15Model1(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'
    tester = 'tester'


class Field1AppsOwnerNameAppNameTeamsGetResponseItem(BaseModel):
    description: Optional[str] = Field(None, description='The description of the team')
    display_name: str = Field(..., description='The display name of the team')
    id: UUID = Field(..., description='The internal unique id (UUID) of the team.')
    name: str = Field(..., description='The name of the team')
    permissions: Optional[List[Permission15Model1]] = Field(
        None, description='The permissions the team has for the app'
    )


class Field1AppsOwnerNameAppNameTeamsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameTeamsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameTeamsGetResponseItem]


class Field1AppsOwnerNameAppNameTeamsGetResponseModel(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameTestExportGetResponse(BaseModel):
    resources: Optional[List[Resource]] = None


class Field1AppsOwnerNameAppNameTestExportAppsGetResponse(BaseModel):
    hash_files_url: Optional[str] = None


class Field1AppsOwnerNameAppNameTestExportFileSetFilesGetResponse(BaseModel):
    app_upload_id: Optional[UUID] = None
    hash_file_id: Optional[UUID] = None
    hash_file_url: Optional[str] = None
    path: Optional[str] = None


class Field1AppsOwnerNameAppNameTestExportHashFilesGetResponse(BaseModel):
    filename: Optional[str] = None
    id: Optional[UUID] = None


class Field1AppsOwnerNameAppNameTestExportPipelineTestsGetResponse(BaseModel):
    app_upload_id: Optional[UUID] = None
    test_parameters: Optional[Dict[str, Any]] = None


class Field1AppsOwnerNameAppNameTestExportTestRunsGetResponse(BaseModel):
    app_hash_file_id: Optional[UUID] = None
    app_hash_file_url: Optional[str] = None
    app_icon_url: Optional[str] = None
    dsym_hash_file_id: Optional[UUID] = None
    dsym_hash_file_url: Optional[str] = None
    id: Optional[UUID] = None
    locale: Optional[str] = None


class Stats(BaseModel):
    devices: Optional[float] = Field(
        None, description='Number of devices running the test'
    )
    devicesFailed: Optional[float] = Field(None, description='Number of failed devices')
    devicesFinished: Optional[float] = Field(
        None, description='Number of finished devices'
    )
    failed: Optional[float] = Field(None, description='Number of failed tests')
    passed: Optional[float] = Field(None, description='Number of passed tests')
    peakMemory: Optional[float] = Field(
        None, description='The max amount of MB used during the test run'
    )
    skipped: Optional[float] = Field(None, description='Number of skipped tests')
    total: Optional[float] = Field(None, description='Number of tests in total')
    totalDeviceMinutes: Optional[float] = Field(
        None,
        description='The number of minutes of device time the test has been runnign',
    )


class Field1AppsOwnerNameAppNameTestRunsGetResponseItem(BaseModel):
    appVersion: Optional[str] = Field(
        None, description='The compiled version of the app binary'
    )
    date: Optional[str] = Field(
        None, description='The date and time the test was uploaded'
    )
    description: Optional[str] = Field(
        None, description='Human readable explanation of the current test status'
    )
    id: Optional[UUID] = Field(None, description='The unique id of the test upload')
    platform: Optional[str] = Field(
        None,
        description="The device platform targeted by the test. Possible values are 'ios' or 'android'",
    )
    resultStatus: Optional[str] = Field(None, description='The passed/failed state')
    runStatus: Optional[str] = Field(
        None,
        description='The current status of the test run, in relation to the various phases',
    )
    state: Optional[str] = Field(None, description='Deprecated. Use runStatus instead.')
    stats: Optional[Stats] = Field(
        None,
        description='Summary single test run on Xamarin Test Cloud',
        title='Test Run Statistics',
    )
    status: Optional[str] = Field(
        None, description='Deprecated. Use resultStatus instead.'
    )
    testSeries: Optional[str] = Field(
        None,
        description='The name of the test series with which this test upload is associated',
    )
    testType: Optional[str] = Field(
        None, description='The name of the test framework used to run this test'
    )


class Field1AppsOwnerNameAppNameTestRunsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameTestRunsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameTestRunsGetResponseItem]


class Field1AppsOwnerNameAppNameTestRunsTestRunIdDeleteResponse(BaseModel):
    appVersion: Optional[str] = Field(
        None, description='The compiled version of the app binary'
    )
    date: Optional[str] = Field(
        None, description='The date and time the test was uploaded'
    )
    description: Optional[str] = Field(
        None, description='Human readable explanation of the current test status'
    )
    id: Optional[UUID] = Field(None, description='The unique id of the test upload')
    platform: Optional[str] = Field(
        None,
        description="The device platform targeted by the test. Possible values are 'ios' or 'android'",
    )
    resultStatus: Optional[str] = Field(None, description='The passed/failed state')
    runStatus: Optional[str] = Field(
        None,
        description='The current status of the test run, in relation to the various phases',
    )
    state: Optional[str] = Field(None, description='Deprecated. Use runStatus instead.')
    stats: Optional[Stats] = Field(
        None,
        description='Summary single test run on Xamarin Test Cloud',
        title='Test Run Statistics',
    )
    status: Optional[str] = Field(
        None, description='Deprecated. Use resultStatus instead.'
    )
    testSeries: Optional[str] = Field(
        None,
        description='The name of the test series with which this test upload is associated',
    )
    testType: Optional[str] = Field(
        None, description='The name of the test framework used to run this test'
    )


class Field1AppsOwnerNameAppNameTestRunsTestRunIdGetResponse(BaseModel):
    appVersion: Optional[str] = Field(
        None, description='The compiled version of the app binary'
    )
    date: Optional[str] = Field(
        None, description='The date and time the test was uploaded'
    )
    description: Optional[str] = Field(
        None, description='Human readable explanation of the current test status'
    )
    id: Optional[UUID] = Field(None, description='The unique id of the test upload')
    platform: Optional[str] = Field(
        None,
        description="The device platform targeted by the test. Possible values are 'ios' or 'android'",
    )
    resultStatus: Optional[str] = Field(None, description='The passed/failed state')
    runStatus: Optional[str] = Field(
        None,
        description='The current status of the test run, in relation to the various phases',
    )
    state: Optional[str] = Field(None, description='Deprecated. Use runStatus instead.')
    stats: Optional[Stats] = Field(
        None,
        description='Summary single test run on Xamarin Test Cloud',
        title='Test Run Statistics',
    )
    status: Optional[str] = Field(
        None, description='Deprecated. Use resultStatus instead.'
    )
    testSeries: Optional[str] = Field(
        None,
        description='The name of the test series with which this test upload is associated',
    )
    testType: Optional[str] = Field(
        None, description='The name of the test framework used to run this test'
    )


class FileType(Enum):
    dsym_file = 'dsym-file'
    app_file = 'app-file'
    test_file = 'test-file'


class Field1AppsOwnerNameAppNameTestRunsTestRunIdHashesPostRequest(BaseModel):
    byte_range: Optional[str] = Field(
        None, description='Range of bytes required to verify ownership of the file'
    )
    checksum: str = Field(..., description='SHA256 hash of the file')
    file_type: FileType = Field(..., description='Type of the file')
    relative_path: str = Field(..., description='Relative path of the file')


class Field1AppsOwnerNameAppNameTestRunsTestRunIdHashesBatchPostRequestItem(BaseModel):
    checksum: str = Field(..., description='SHA256 hash of the file')
    fileType: FileType = Field(..., description='Type of the file')
    relativePath: str = Field(..., description='Relative path of the file')


class Field1AppsOwnerNameAppNameTestRunsTestRunIdHashesBatchPostRequest(
    RootModel[
        List[Field1AppsOwnerNameAppNameTestRunsTestRunIdHashesBatchPostRequestItem]
    ]
):
    root: List[Field1AppsOwnerNameAppNameTestRunsTestRunIdHashesBatchPostRequestItem]


class UploadStatus(BaseModel):
    location: Optional[str] = Field(
        None,
        description="URI that should be used to make POST request if file with given hash doesn't exist. This is set when status_code is equal to 412",
    )
    statusCode: float = Field(
        ..., description='HTTP status code that represent result of upload'
    )


class Field1AppsOwnerNameAppNameTestRunsTestRunIdHashesBatchPostResponseItem(BaseModel):
    checksum: str = Field(..., description='SHA256 hash of the file')
    fileType: FileType = Field(..., description='Type of the file')
    relativePath: Optional[str] = Field(None, description='Relative path of the file')
    uploadStatus: UploadStatus = Field(
        ..., description='Status of the upload', title='Test Cloud Hash Upload Status'
    )


class Field1AppsOwnerNameAppNameTestRunsTestRunIdHashesBatchPostResponse(
    RootModel[
        List[Field1AppsOwnerNameAppNameTestRunsTestRunIdHashesBatchPostResponseItem]
    ]
):
    root: List[Field1AppsOwnerNameAppNameTestRunsTestRunIdHashesBatchPostResponseItem]


class DeviceLog(BaseModel):
    appium_log: Optional[str] = None
    device_log: Optional[str] = None
    device_snapshot_id: Optional[str] = None
    test_log: Optional[str] = None


class StepExecution(BaseModel):
    device_snapshot_id: Optional[str] = None
    status: Optional[str] = None
    timestamp: Optional[float] = None


class Step(BaseModel):
    failed: Optional[float] = None
    id: Optional[str] = None
    skipped: Optional[float] = None
    stepExecutions: Optional[List[StepExecution]] = None
    stepName: Optional[str] = None
    step_report_url: Optional[str] = None


class Run(BaseModel):
    failed: Optional[float] = None
    id: Optional[str] = None
    number: Optional[float] = None
    report_url: Optional[str] = None
    skipped: Optional[float] = None
    steps: Optional[List[Step]] = None


class Test(BaseModel):
    peakDuration: Optional[float] = None
    peakMemory: Optional[float] = None
    runs: Optional[List[Run]] = None
    testName: Optional[str] = None


class Feature(BaseModel):
    failed: Optional[float] = None
    name: Optional[str] = None
    peakDuration: Optional[float] = None
    peakMemory: Optional[float] = None
    skipped: Optional[float] = None
    tests: Optional[List[Test]] = None


class SnapshotFatalError(BaseModel):
    device_snapshot_id: Optional[str] = None
    error_message: Optional[str] = None
    error_title: Optional[str] = None


class Stats2Model(BaseModel):
    artifacts: Optional[Dict[str, str]] = None
    devices: float
    devices_failed: float
    devices_finished: float
    devices_not_runned: float
    devices_skipped: float
    failed: float
    filesize: float
    os: float
    passed: float
    skipped: float
    step_count: float
    total: float
    totalDeviceMinutes: float


class Field1AppsOwnerNameAppNameTestRunsTestRunIdReportGetResponse(BaseModel):
    app_upload_id: str
    date: str
    date_finished: str
    device_logs: List[DeviceLog]
    errorMessage: Optional[str] = None
    features: List[Feature]
    finished_device_snapshots: List[str]
    id: str
    platform: str
    revision: float
    schema_version: float
    snapshot_fatal_errors: Optional[List[SnapshotFatalError]] = None
    stats: Stats2Model
    testType: str


class Field1AppsOwnerNameAppNameTestRunsTestRunIdStartPostRequest(BaseModel):
    device_selection: str = Field(..., description='Device selection string.')
    language: Optional[str] = Field(
        None, description='Language that should be used to run tests.'
    )
    locale: Optional[str] = Field(
        None, description='Locale that should be used to run tests.'
    )
    test_framework: str = Field(..., description='Test framework used by tests.')
    test_parameters: Optional[Dict[str, Any]] = Field(
        None, description='A JSON dictionary with additional test parameters'
    )
    test_series: Optional[str] = Field(None, description='Name of the test series.')


class Field1AppsOwnerNameAppNameTestRunsTestRunIdStartPostResponse(BaseModel):
    accepted_devices: Optional[List[str]] = Field(
        None, description='List with names of accepted devices'
    )
    rejected_devices: Optional[List[str]] = Field(
        None, description='List with names and descriptions of rejected devices'
    )


class Field1AppsOwnerNameAppNameTestRunsTestRunIdStateGetResponse(BaseModel):
    exit_code: Optional[int] = Field(
        None,
        description='The exit code that the client should use when exiting. Used for indicating status to the caller of the client.\n0: test run completes with no failing tests\n1: test run completes with at least one failing test\n2: test run failed to complete. Status for test run is unknown\n',
    )
    message: Optional[List[str]] = Field(
        None, description='Multi-line message that describes the status'
    )
    wait_time: Optional[int] = Field(
        None,
        description='Time (in seconds) that the client should wait for before checking the status again',
    )


class Stats2Model1(BaseModel):
    devices: Optional[float] = Field(
        None, description='Number of devices running the test'
    )
    devicesFailed: Optional[float] = Field(None, description='Number of failed devices')
    devicesFinished: Optional[float] = Field(
        None, description='Number of finished devices'
    )
    failed: Optional[float] = Field(None, description='Number of failed tests')
    passed: Optional[float] = Field(None, description='Number of passed tests')
    peakMemory: Optional[float] = Field(
        None, description='The max amount of MB used during the test run'
    )
    skipped: Optional[float] = Field(None, description='Number of skipped tests')
    total: Optional[float] = Field(None, description='Number of tests in total')
    totalDeviceMinutes: Optional[float] = Field(
        None,
        description='The number of minutes of device time the test has been runnign',
    )


class Field1AppsOwnerNameAppNameTestRunsTestRunIdStopPutResponse(BaseModel):
    appVersion: Optional[str] = Field(
        None, description='The compiled version of the app binary'
    )
    date: Optional[str] = Field(
        None, description='The date and time the test was uploaded'
    )
    description: Optional[str] = Field(
        None, description='Human readable explanation of the current test status'
    )
    id: Optional[UUID] = Field(None, description='The unique id of the test upload')
    platform: Optional[str] = Field(
        None,
        description="The device platform targeted by the test. Possible values are 'ios' or 'android'",
    )
    resultStatus: Optional[str] = Field(None, description='The passed/failed state')
    runStatus: Optional[str] = Field(
        None,
        description='The current status of the test run, in relation to the various phases',
    )
    state: Optional[str] = Field(None, description='Deprecated. Use runStatus instead.')
    stats: Optional[Stats2Model1] = Field(
        None,
        description='Summary single test run on Xamarin Test Cloud',
        title='Test Run Statistics',
    )
    status: Optional[str] = Field(
        None, description='Deprecated. Use resultStatus instead.'
    )
    testSeries: Optional[str] = Field(
        None,
        description='The name of the test series with which this test upload is associated',
    )
    testType: Optional[str] = Field(
        None, description='The name of the test framework used to run this test'
    )


class TestRun(BaseModel):
    completed: Optional[bool] = Field(
        None, description='Tells whether the test run has completed'
    )
    date: Optional[str] = Field(None, description='Date of the test run.')
    failed: Optional[float] = Field(None, description='Number of failed tests')
    passed: Optional[float] = Field(None, description='Number of passed tests')
    statusDescription: Optional[str] = Field(
        None, description='Human-readable status of the test run.'
    )


class Field1AppsOwnerNameAppNameTestSeriesGetResponseItem(BaseModel):
    mostRecentActivity: Optional[str] = Field(
        None, description='Date of the latest test run that used this test series'
    )
    name: str = Field(..., description='Name of the test series')
    slug: str = Field(
        ..., description='Unique, human-readable identifier of the test series'
    )
    testRuns: Optional[List[TestRun]] = Field(None, description='Most recent test runs')


class Field1AppsOwnerNameAppNameTestSeriesGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameTestSeriesGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameTestSeriesGetResponseItem]


class Field1AppsOwnerNameAppNameTestSeriesPostRequest(BaseModel):
    name: str = Field(..., description='Name of the new test series')


class Field1AppsOwnerNameAppNameTestSeriesPostResponse(BaseModel):
    mostRecentActivity: Optional[str] = Field(
        None, description='Date of the latest test run that used this test series'
    )
    name: str = Field(..., description='Name of the test series')
    slug: str = Field(
        ..., description='Unique, human-readable identifier of the test series'
    )
    testRuns: Optional[List[TestRun]] = Field(None, description='Most recent test runs')


class Field1AppsOwnerNameAppNameTestSeriesPostResponseModel(BaseModel):
    message: str = Field(
        ..., description='Human-readable message that describes the error'
    )
    status: str = Field(..., description='Status of the operation')


class Field1AppsOwnerNameAppNameTestSeriesTestSeriesSlugPatchRequest(BaseModel):
    name: str = Field(..., description='Name of the new test series')


class Field1AppsOwnerNameAppNameTestSeriesTestSeriesSlugPatchResponse(BaseModel):
    mostRecentActivity: Optional[str] = Field(
        None, description='Date of the latest test run that used this test series'
    )
    name: str = Field(..., description='Name of the test series')
    slug: str = Field(
        ..., description='Unique, human-readable identifier of the test series'
    )
    testRuns: Optional[List[TestRun]] = Field(None, description='Most recent test runs')


class Field1AppsOwnerNameAppNameTestSeriesTestSeriesSlugTestRunsGetResponseItem(
    BaseModel
):
    appVersion: Optional[str] = Field(
        None, description='The compiled version of the app binary'
    )
    date: Optional[str] = Field(
        None, description='The date and time the test was uploaded'
    )
    description: Optional[str] = Field(
        None, description='Human readable explanation of the current test status'
    )
    id: Optional[UUID] = Field(None, description='The unique id of the test upload')
    platform: Optional[str] = Field(
        None,
        description="The device platform targeted by the test. Possible values are 'ios' or 'android'",
    )
    resultStatus: Optional[str] = Field(None, description='The passed/failed state')
    runStatus: Optional[str] = Field(
        None,
        description='The current status of the test run, in relation to the various phases',
    )
    state: Optional[str] = Field(None, description='Deprecated. Use runStatus instead.')
    stats: Optional[Stats2Model1] = Field(
        None,
        description='Summary single test run on Xamarin Test Cloud',
        title='Test Run Statistics',
    )
    status: Optional[str] = Field(
        None, description='Deprecated. Use resultStatus instead.'
    )
    testSeries: Optional[str] = Field(
        None,
        description='The name of the test series with which this test upload is associated',
    )
    testType: Optional[str] = Field(
        None, description='The name of the test framework used to run this test'
    )


class Field1AppsOwnerNameAppNameTestSeriesTestSeriesSlugTestRunsGetResponse(
    RootModel[
        List[Field1AppsOwnerNameAppNameTestSeriesTestSeriesSlugTestRunsGetResponseItem]
    ]
):
    root: List[
        Field1AppsOwnerNameAppNameTestSeriesTestSeriesSlugTestRunsGetResponseItem
    ]


class Origin48Model7(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class Field1AppsOwnerNameAppNameTestersGetResponseItem(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin48Model7 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission15Model1]] = Field(
        None, description='The permissions the user has for the app'
    )


class Field1AppsOwnerNameAppNameTestersGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameTestersGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameTestersGetResponseItem]


class Field1AppsOwnerNameAppNameTestersGetResponseModel(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameTestersTesterIdDeleteResponse(BaseModel):
    code: Code8Model16
    message: str


class NodeItem(BaseModel):
    current: Optional[bool] = Field(
        None, description='If the Node version is default for AppCenter'
    )
    name: Optional[str] = Field(None, description='The version name')


class XamarinItem(BaseModel):
    current: Optional[bool] = Field(None, description='If the SDK is latest stable')
    monoVersion: Optional[str] = Field(None, description='The Mono version')
    sdkBundle: Optional[str] = Field(None, description='The Xamarin SDK version')
    stable: Optional[bool] = Field(None, description='If the SDK is stable')
    xcodeVersions: Optional[List[str]] = Field(
        None,
        description='Specific for iOS SDK. A list of Xcode versions supported by current SDK version',
    )


class XcodeItem(BaseModel):
    current: Optional[bool] = Field(None, description='If the Xcode is latest stable')
    name: Optional[str] = Field(None, description='The version name')


class Field1AppsOwnerNameAppNameToolsetsGetResponse(BaseModel):
    node: Optional[List[NodeItem]] = Field(None, description='A list of Node versions')
    xamarin: Optional[List[XamarinItem]] = Field(
        None, description='A list of Xamarin SDK bundles'
    )
    xcode: Optional[List[XcodeItem]] = Field(
        None, description='A list of Xcode versions'
    )


class Field1AppsOwnerNameAppNameToolsetsGetResponseModel(BaseModel):
    code: str
    id: str
    message: str


class Field1AppsOwnerNameAppNameTransferDestinationOwnerNamePostRequest(BaseModel):
    pass


class Type84Model15(Enum):
    org = 'org'
    user = 'user'


class Owner16Model1(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type84Model15 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class Field1AppsOwnerNameAppNameTransferDestinationOwnerNamePostResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner16Model1 = Field(
        ..., description="The information about the app's owner"
    )
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model7 = Field(..., description='The creation origin of this app')
    platform: Platform13Model1 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1AppsOwnerNameAppNameTransferDestinationOwnerNamePostResponseModel(
    BaseModel
):
    error: Error8Model21


class Field1AppsOwnerNameAppNameTransferToOrgPostRequest(BaseModel):
    pass


class Origin48Model8(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class Field1AppsOwnerNameAppNameTransferToOrgPostResponse(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin48Model8 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class Field1AppsOwnerNameAppNameTransferToOrgPostResponseModel(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameUploadsReleasesPostRequest(BaseModel):
    build_number: Optional[str] = Field(None, description='User defined build number')
    build_version: Optional[str] = Field(None, description='User defined build version')


class Field1AppsOwnerNameAppNameUploadsReleasesPostResponse(BaseModel):
    id: UUID = Field(
        ...,
        description='The ID for the newly created upload. It is going to be required later in the process.',
    )
    package_asset_id: UUID = Field(
        ...,
        description='The associated asset ID in the file management service associated with this uploaded.',
    )
    token: str = Field(..., description='The access token used for upload permissions.')
    upload_domain: str = Field(
        ..., description='The URL domain used to upload the release.'
    )
    url_encoded_token: str = Field(
        ...,
        description='The access token used for upload permissions (URL encoded to use as a single query parameter).',
    )


class Field1AppsOwnerNameAppNameUploadsReleasesPostResponseModel(BaseModel):
    code: Code8Model16
    message: str


class UploadStatus4Model(Enum):
    uploadStarted = 'uploadStarted'
    uploadFinished = 'uploadFinished'
    readyToBePublished = 'readyToBePublished'
    malwareDetected = 'malwareDetected'
    error = 'error'


class Field1AppsOwnerNameAppNameUploadsReleasesUploadIdGetResponse(BaseModel):
    error_details: Optional[str] = Field(
        None,
        description="Details describing what went wrong processing the upload. Will only be set if status = 'error'.",
    )
    id: UUID = Field(..., description='The ID for the upload.')
    release_distinct_id: Optional[float] = Field(
        None,
        description="The distinct ID of the release. Will only be set when the status = 'readyToBePublished'.",
    )
    release_url: Optional[Any] = Field(
        None,
        description="The URL of the release. Will only be set when the status = 'readyToBePublished'.",
    )
    upload_status: UploadStatus4Model = Field(
        ..., description='The current upload status.'
    )


class Field1AppsOwnerNameAppNameUploadsReleasesUploadIdGetResponseModel(BaseModel):
    code: Code8Model16
    message: str


class UploadStatus4Model1(Enum):
    uploadFinished = 'uploadFinished'
    uploadCanceled = 'uploadCanceled'


class Field1AppsOwnerNameAppNameUploadsReleasesUploadIdPatchRequest(BaseModel):
    upload_status: UploadStatus4Model1 = Field(
        ..., description='The new status of the release upload'
    )


class UploadStatus4Model2(Enum):
    uploadStarted = 'uploadStarted'
    uploadFinished = 'uploadFinished'
    uploadCanceled = 'uploadCanceled'
    readyToBePublished = 'readyToBePublished'
    malwareDetected = 'malwareDetected'
    error = 'error'


class Field1AppsOwnerNameAppNameUploadsReleasesUploadIdPatchResponse(BaseModel):
    id: UUID = Field(..., description='The ID for the upload.')
    upload_status: UploadStatus4Model2 = Field(
        ..., description='The current upload status.'
    )


class Field1AppsOwnerNameAppNameUploadsReleasesUploadIdPatchResponseModel(BaseModel):
    code: Code8Model16
    message: str


class Owner16Model2(BaseModel):
    displayName: Optional[str] = Field(None, description='Display name of the account')
    id: str = Field(..., description='Account ID')
    name: str = Field(..., description='Name of the account')
    type: str = Field(..., description='Type of account')


class Field1AppsOwnerNameAppNameUserDeviceSetsGetResponseItem(BaseModel):
    deviceConfigurations: List[DeviceConfiguration]
    id: str = Field(..., description='Identifier of the device set')
    manufacturerCount: Optional[float] = Field(
        None,
        description="The number of manufacturers in the device set's device selection",
    )
    name: str = Field(..., description='Name of the device set')
    osVersionCount: Optional[float] = Field(
        None,
        description="The number of os versions in the device set's device selection",
    )
    owner: Owner16Model2 = Field(
        ..., description='The owner of a device set', title='Device Set Owner'
    )
    slug: Optional[str] = Field(None, description='Slug of the device set')


class Field1AppsOwnerNameAppNameUserDeviceSetsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameUserDeviceSetsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameUserDeviceSetsGetResponseItem]


class Field1AppsOwnerNameAppNameUserDeviceSetsPostRequest(BaseModel):
    devices: List[str] = Field(..., description='List of device IDs')
    name: str = Field(..., description='The name of the device set')


class Field1AppsOwnerNameAppNameUserDeviceSetsPostResponse(BaseModel):
    deviceConfigurations: List[DeviceConfiguration]
    id: str = Field(..., description='Identifier of the device set')
    manufacturerCount: Optional[float] = Field(
        None,
        description="The number of manufacturers in the device set's device selection",
    )
    name: str = Field(..., description='Name of the device set')
    osVersionCount: Optional[float] = Field(
        None,
        description="The number of os versions in the device set's device selection",
    )
    owner: Owner16Model2 = Field(
        ..., description='The owner of a device set', title='Device Set Owner'
    )
    slug: Optional[str] = Field(None, description='Slug of the device set')


class Field1AppsOwnerNameAppNameUserDeviceSetsPostResponseModel(BaseModel):
    message: str = Field(
        ..., description='Human-readable message that describes the error'
    )
    status: str = Field(..., description='Status of the operation')


class Field1AppsOwnerNameAppNameUserDeviceSetsIdGetResponse(BaseModel):
    deviceConfigurations: List[DeviceConfiguration]
    id: str = Field(..., description='Identifier of the device set')
    manufacturerCount: Optional[float] = Field(
        None,
        description="The number of manufacturers in the device set's device selection",
    )
    name: str = Field(..., description='Name of the device set')
    osVersionCount: Optional[float] = Field(
        None,
        description="The number of os versions in the device set's device selection",
    )
    owner: Owner16Model2 = Field(
        ..., description='The owner of a device set', title='Device Set Owner'
    )
    slug: Optional[str] = Field(None, description='Slug of the device set')


class Field1AppsOwnerNameAppNameUserDeviceSetsIdPutRequest(BaseModel):
    devices: List[str] = Field(..., description='List of device IDs')
    name: str = Field(..., description='The name of the device set')


class Field1AppsOwnerNameAppNameUserDeviceSetsIdPutResponse(BaseModel):
    deviceConfigurations: List[DeviceConfiguration]
    id: str = Field(..., description='Identifier of the device set')
    manufacturerCount: Optional[float] = Field(
        None,
        description="The number of manufacturers in the device set's device selection",
    )
    name: str = Field(..., description='Name of the device set')
    osVersionCount: Optional[float] = Field(
        None,
        description="The number of os versions in the device set's device selection",
    )
    owner: Owner16Model2 = Field(
        ..., description='The owner of a device set', title='Device Set Owner'
    )
    slug: Optional[str] = Field(None, description='Slug of the device set')


class Field1AppsOwnerNameAppNameUserDeviceSetsIdPutResponseModel(BaseModel):
    message: str = Field(
        ..., description='Human-readable message that describes the error'
    )
    status: str = Field(..., description='Status of the operation')


class Origin48Model9(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class Field1AppsOwnerNameAppNameUsersGetResponseItem(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin48Model9 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission15Model1]] = Field(
        None, description='The permissions the user has for the app'
    )


class Field1AppsOwnerNameAppNameUsersGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameUsersGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameUsersGetResponseItem]


class Field1AppsOwnerNameAppNameUsersGetResponseModel(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameUsersUserEmailDeleteResponse(BaseModel):
    error: Error8Model21


class Permission15Model2(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'


class Field1AppsOwnerNameAppNameUsersUserEmailPatchRequest(BaseModel):
    permissions: List[Permission15Model2] = Field(
        ..., description='The permissions the user has for the app'
    )


class Field1AppsOwnerNameAppNameUsersUserEmailPatchResponse(BaseModel):
    error: Error8Model21


class Field1AppsOwnerNameAppNameVersionsGetResponseItem(BaseModel):
    app_id: str
    app_version: str
    app_version_id: str
    build_number: Optional[str] = None
    display_name: str


class Field1AppsOwnerNameAppNameVersionsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameVersionsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameVersionsGetResponseItem]


class Field1AppsOwnerNameAppNameVersionsGetResponseModel(BaseModel):
    message: str


class EventType7Model1(Enum):
    newCrashGroupCreated = 'newCrashGroupCreated'
    newAppReleased = 'newAppReleased'


class Value8Model3(BaseModel):
    enabled: Optional[bool] = Field(None, description='Allows eanble/disable webhook')
    event_types: List[EventType7Model1] = Field(
        ..., description='Event types enabled for webhook'
    )
    id: Optional[str] = Field(None, description='The unique id (UUID) of the webhook')
    name: constr(max_length=512) = Field(..., description='display name of the webhook')
    url: str = Field(..., description='target url of the webhook')


class Field1AppsOwnerNameAppNameWebhooksGetResponse(BaseModel):
    values: List[Value8Model3]


class Code8Model17(Enum):
    integer_400 = 400
    integer_404 = 404
    integer_409 = 409
    integer_500 = 500


class Field1AppsOwnerNameAppNameWebhooksGetResponseModel(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    code: Code8Model17 = Field(
        ...,
        description='The status code return by the API. It can be 400 or 404 or 409 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed'
    )


class Field1AppsOwnerNameAppNameXamarinSdkBundlesGetResponseItem(BaseModel):
    current: Optional[bool] = Field(None, description='If the SDK is latest stable')
    monoVersion: Optional[str] = Field(None, description='The Mono version')
    sdkBundle: Optional[str] = Field(None, description='The Xamarin SDK version')
    stable: Optional[bool] = Field(None, description='If the SDK is stable')
    xcodeVersions: Optional[List[str]] = Field(
        None,
        description='Specific for iOS SDK. A list of Xcode versions supported by current SDK version',
    )


class Field1AppsOwnerNameAppNameXamarinSdkBundlesGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameXamarinSdkBundlesGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameXamarinSdkBundlesGetResponseItem] = Field(
        ..., description='A list of Xamarin SDK bundles'
    )


class Field1AppsOwnerNameAppNameXamarinSdkBundlesGetResponseModel(BaseModel):
    code: str
    id: str
    message: str


class Field1AppsOwnerNameAppNameXcodeVersionsGetResponseItem(BaseModel):
    current: Optional[bool] = Field(None, description='If the Xcode is latest stable')
    name: Optional[str] = Field(None, description='The version name')


class Field1AppsOwnerNameAppNameXcodeVersionsGetResponse(
    RootModel[List[Field1AppsOwnerNameAppNameXcodeVersionsGetResponseItem]]
):
    root: List[Field1AppsOwnerNameAppNameXcodeVersionsGetResponseItem] = Field(
        ..., description='A list of Xcode versions'
    )


class Field1AppsOwnerNameAppNameXcodeVersionsGetResponseModel(BaseModel):
    code: str
    id: str
    message: str


class Field1AzureSubscriptionsGetResponseItem(BaseModel):
    is_billable: Optional[bool] = Field(
        None, description='If the subscription can be used for billing'
    )
    is_billing: Optional[bool] = Field(
        None, description='If the subscription is used for billing'
    )
    is_microsoft_internal: Optional[bool] = Field(
        None, description='If the subscription is internal Microsoft subscription'
    )
    subscription_id: UUID = Field(..., description='The azure subscription id')
    subscription_name: str = Field(
        ..., description='The name of the azure subscription'
    )
    tenant_id: UUID = Field(
        ..., description='The tenant id of the azure subscription belongs to'
    )


class Field1AzureSubscriptionsGetResponse(
    RootModel[List[Field1AzureSubscriptionsGetResponseItem]]
):
    root: List[Field1AzureSubscriptionsGetResponseItem]


class Code8Model18(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Field1AzureSubscriptionsGetResponseModel(BaseModel):
    error: Error8Model21


class Plan12Model(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class BuildService7Model1(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class TestService7Model1(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class BuildService7Model2(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class TestService7Model2(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class AggregatedBillings(BaseModel):
    azureSubscriptionId: Optional[str] = Field(
        None,
        description='Unique identifier for the Azure subscription used for billing',
    )
    azureSubscriptionState: Optional[AzureSubscriptionState] = Field(
        None, description='State of the Azure subscription used for billing'
    )
    billingPlans: Optional[BillingPlans] = Field(
        None, description='Billing Plans section in the Billing Information'
    )
    id: Optional[str] = Field(None, description='ID of the user or organization')
    timestamp: Optional[str] = Field(
        None, description='The ISO 8601 datetime of last modification'
    )
    usage: Optional[Usage] = Field(
        None, description='Usage section in the Billing Information'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Information schema'
    )


class Field1BillingAllAccountsAggregatedGetResponse(BaseModel):
    aggregatedBillings: Optional[AggregatedBillings] = Field(
        None, description='Aggregated Billing Information for a user or an organization'
    )


class Code8Model19(Enum):
    integer_400 = 400
    integer_403 = 403
    integer_500 = 500


class Error8Model22(BaseModel):
    code: Optional[Code8Model19] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed'
    )


class Field1BillingAllAccountsAggregatedGetResponseModel(BaseModel):
    error: Optional[Error8Model22] = None


class Owner16Model3(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type84Model15 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class Origin48Model10(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class Organization(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin48Model10 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class Field1InvitationsSentGetResponseItem(BaseModel):
    app: Optional[App] = None
    invitation_id: UUID = Field(..., description='The id of the invitation')
    organization: Optional[Organization] = None


class Field1InvitationsSentGetResponse(
    RootModel[List[Field1InvitationsSentGetResponseItem]]
):
    root: List[Field1InvitationsSentGetResponseItem]


class Code8Model20(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error8Model23(BaseModel):
    code: Code8Model20
    message: str


class Field1InvitationsSentGetResponseModel(BaseModel):
    error: Error8Model23


class Field1LegacyReportStatusDeployPostRequest(BaseModel):
    appVersion: Optional[str] = None
    clientUniqueId: Optional[str] = None
    deploymentKey: Optional[str] = None
    label: Optional[str] = None
    previousDeploymentKey: Optional[str] = None
    previousLabelOrAppVersion: Optional[str] = None
    status: Optional[str] = None


class Field1LegacyReportStatusDeployPostResponse(BaseModel):
    message: str


class Field1LegacyReportStatusDownloadPostRequest(BaseModel):
    appVersion: Optional[str] = None
    clientUniqueId: Optional[str] = None
    deploymentKey: Optional[str] = None
    label: Optional[str] = None
    previousDeploymentKey: Optional[str] = None
    previousLabelOrAppVersion: Optional[str] = None
    status: Optional[str] = None


class Field1LegacyReportStatusDownloadPostResponse(BaseModel):
    message: str


class UpdateInfo(BaseModel):
    appVersion: Optional[str] = None
    description: Optional[str] = None
    isDisabled: Optional[bool] = None
    isMandatory: Optional[bool] = None
    rollout: Optional[int] = None
    downloadURL: Optional[str] = None
    isAvailable: bool
    label: Optional[str] = None
    packageHash: Optional[str] = None
    packageSize: Optional[float] = None
    shouldRunBinaryVersion: Optional[bool] = None
    updateAppVersion: Optional[bool] = None


class Field1LegacyUpdateCheckGetResponse(BaseModel):
    updateInfo: UpdateInfo


class Field1LegacyUpdateCheckGetResponseModel(BaseModel):
    message: str


class Field1OrgsGetResponseItem(BaseModel):
    display_name: str = Field(..., description='The display name of the organization')
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin48Model10 = Field(
        ..., description='The creation origin of this organization'
    )


class Field1OrgsGetResponse(RootModel[List[Field1OrgsGetResponseItem]]):
    root: List[Field1OrgsGetResponseItem]


class Field1OrgsGetResponseModel(BaseModel):
    error: Error8Model23


class Field1OrgsPostRequest(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The display name of the organization'
    )
    name: Optional[str] = Field(
        None, description='The name of the organization used in URLs'
    )


class Field1OrgsPostResponse(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin48Model10 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class Field1OrgsPostResponseModel(BaseModel):
    error: Error8Model23


class Plan12Model1(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class BuildService7Model3(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class TestService7Model3(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class BuildService7Model4(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class TestService7Model4(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class Field1OrgsOrgNameBillingAggregatedGetResponse(BaseModel):
    azureSubscriptionId: Optional[str] = Field(
        None,
        description='Unique identifier for the Azure subscription used for billing',
    )
    azureSubscriptionState: Optional[AzureSubscriptionState] = Field(
        None, description='State of the Azure subscription used for billing'
    )
    billingPlans: Optional[BillingPlans] = Field(
        None, description='Billing Plans section in the Billing Information'
    )
    id: Optional[str] = Field(None, description='ID of the user or organization')
    timestamp: Optional[str] = Field(
        None, description='The ISO 8601 datetime of last modification'
    )
    usage: Optional[Usage] = Field(
        None, description='Usage section in the Billing Information'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Information schema'
    )


class Code8Model21(Enum):
    integer_400 = 400
    integer_403 = 403
    integer_500 = 500


class Error8Model24(BaseModel):
    code: Optional[Code8Model21] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed'
    )


class Field1OrgsOrgNameBillingAggregatedGetResponseModel(BaseModel):
    error: Optional[Error8Model24] = None


class Code8Model22(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error8Model25(BaseModel):
    code: Code8Model22
    message: str


class Field1OrgsOrgNameDeleteResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameGetResponse(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin48Model10 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class Field1OrgsOrgNameGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNamePatchRequest(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The full (friendly) name of the organization.'
    )
    name: Optional[str] = Field(
        None, description='The name of the organization used in URLs'
    )


class Field1OrgsOrgNamePatchResponse(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin48Model10 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class Field1OrgsOrgNamePatchResponseModel(BaseModel):
    error: Error8Model25


class Origin48Model11(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class Field1OrgsOrgNameAppsGetResponseItem(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner16Model3 = Field(
        ..., description="The information about the app's owner"
    )
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model11 = Field(..., description='The creation origin of this app')
    platform: Platform13Model1 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1OrgsOrgNameAppsGetResponse(
    RootModel[List[Field1OrgsOrgNameAppsGetResponseItem]]
):
    root: List[Field1OrgsOrgNameAppsGetResponseItem]


class Field1OrgsOrgNameAppsGetResponseModel(BaseModel):
    error: Error8Model25


class Platform15(Enum):
    Java = 'Java'
    Objective_C_Swift = 'Objective-C-Swift'
    UWP = 'UWP'
    Cordova = 'Cordova'
    React_Native = 'React-Native'
    Xamarin = 'Xamarin'
    Unity = 'Unity'
    Electron = 'Electron'
    WPF = 'WPF'
    WinForms = 'WinForms'
    Custom = 'Custom'


class Field1OrgsOrgNameAppsPostRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='A short text describing the app'
    )
    display_name: str = Field(
        ...,
        description='The descriptive name of the app. This can contain any characters',
    )
    name: Optional[str] = Field(None, description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    platform: Platform15 = Field(..., description='The platform of the app')
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )


class Platform15Model(Enum):
    Java = 'Java'
    Objective_C_Swift = 'Objective-C-Swift'
    UWP = 'UWP'
    Cordova = 'Cordova'
    React_Native = 'React-Native'
    Unity = 'Unity'
    Electron = 'Electron'
    Xamarin = 'Xamarin'
    WPF = 'WPF'
    WinForms = 'WinForms'
    Unknown = 'Unknown'
    Custom = 'Custom'


class Field1OrgsOrgNameAppsPostResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner16Model3 = Field(
        ..., description="The information about the app's owner"
    )
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model11 = Field(..., description='The creation origin of this app')
    platform: Platform15Model = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1OrgsOrgNameAppsPostResponseModel(BaseModel):
    error: Error8Model25


class Origin48Model12(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class Field1OrgsOrgNameAvatarDeleteResponse(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin48Model12 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class Field1OrgsOrgNameAvatarDeleteResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameAvatarPostRequest(BaseModel):
    avatar: Optional[bytes] = Field(
        None, description='The image for an Organization avatar to upload.'
    )


class Field1OrgsOrgNameAvatarPostResponse(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin48Model12 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class Field1OrgsOrgNameAvatarPostResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameAzureSubscriptionsGetResponseItem(BaseModel):
    is_billable: Optional[bool] = Field(
        None, description='If the subscription can be used for billing'
    )
    is_billing: Optional[bool] = Field(
        None, description='If the subscription is used for billing'
    )
    is_microsoft_internal: Optional[bool] = Field(
        None, description='If the subscription is internal Microsoft subscription'
    )
    subscription_id: UUID = Field(..., description='The azure subscription id')
    subscription_name: str = Field(
        ..., description='The name of the azure subscription'
    )
    tenant_id: UUID = Field(
        ..., description='The tenant id of the azure subscription belongs to'
    )


class Field1OrgsOrgNameAzureSubscriptionsGetResponse(
    RootModel[List[Field1OrgsOrgNameAzureSubscriptionsGetResponseItem]]
):
    root: List[Field1OrgsOrgNameAzureSubscriptionsGetResponseItem]


class Field1OrgsOrgNameAzureSubscriptionsGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameDistributionGroupsGetResponseItem(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin48Model12 = Field(
        ..., description='The creation origin of this distribution group'
    )


class Field1OrgsOrgNameDistributionGroupsGetResponse(
    RootModel[List[Field1OrgsOrgNameDistributionGroupsGetResponseItem]]
):
    root: List[Field1OrgsOrgNameDistributionGroupsGetResponseItem]


class Field1OrgsOrgNameDistributionGroupsGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameDistributionGroupsPostRequest(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The display name of the distribution group. If not specified, the name will be used.',
    )
    name: str = Field(..., description='The name of the distribution group')


class Field1OrgsOrgNameDistributionGroupsPostResponse(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin48Model12 = Field(
        ..., description='The creation origin of this distribution group'
    )


class Field1OrgsOrgNameDistributionGroupsPostResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameDeleteResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameGetResponse(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin48Model12 = Field(
        ..., description='The creation origin of this distribution group'
    )


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameGetResponseModel(
    BaseModel
):
    error: Error8Model25


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNamePatchRequest(BaseModel):
    is_public: Optional[bool] = Field(
        None, description='Whether the distribution group is public'
    )
    name: Optional[str] = Field(None, description='The name of the distribution group')


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNamePatchResponse(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin48Model12 = Field(
        ..., description='The creation origin of this distribution group'
    )


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNamePatchResponseModel(
    BaseModel
):
    error: Error8Model25


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameAppsGetResponseItem(
    BaseModel
):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner16Model3 = Field(
        ..., description="The information about the app's owner"
    )
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    origin: Optional[str] = Field(None, description='The creation origin of this app')
    platform: Optional[str] = Field(None, description='The platform of the app')


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameAppsGetResponse(
    RootModel[
        List[
            Field1OrgsOrgNameDistributionGroupsDistributionGroupNameAppsGetResponseItem
        ]
    ]
):
    root: List[
        Field1OrgsOrgNameDistributionGroupsDistributionGroupNameAppsGetResponseItem
    ]


class App8Model(BaseModel):
    name: str = Field(
        ..., description='The name of the app to be added to the distribution group'
    )


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameAppsPostRequest(
    BaseModel
):
    apps: Optional[List[App8Model]] = Field(
        None, description='The list of apps to add to distribution group'
    )


class App8Model1(BaseModel):
    name: str = Field(
        ..., description='The name of the app to be deleted from the distribution group'
    )


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameAppsBulkDeletePostRequest(
    BaseModel
):
    apps: Optional[List[App8Model1]] = Field(
        None,
        description='The list of apps to delete from the distribution group',
        min_length=1,
    )


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersGetResponseItem(
    BaseModel
):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: Optional[UUID] = Field(None, description='The unique id (UUID) of the user')
    invite_pending: Optional[bool] = Field(
        None,
        description='Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".',
    )
    name: Optional[str] = Field(
        None, description='The unique name that is used to identify the user.'
    )


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersGetResponse(
    RootModel[
        List[
            Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersGetResponseItem
        ]
    ]
):
    root: List[
        Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersGetResponseItem
    ]


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersGetResponseModel(
    BaseModel
):
    error: Error8Model25


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersPostRequest(
    BaseModel
):
    user_emails: Optional[List[str]] = Field(
        None, description='The list of emails of the users', min_length=1
    )


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersPostResponseItem(
    BaseModel
):
    code: Optional[str] = Field(None, description='The code of the result')
    invite_pending: Optional[bool] = Field(
        None,
        description='Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".',
    )
    message: Optional[str] = Field(None, description='The message of the result')
    status: int = Field(..., description='The status code of the result')
    user_email: Optional[str] = Field(None, description='The email of the user')


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersPostResponse(
    RootModel[
        List[
            Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersPostResponseItem
        ]
    ]
):
    root: List[
        Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersPostResponseItem
    ]


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersPostResponseModel(
    BaseModel
):
    error: Error8Model25


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameMembersBulkDeletePostRequest(
    BaseModel
):
    user_emails: Optional[List[str]] = Field(
        None, description='The list of emails of the users', min_length=1
    )


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameResendInvitePostRequest(
    BaseModel
):
    user_emails: Optional[List[str]] = Field(
        None, description='The list of emails of the users', min_length=1
    )


class Field1OrgsOrgNameDistributionGroupsDistributionGroupNameResendInvitePostResponse(
    BaseModel
):
    error: Error8Model25


class Origin48Model13(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class App8Model2(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner16Model3 = Field(
        ..., description="The information about the app's owner"
    )
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model13 = Field(..., description='The creation origin of this app')
    platform: Platform15Model = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1OrgsOrgNameDistributionGroupsDetailsGetResponseItem(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin48Model12 = Field(
        ..., description='The creation origin of this distribution group'
    )
    apps: List[App8Model2] = Field(
        ..., description='The apps associated with the distribution group'
    )
    total_apps_count: float = Field(
        ..., description='The count of apps associated with this distribution group'
    )
    total_users_count: float = Field(
        ..., description='The count of users in the distribution group'
    )


class Field1OrgsOrgNameDistributionGroupsDetailsGetResponse(
    RootModel[List[Field1OrgsOrgNameDistributionGroupsDetailsGetResponseItem]]
):
    root: List[Field1OrgsOrgNameDistributionGroupsDetailsGetResponseItem]


class Field1OrgsOrgNameDistributionGroupsDetailsGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameInvitationsDeleteRequest(BaseModel):
    user_email: str = Field(..., description="The user's email address")


class Field1OrgsOrgNameInvitationsDeleteResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameInvitationsGetResponseItem(BaseModel):
    email: str = Field(..., description='The email address of the invited user')
    id: UUID = Field(..., description='The unique ID (UUID) of the invitation')
    role: str = Field(..., description='The role assigned to the invited user')


class Field1OrgsOrgNameInvitationsGetResponse(
    RootModel[List[Field1OrgsOrgNameInvitationsGetResponseItem]]
):
    root: List[Field1OrgsOrgNameInvitationsGetResponseItem]


class Field1OrgsOrgNameInvitationsGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameInvitationsPostRequest(BaseModel):
    role: Optional[Role] = Field(None, description="The user's role")
    user_email: str = Field(..., description="The user's email address")


class Field1OrgsOrgNameInvitationsPostResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameInvitationsEmailPatchRequest(BaseModel):
    role: Optional[Role] = Field(
        None, description="The user's role in the organizatiion"
    )


class Field1OrgsOrgNameInvitationsEmailPatchResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameInvitationsEmailResendPostRequest(BaseModel):
    role: Optional[Role] = Field(None, description='The role of the user to be added')


class Field1OrgsOrgNameInvitationsEmailResendPostResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameInvitationsEmailRevokePostRequest(BaseModel):
    pass


class Field1OrgsOrgNameInvitationsEmailRevokePostResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTeamsGetResponseItem(BaseModel):
    description: Optional[str] = Field(None, description='The description of the team')
    display_name: str = Field(..., description='The display name of the team')
    id: UUID = Field(..., description='The internal unique id (UUID) of the team.')
    name: str = Field(..., description='The name of the team')


class Field1OrgsOrgNameTeamsGetResponse(
    RootModel[List[Field1OrgsOrgNameTeamsGetResponseItem]]
):
    root: List[Field1OrgsOrgNameTeamsGetResponseItem]


class Field1OrgsOrgNameTeamsGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTeamsPostRequest(BaseModel):
    description: Optional[str] = Field(None, description='The description of the team')
    display_name: str = Field(..., description='The display name of the team')
    name: Optional[str] = Field(None, description='The name of the team')


class Field1OrgsOrgNameTeamsPostResponseItem(BaseModel):
    description: Optional[str] = Field(None, description='The description of the team')
    display_name: str = Field(..., description='The display name of the team')
    id: UUID = Field(..., description='The internal unique id (UUID) of the team.')
    name: str = Field(..., description='The name of the team')


class Field1OrgsOrgNameTeamsPostResponse(
    RootModel[List[Field1OrgsOrgNameTeamsPostResponseItem]]
):
    root: List[Field1OrgsOrgNameTeamsPostResponseItem]


class Field1OrgsOrgNameTeamsPostResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTeamsTeamNameDeleteResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTeamsTeamNameGetResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the team')
    display_name: str = Field(..., description='The display name of the team')
    id: UUID = Field(..., description='The internal unique id (UUID) of the team.')
    name: str = Field(..., description='The name of the team')


class Field1OrgsOrgNameTeamsTeamNameGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTeamsTeamNamePatchRequest(BaseModel):
    display_name: str = Field(..., description='The new display name of the team')


class Field1OrgsOrgNameTeamsTeamNamePatchResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the team')
    display_name: str = Field(..., description='The display name of the team')
    id: UUID = Field(..., description='The internal unique id (UUID) of the team.')
    name: str = Field(..., description='The name of the team')


class Field1OrgsOrgNameTeamsTeamNamePatchResponseModel(BaseModel):
    error: Error8Model25


class TeamPermission(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'


class Field1OrgsOrgNameTeamsTeamNameAppsGetResponseItem(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner16Model3 = Field(
        ..., description="The information about the app's owner"
    )
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model13 = Field(..., description='The creation origin of this app')
    platform: Platform15Model = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )
    team_permissions: Optional[List[TeamPermission]] = Field(
        None, description='The permissions the team has for the app'
    )


class Field1OrgsOrgNameTeamsTeamNameAppsGetResponse(
    RootModel[List[Field1OrgsOrgNameTeamsTeamNameAppsGetResponseItem]]
):
    root: List[Field1OrgsOrgNameTeamsTeamNameAppsGetResponseItem]


class Field1OrgsOrgNameTeamsTeamNameAppsGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTeamsTeamNameAppsPostRequest(BaseModel):
    name: str = Field(
        ..., description='The name of the app to be added to the distribution group'
    )


class Field1OrgsOrgNameTeamsTeamNameAppsPostResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner16Model3 = Field(
        ..., description="The information about the app's owner"
    )
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model13 = Field(..., description='The creation origin of this app')
    platform: Platform15Model = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )
    team_permissions: Optional[List[TeamPermission]] = Field(
        None, description='The permissions the team has for the app'
    )


class Field1OrgsOrgNameTeamsTeamNameAppsPostResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTeamsTeamNameAppsAppNameDeleteResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTeamsTeamNameAppsAppNamePatchRequest(BaseModel):
    permissions: List[Permission15Model2] = Field(
        ..., description='The permissions all members of the team have on the app'
    )


class Field1OrgsOrgNameTeamsTeamNameAppsAppNamePatchResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner16Model3 = Field(
        ..., description="The information about the app's owner"
    )
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model13 = Field(..., description='The creation origin of this app')
    platform: Platform15Model = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )
    team_permissions: Optional[List[TeamPermission]] = Field(
        None, description='The permissions the team has for the app'
    )


class Field1OrgsOrgNameTeamsTeamNameAppsAppNamePatchResponseModel(BaseModel):
    error: Error8Model25


class Role7Model(Enum):
    maintainer = 'maintainer'
    collaborator = 'collaborator'


class Field1OrgsOrgNameTeamsTeamNameUsersGetResponse(BaseModel):
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    role: Role7Model = Field(
        ..., description='The role of the user has within the team'
    )


class Field1OrgsOrgNameTeamsTeamNameUsersGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTeamsTeamNameUsersPostRequest(BaseModel):
    user_email: str = Field(..., description="The user's email address")


class Field1OrgsOrgNameTeamsTeamNameUsersPostResponse(BaseModel):
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    role: Role7Model = Field(
        ..., description='The role of the user has within the team'
    )


class Field1OrgsOrgNameTeamsTeamNameUsersPostResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTeamsTeamNameUsersUserNameDeleteResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameTestersGetResponseItem(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The full name of the tester. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the tester')
    name: str = Field(
        ..., description='The unique name that is used to identify the tester.'
    )


class Field1OrgsOrgNameTestersGetResponse(
    RootModel[List[Field1OrgsOrgNameTestersGetResponseItem]]
):
    root: List[Field1OrgsOrgNameTestersGetResponseItem]


class Field1OrgsOrgNameTestersGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameUsersGetResponseItem(BaseModel):
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    joined_at: str = Field(
        ..., description='The date when the user joined the organization'
    )
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    role: str = Field(..., description='The role the user has within the organization')


class Field1OrgsOrgNameUsersGetResponse(
    RootModel[List[Field1OrgsOrgNameUsersGetResponseItem]]
):
    root: List[Field1OrgsOrgNameUsersGetResponseItem]


class Field1OrgsOrgNameUsersGetResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameUsersUserNameDeleteResponse(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameUsersUserNameGetResponse(BaseModel):
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    joined_at: str = Field(
        ..., description='The date when the user joined the organization'
    )
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    role: str = Field(..., description='The role the user has within the organization')


class Field1OrgsOrgNameUsersUserNameGetResponseModel(BaseModel):
    error: Error8Model25


class Role7Model1(Enum):
    admin = 'admin'
    collaborator = 'collaborator'
    member = 'member'


class Field1OrgsOrgNameUsersUserNamePatchRequest(BaseModel):
    role: Optional[Role7Model1] = Field(
        None, description="The user's role in the organizatiion"
    )


class Field1OrgsOrgNameUsersUserNamePatchResponse(BaseModel):
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    joined_at: str = Field(
        ..., description='The date when the user joined the organization'
    )
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    role: str = Field(..., description='The role the user has within the organization')


class Field1OrgsOrgNameUsersUserNamePatchResponseModel(BaseModel):
    error: Error8Model25


class Field1OrgsOrgNameUsersUserNameAppsGetResponseItem(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner16Model3 = Field(
        ..., description="The information about the app's owner"
    )
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin48Model13 = Field(..., description='The creation origin of this app')
    platform: Platform15Model = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Field1OrgsOrgNameUsersUserNameAppsGetResponse(
    RootModel[List[Field1OrgsOrgNameUsersUserNameAppsGetResponseItem]]
):
    root: List[Field1OrgsOrgNameUsersUserNameAppsGetResponseItem]


class Field1OrgsOrgNameUsersUserNameAppsGetResponseModel(BaseModel):
    error: Error8Model25


class Field1PublicAppsAppIdReleasesReleaseIdIosManifestGetResponse(BaseModel):
    code: Code8Model22
    message: str


class Release7Model(BaseModel):
    distribution_group_id: str = Field(..., description='distribution group id')
    release_id: int = Field(..., description='release id')
    user_id: UUID = Field(..., description='user id')


class Field1PublicAppsOwnerNameAppNameInstallAnalyticsPostRequest(BaseModel):
    releases: Optional[List[Release7Model]] = None


class Field1PublicCodepushReportStatusDeployPostRequest(BaseModel):
    app_version: Optional[str] = None
    client_unique_id: Optional[str] = None
    deployment_key: str
    label: Optional[str] = None
    previous_deployment_key: Optional[str] = None
    previous_label_or_app_version: Optional[str] = None
    status: Optional[str] = None


class Field1PublicCodepushReportStatusDeployPostResponse(BaseModel):
    message: str


class Field1PublicCodepushReportStatusDownloadPostRequest(BaseModel):
    app_version: Optional[str] = None
    client_unique_id: Optional[str] = None
    deployment_key: str
    label: Optional[str] = None
    previous_deployment_key: Optional[str] = None
    previous_label_or_app_version: Optional[str] = None
    status: Optional[str] = None


class Field1PublicCodepushReportStatusDownloadPostResponse(BaseModel):
    message: str


class Field1PublicCodepushStatusGetResponse(BaseModel):
    code: str = Field(..., description='The code indicating the status')
    message: str = Field(..., description='The message indicating the status')


class Field1PublicCodepushStatusGetResponseModel(BaseModel):
    message: str


class UpdateInfo2Model(BaseModel):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    download_url: Optional[str] = None
    is_available: bool
    label: Optional[str] = None
    package_hash: Optional[str] = None
    package_size: Optional[float] = None
    should_run_binary_version: Optional[bool] = None
    update_app_version: Optional[bool] = None


class Field1PublicCodepushUpdateCheckGetResponse(BaseModel):
    update_info: UpdateInfo2Model


class Field1PublicCodepushUpdateCheckGetResponseModel(BaseModel):
    message: str


class Field1PublicHooksPostRequest(BaseModel):
    pass


class Field1PublicHooksPostResponse(BaseModel):
    code: str
    id: str
    message: str


class Type84Model16(Enum):
    intune = 'intune'
    googleplay = 'googleplay'
    apple = 'apple'
    none = 'none'


class Destination8Model5(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution group.',
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type84Model16] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )
    destination_type: Optional[DestinationType] = Field(
        None, description='Destination can be either store or group.'
    )
    display_name: Optional[str] = Field(
        None, description='Display name for the group or tester'
    )


class Origin48Model14(Enum):
    hockeyapp = 'hockeyapp'
    appcenter = 'appcenter'


class Field1PublicSdkAppsAppSecretDistributionGroupsDistributionGroupIdReleasesLatestGetResponse(
    BaseModel
):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: str = Field(..., description="The app's display name.")
    app_icon_url: str = Field(..., description="A URL to the app's icon.")
    app_name: str = Field(
        ..., description="The app's name (extracted from the uploaded release)."
    )
    app_os: Optional[str] = Field(None, description="The app's OS.")
    build: Optional[Build] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    can_resign: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value determines if a release can be re-signed. When true, after a re-sign, the tester will be able to install the release from his registered devices. Will not be returned for non-iOS platforms.',
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned.<br>\n<b>tester</b>: The release distributed testers details will be returned.<br>\n',
    )
    destinations: Optional[List[Destination8Model5]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    device_family: Optional[str] = Field(
        None, description="The release's device family."
    )
    distribution_groups: Optional[List[DistributionGroup4Model2]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore5Model4]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    install_url: Optional[str] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    is_provisioning_profile_syncing: Optional[bool] = Field(
        None,
        description="A flag that determines whether the release's provisioning profile is still extracted or not.",
    )
    is_udid_provisioned: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value will hold the provisioning status of that UDID in this release. Will be ignored for non-iOS platforms.',
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    origin: Optional[Origin48Model14] = Field(None, description="The release's origin")
    package_hashes: Optional[List[str]] = Field(
        None, description='Hashes for the packages.'
    )
    provisioning_profile_expiry_date: Optional[str] = Field(
        None, description='expiration date of provisioning profile in UTC format.'
    )
    provisioning_profile_name: Optional[str] = Field(
        None, description="The release's provisioning profile name."
    )
    provisioning_profile_type: Optional[ProvisioningProfileType] = Field(
        None,
        description='The type of the provisioning profile for the requested app version.',
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    secondary_download_url: Optional[str] = Field(
        None,
        description='The URL that hosts the secondary binary for this release, such as the apk file for aab releases.',
    )
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[int] = Field(None, description="The release's size in bytes.")
    status: Optional[str] = Field(None, description='Status of the release.')
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1PublicSdkAppsAppSecretDistributionGroupsDistributionGroupIdReleasesLatestGetResponseModel(
    BaseModel
):
    code: Code8Model22
    message: str


class Field1PublicSdkAppsAppSecretReleasesLatestGetResponse(BaseModel):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: str = Field(..., description="The app's display name.")
    app_icon_url: str = Field(..., description="A URL to the app's icon.")
    app_name: str = Field(
        ..., description="The app's name (extracted from the uploaded release)."
    )
    app_os: Optional[str] = Field(None, description="The app's OS.")
    build: Optional[Build] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    can_resign: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value determines if a release can be re-signed. When true, after a re-sign, the tester will be able to install the release from his registered devices. Will not be returned for non-iOS platforms.',
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned.<br>\n<b>tester</b>: The release distributed testers details will be returned.<br>\n',
    )
    destinations: Optional[List[Destination8Model5]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    device_family: Optional[str] = Field(
        None, description="The release's device family."
    )
    distribution_groups: Optional[List[DistributionGroup4Model2]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore5Model4]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    install_url: Optional[str] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    is_provisioning_profile_syncing: Optional[bool] = Field(
        None,
        description="A flag that determines whether the release's provisioning profile is still extracted or not.",
    )
    is_udid_provisioned: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value will hold the provisioning status of that UDID in this release. Will be ignored for non-iOS platforms.',
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    origin: Optional[Origin48Model14] = Field(None, description="The release's origin")
    package_hashes: Optional[List[str]] = Field(
        None, description='Hashes for the packages.'
    )
    provisioning_profile_expiry_date: Optional[str] = Field(
        None, description='expiration date of provisioning profile in UTC format.'
    )
    provisioning_profile_name: Optional[str] = Field(
        None, description="The release's provisioning profile name."
    )
    provisioning_profile_type: Optional[ProvisioningProfileType] = Field(
        None,
        description='The type of the provisioning profile for the requested app version.',
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    secondary_download_url: Optional[str] = Field(
        None,
        description='The URL that hosts the secondary binary for this release, such as the apk file for aab releases.',
    )
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[int] = Field(None, description="The release's size in bytes.")
    status: Optional[str] = Field(None, description='Status of the release.')
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1PublicSdkAppsAppSecretReleasesLatestGetResponseModel(BaseModel):
    code: Code8Model22
    message: str


class Field1PublicSdkAppsAppSecretReleasesReleaseHashPublicDistributionGroupsGetResponseItem(
    BaseModel
):
    id: UUID = Field(..., description='The id of the distribution group')


class Field1PublicSdkAppsAppSecretReleasesReleaseHashPublicDistributionGroupsGetResponse(
    RootModel[
        List[
            Field1PublicSdkAppsAppSecretReleasesReleaseHashPublicDistributionGroupsGetResponseItem
        ]
    ]
):
    root: List[
        Field1PublicSdkAppsAppSecretReleasesReleaseHashPublicDistributionGroupsGetResponseItem
    ]


class Field1PublicSdkAppsAppSecretReleasesReleaseHashPublicDistributionGroupsGetResponseModel(
    BaseModel
):
    code: Code8Model22
    message: str


class Field1PublicSparkleAppsAppSecretGetResponse(BaseModel):
    code: Code8Model22
    message: str


class Field1SdkAppsAppSecretReleasesPrivateLatestGetResponse(BaseModel):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: str = Field(..., description="The app's display name.")
    app_icon_url: str = Field(..., description="A URL to the app's icon.")
    app_name: str = Field(
        ..., description="The app's name (extracted from the uploaded release)."
    )
    app_os: Optional[str] = Field(None, description="The app's OS.")
    build: Optional[Build] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    can_resign: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value determines if a release can be re-signed. When true, after a re-sign, the tester will be able to install the release from his registered devices. Will not be returned for non-iOS platforms.',
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned.<br>\n<b>tester</b>: The release distributed testers details will be returned.<br>\n',
    )
    destinations: Optional[List[Destination8Model5]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    device_family: Optional[str] = Field(
        None, description="The release's device family."
    )
    distribution_groups: Optional[List[DistributionGroup4Model2]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore5Model4]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    install_url: Optional[str] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    is_provisioning_profile_syncing: Optional[bool] = Field(
        None,
        description="A flag that determines whether the release's provisioning profile is still extracted or not.",
    )
    is_udid_provisioned: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value will hold the provisioning status of that UDID in this release. Will be ignored for non-iOS platforms.',
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    origin: Optional[Origin48Model14] = Field(None, description="The release's origin")
    package_hashes: Optional[List[str]] = Field(
        None, description='Hashes for the packages.'
    )
    provisioning_profile_expiry_date: Optional[str] = Field(
        None, description='expiration date of provisioning profile in UTC format.'
    )
    provisioning_profile_name: Optional[str] = Field(
        None, description="The release's provisioning profile name."
    )
    provisioning_profile_type: Optional[ProvisioningProfileType] = Field(
        None,
        description='The type of the provisioning profile for the requested app version.',
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    secondary_download_url: Optional[str] = Field(
        None,
        description='The URL that hosts the secondary binary for this release, such as the apk file for aab releases.',
    )
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[int] = Field(None, description="The release's size in bytes.")
    status: Optional[str] = Field(None, description='Status of the release.')
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1SdkAppsAppSecretReleasesPrivateLatestGetResponseModel(BaseModel):
    code: Code8Model22
    message: str


class Field1SdkAppsAppSecretReleasesReleaseHashGetResponse(BaseModel):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: str = Field(..., description="The app's display name.")
    app_icon_url: str = Field(..., description="A URL to the app's icon.")
    app_name: str = Field(
        ..., description="The app's name (extracted from the uploaded release)."
    )
    app_os: Optional[str] = Field(None, description="The app's OS.")
    build: Optional[Build] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    can_resign: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value determines if a release can be re-signed. When true, after a re-sign, the tester will be able to install the release from his registered devices. Will not be returned for non-iOS platforms.',
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned.<br>\n<b>tester</b>: The release distributed testers details will be returned.<br>\n',
    )
    destinations: Optional[List[Destination8Model5]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    device_family: Optional[str] = Field(
        None, description="The release's device family."
    )
    distribution_groups: Optional[List[DistributionGroup4Model2]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore5Model4]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    install_url: Optional[str] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    is_provisioning_profile_syncing: Optional[bool] = Field(
        None,
        description="A flag that determines whether the release's provisioning profile is still extracted or not.",
    )
    is_udid_provisioned: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value will hold the provisioning status of that UDID in this release. Will be ignored for non-iOS platforms.',
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    origin: Optional[Origin48Model14] = Field(None, description="The release's origin")
    package_hashes: Optional[List[str]] = Field(
        None, description='Hashes for the packages.'
    )
    provisioning_profile_expiry_date: Optional[str] = Field(
        None, description='expiration date of provisioning profile in UTC format.'
    )
    provisioning_profile_name: Optional[str] = Field(
        None, description="The release's provisioning profile name."
    )
    provisioning_profile_type: Optional[ProvisioningProfileType] = Field(
        None,
        description='The type of the provisioning profile for the requested app version.',
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    secondary_download_url: Optional[str] = Field(
        None,
        description='The URL that hosts the secondary binary for this release, such as the apk file for aab releases.',
    )
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[int] = Field(None, description="The release's size in bytes.")
    status: Optional[str] = Field(None, description='Status of the release.')
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Field1SdkAppsAppSecretReleasesReleaseHashGetResponseModel(BaseModel):
    code: Code8Model22
    message: str


class Origin48Model15(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class Permission15Model3(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'
    tester = 'tester'


class Field1UserGetResponse(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin48Model15 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission15Model3]] = Field(
        None, description='The permissions the user has for the app'
    )


class Field1UserGetResponseModel(BaseModel):
    error: Error8Model25


class Field1UserPatchRequest(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )


class Field1UserPatchResponse(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin48Model15 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission15Model3]] = Field(
        None, description='The permissions the user has for the app'
    )


class Field1UserPatchResponseModel(BaseModel):
    error: Error8Model25


class Field1UserDevicesGetResponseItem(BaseModel):
    device_name: str = Field(
        ..., description='The device description, in the format "iPhone 7 Plus (A1784)"'
    )
    full_device_name: Optional[str] = Field(
        None, description='A combination of the device model name and the owner name.'
    )
    imei: Optional[str] = Field(
        None,
        description="The device's International Mobile Equipment Identity number. Always empty or undefined at present.",
    )
    model: str = Field(
        ..., description='The model identifier of the device, in the format iDeviceM,N'
    )
    os_build: str = Field(
        ..., description='The last known OS version running on the device'
    )
    os_version: str = Field(
        ..., description='The last known OS version running on the device'
    )
    owner_id: Optional[str] = Field(
        None, description='The user ID of the device owner.'
    )
    registered_at: Optional[str] = Field(
        None, description='Timestamp of when the device was registered in ISO format.'
    )
    serial: Optional[str] = Field(
        None,
        description="The device's serial number. Always empty or undefined at present.",
    )
    status: str = Field(..., description='The provisioning status of the device.')
    udid: str = Field(..., description='The Unique Device IDentifier of the device')


class Field1UserDevicesGetResponse(RootModel[List[Field1UserDevicesGetResponseItem]]):
    root: List[Field1UserDevicesGetResponseItem]


class Field1UserDevicesGetResponseModel(BaseModel):
    code: Code8Model22
    message: str


class Field1UserDevicesDeviceUdidDeleteResponse(BaseModel):
    code: Code8Model22
    message: str


class Field1UserDevicesDeviceUdidGetResponse(BaseModel):
    device_name: str = Field(
        ..., description='The device description, in the format "iPhone 7 Plus (A1784)"'
    )
    full_device_name: Optional[str] = Field(
        None, description='A combination of the device model name and the owner name.'
    )
    imei: Optional[str] = Field(
        None,
        description="The device's International Mobile Equipment Identity number. Always empty or undefined at present.",
    )
    model: str = Field(
        ..., description='The model identifier of the device, in the format iDeviceM,N'
    )
    os_build: str = Field(
        ..., description='The last known OS version running on the device'
    )
    os_version: str = Field(
        ..., description='The last known OS version running on the device'
    )
    owner_id: Optional[str] = Field(
        None, description='The user ID of the device owner.'
    )
    registered_at: Optional[str] = Field(
        None, description='Timestamp of when the device was registered in ISO format.'
    )
    serial: Optional[str] = Field(
        None,
        description="The device's serial number. Always empty or undefined at present.",
    )
    status: str = Field(..., description='The provisioning status of the device.')
    udid: str = Field(..., description='The Unique Device IDentifier of the device')


class Field1UserDevicesDeviceUdidGetResponseModel(BaseModel):
    code: Code8Model22
    message: str


class Field1UserDsrDeletePostResponse(BaseModel):
    createdAt: datetime_aliased = Field(
        ..., description='ISO 8601 format timestamp of when request was created.'
    )
    token: UUID = Field(..., description='Unique request identifier')


class Field1UserDsrDeletePostResponseModel(BaseModel):
    error: Error8Model25


class Status33Model3(Enum):
    None_ = 'None'
    Created = 'Created'
    Queued = 'Queued'
    InProgress = 'InProgress'
    Completed = 'Completed'
    Failed = 'Failed'


class Field1UserDsrDeleteTokenGetResponse(BaseModel):
    message: str = Field(..., description='explanation message of the status')
    sasUrl: Optional[str] = Field(
        None,
        description='Azure Storage shared access signature (SAS) URL for exported user data.',
    )
    sasUrlExpired: Optional[bool] = Field(
        None,
        description='Whether Azure Storage shared access signature (SAS) URL has expired or not.',
    )
    status: Status33Model3 = Field(
        ..., description='Status of data subject right request'
    )


class Field1UserDsrDeleteTokenGetResponseModel(BaseModel):
    error: Error8Model25


class Field1UserDsrDeleteTokenCancelPostRequest(BaseModel):
    email: str = Field(
        ..., description='Email used for cancel delete with x-authz-bypass headers'
    )


class Field1UserDsrDeleteTokenCancelPostResponse(BaseModel):
    createdAt: datetime_aliased = Field(
        ..., description='ISO 8601 format timestamp of when request was created.'
    )
    token: UUID = Field(..., description='Unique request identifier')


class Field1UserDsrDeleteTokenCancelPostResponseModel(BaseModel):
    error: Error8Model25


class Field1UserDsrExportPostResponse(BaseModel):
    createdAt: datetime_aliased = Field(
        ..., description='ISO 8601 format timestamp of when request was created.'
    )
    token: UUID = Field(..., description='Unique request identifier')


class Field1UserDsrExportPostResponseModel(BaseModel):
    error: Error8Model25


class Field1UserDsrExportTokenGetResponse(BaseModel):
    message: str = Field(..., description='explanation message of the status')
    sasUrl: Optional[str] = Field(
        None,
        description='Azure Storage shared access signature (SAS) URL for exported user data.',
    )
    sasUrlExpired: Optional[bool] = Field(
        None,
        description='Whether Azure Storage shared access signature (SAS) URL has expired or not.',
    )
    status: Status33Model3 = Field(
        ..., description='Status of data subject right request'
    )


class Field1UserDsrExportTokenGetResponseModel(BaseModel):
    error: Error8Model25


class Field1UserDsrExportTokenCancelPostResponse(BaseModel):
    createdAt: datetime_aliased = Field(
        ..., description='ISO 8601 format timestamp of when request was created.'
    )
    token: UUID = Field(..., description='Unique request identifier')


class Field1UserDsrExportTokenCancelPostResponseModel(BaseModel):
    error: Error8Model25


class CredentialType(Enum):
    credentials = 'credentials'
    certificate = 'certificate'
    key = 'key'


class ServiceType(Enum):
    apple = 'apple'
    jira = 'jira'
    googleplay = 'googleplay'
    gitlab = 'gitlab'


class Field1UserExportServiceConnectionsGetResponseItem(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )


class Field1UserExportServiceConnectionsGetResponse(
    RootModel[List[Field1UserExportServiceConnectionsGetResponseItem]]
):
    root: List[Field1UserExportServiceConnectionsGetResponseItem]


class Field1UserExportServiceConnectionsGetResponseModel(BaseModel):
    code: Code8Model22
    message: str


class Field1UserInvitationsAppsInvitationTokenAcceptPostRequest(BaseModel):
    pass


class Field1UserInvitationsAppsInvitationTokenAcceptPostResponse(BaseModel):
    error: Error8Model25


class Field1UserInvitationsAppsInvitationTokenRejectPostRequest(BaseModel):
    pass


class Field1UserInvitationsAppsInvitationTokenRejectPostResponse(BaseModel):
    error: Error8Model25


class Field1UserInvitationsDistributionGroupsAcceptPostRequest(BaseModel):
    pass


class Field1UserInvitationsDistributionGroupsAcceptPostResponse(BaseModel):
    error: Error8Model25


class Field1UserInvitationsOrgsInvitationTokenAcceptPostRequest(BaseModel):
    pass


class Field1UserInvitationsOrgsInvitationTokenAcceptPostResponse(BaseModel):
    error: Error8Model25


class Field1UserInvitationsOrgsInvitationTokenRejectPostRequest(BaseModel):
    pass


class Field1UserInvitationsOrgsInvitationTokenRejectPostResponse(BaseModel):
    error: Error8Model25


class Field1UserMetadataOptimizelyGetResponse(BaseModel):
    metadata: Optional[Dict[str, Any]] = None
    userId: Optional[str] = None


class Code8Model23(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'


class Field1UserMetadataOptimizelyGetResponseModel(BaseModel):
    error: Error8Model25


class EventType7Model2(Enum):
    crash_newCrashGroupCreated = 'crash_newCrashGroupCreated'


class Value8Model4(Enum):
    Disabled = 'Disabled'
    Individual = 'Individual'
    Daily = 'Daily'
    DailyAndIndividual = 'DailyAndIndividual'
    Default = 'Default'


class Field1UserNotificationsEmailSettingsGetResponse(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    eTag: Optional[str] = Field(None, description='The ETag of the entity')
    enabled: bool = Field(
        ..., description='Allows to forcefully disable emails on app or user level'
    )
    settings: List[Setting] = Field(
        ..., description='The settings the user has for the app'
    )
    userId: Optional[str] = Field(None, description='The unique id (UUID) of the user')


class Code8Model24(Enum):
    integer_400 = 400
    integer_404 = 404
    integer_409 = 409
    integer_500 = 500


class Field1UserNotificationsEmailSettingsGetResponseModel(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    code: Code8Model24 = Field(
        ...,
        description='The status code return by the API. It can be 400 or 404 or 409 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed'
    )


class Field1UsersUserIdDevicesRegisterPostRequest(BaseModel):
    imei: Optional[str] = Field(
        None,
        description="The device's International Mobile Equipment Identity number. Always empty or undefined at present.",
    )
    model: str = Field(
        ..., description='The model identifier of the device, in the format iDeviceM,N'
    )
    os_build: Optional[str] = Field(
        None,
        description='The build number of the last known OS version running on the device',
    )
    os_version: Optional[str] = Field(
        None, description='The last known OS version running on the device'
    )
    owner_id: Optional[str] = Field(
        None, description='The user ID of the device owner.'
    )
    serial: Optional[str] = Field(
        None,
        description="The device's serial number. Always empty or undefined at present.",
    )
    udid: str = Field(..., description='The Unique Device IDentifier of the device')


class Field1UsersUserIdDevicesRegisterPostResponse(BaseModel):
    device_name: str = Field(
        ..., description='The device description, in the format "iPhone 7 Plus (A1784)"'
    )
    full_device_name: Optional[str] = Field(
        None, description='A combination of the device model name and the owner name.'
    )
    imei: Optional[str] = Field(
        None,
        description="The device's International Mobile Equipment Identity number. Always empty or undefined at present.",
    )
    model: str = Field(
        ..., description='The model identifier of the device, in the format iDeviceM,N'
    )
    os_build: str = Field(
        ..., description='The last known OS version running on the device'
    )
    os_version: str = Field(
        ..., description='The last known OS version running on the device'
    )
    owner_id: Optional[str] = Field(
        None, description='The user ID of the device owner.'
    )
    registered_at: Optional[str] = Field(
        None, description='Timestamp of when the device was registered in ISO format.'
    )
    serial: Optional[str] = Field(
        None,
        description="The device's serial number. Always empty or undefined at present.",
    )
    status: str = Field(..., description='The provisioning status of the device.')
    udid: str = Field(..., description='The Unique Device IDentifier of the device')


class Code8Model25(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Field1UsersUserIdDevicesRegisterPostResponseModel(BaseModel):
    code: Code8Model25
    message: str


class Field1AppsOwnerNameAppNameCrashGroupsCrashGroupIdCrashesGetResponseModel(
    RootModel[List[Crash_1]]
):
    root: List[Crash_1]
