# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T15:41:50+00:00

from __future__ import annotations

from datetime import datetime as datetime_aliased
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import AnyUrl, BaseModel, Field, PositiveInt, RootModel, conint, constr


class AADGroup(BaseModel):
    aad_group_id: UUID = Field(..., description='The id of the aad group')
    display_name: str = Field(..., description='The display name of the aad group')
    tenant_id: UUID = Field(..., description='The id of the aad tenant')


class AADTenantAddRequest(BaseModel):
    aad_tenant_id: UUID = Field(..., description='The AAD tenant id')
    display_name: str = Field(..., description='The name of the AAD Tenant')
    user_id: UUID = Field(
        ...,
        description='The user wanting to add this tenant to the organization, must be an admin of the organization',
    )


class AADTenantResponse(BaseModel):
    aad_tenant_id: UUID = Field(..., description='The AAD tenant id')
    display_name: str = Field(..., description='The name of the AAD Tenant')


class AADUser(BaseModel):
    object_id: UUID = Field(..., description="the aad user's id")
    tenant_id: UUID = Field(..., description="the aad user's tenant id")


class AccessKey(BaseModel):
    createdBy: Optional[str] = Field(None, description='Account name of creator.')
    createdTime: Optional[float] = Field(None, description='Created time of access key')
    description: Optional[str] = Field(None, description='Description of access key')
    expires: Optional[float] = Field(None, description='Time of expiry of access key')
    friendlyName: Optional[str] = Field(None, description='Friendly name of access key')
    id: Optional[str] = Field(None, description='Id of accessKey')
    isSession: Optional[bool] = Field(
        None,
        description='Legacy property which indicate if accessKey was created from session',
    )
    name: Optional[str] = Field(None, description='Key of access key')


class AccessKeyListResponse(BaseModel):
    accessKeys: Optional[List[AccessKey]] = Field(
        None, description='Array containing the list of existing AccessKeys'
    )


class Origin(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class Type(Enum):
    user = 'user'
    org = 'org'


class AccountResponse(BaseModel):
    display_name: str = Field(..., description='The display name of the account')
    email: Optional[str] = Field(
        None, description="The account's email. For org that value might be empty."
    )
    id: UUID = Field(..., description='The internal unique id (UUID) of the account.')
    name: str = Field(..., description='The slug name of the account')
    origin: Origin = Field(..., description='The creation origin of this account')
    type: Type = Field(..., description='The type of this account')


class AcquisitionStatusSuccessResponse(BaseModel):
    code: str = Field(..., description='The code indicating the status')
    message: str = Field(..., description='The message indicating the status')


class AppsWithCrash(BaseModel):
    appId: Optional[str] = Field(None, description='application identifier')
    appVersion: Optional[str] = Field(None, description='application version')
    crashGroupId: Optional[str] = Field(None, description='crash group identifier')


class ActiveCrashingAppDetails(BaseModel):
    appsWithCrashes: Optional[List[AppsWithCrash]] = Field(
        None, description='details of the apps with crashes'
    )
    nextLink: Optional[str] = None


class DailyItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class MonthlyItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class WeeklyItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class ActiveDeviceCounts(BaseModel):
    daily: Optional[List[DailyItem]] = Field(
        None, description='The active device count for each interval.'
    )
    monthly: Optional[List[MonthlyItem]] = Field(
        None,
        description="The active device count for each interval with a month's retention.",
    )
    weekly: Optional[List[WeeklyItem]] = Field(
        None,
        description="The active device count for each interval with a week's retention.",
    )


class AddAADGroupResponse(BaseModel):
    id: Optional[UUID] = Field(
        None, description='The unique ID (UUID) of the aad group'
    )


class AddAppTesterRequest(BaseModel):
    release_id: int = Field(
        ..., description='The ID of the release the user was added to'
    )
    user_id: UUID = Field(
        ..., description='The user ID of the tester that needs to be added'
    )


class AddAppTesterResponse(BaseModel):
    release_id: int = Field(
        ..., description='The ID of the release the user was added to'
    )
    user_id: UUID = Field(
        ..., description='The user ID of the tester that needs to be added'
    )


class AddOrganizationAdminRequest(BaseModel):
    assigning_reason: str = Field(
        ..., description='The explanation for adding new org admin.'
    )
    issue_id: str = Field(..., description='The id of the related Intercom issue.')
    new_org_admin_id: UUID = Field(
        ..., description='The internal unique id (UUID) of the account.'
    )
    responsible_admin_id: UUID = Field(
        ..., description='The id of the user who started adding new org admin.'
    )


class Role(Enum):
    admin = 'admin'
    collaborator = 'collaborator'
    member = 'member'


class AddUserAsRoleRequest(BaseModel):
    role: Optional[Role] = Field(None, description='The role of the user to be added')


class Organizations(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin = Field(..., description='The creation origin of this organization')
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class AdministeredOrgsResponse(BaseModel):
    organizations: Organizations


class AgentQueueResponse(BaseModel):
    id: Optional[int] = None
    name: Optional[str] = None


class AgentQueuesResponseItem(BaseModel):
    id: Optional[int] = None
    name: Optional[str] = None


class AgentQueuesResponse(RootModel[List[AgentQueuesResponseItem]]):
    root: List[AgentQueuesResponseItem] = Field(
        ..., description='A list of agent queues'
    )


class AzureSubscriptionState(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'
    NotSet = 'NotSet'


class PaymentSource(Enum):
    None_ = 'None'
    AppCenter = 'AppCenter'
    GitHub = 'GitHub'
    Xtc = 'Xtc'


class Service(Enum):
    Build = 'Build'
    Test = 'Test'


class Plan(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class ByAccount(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan] = Field(None, description='Billing Plan')


class CurrentBillingPeriod(BaseModel):
    byAccount: Optional[ByAccount] = Field(
        None, description='Selection of a billing plan'
    )
    endTime: Optional[str] = Field(None, description='Exclusive end of the period.')
    startTime: Optional[str] = Field(None, description='Inclusive start of the period')


class BuildService(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class Plan1(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class ByAccount1(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan1] = Field(None, description='Billing Plan')


class CurrentBillingPeriod1(BaseModel):
    byAccount: Optional[ByAccount1] = Field(
        None, description='Selection of a billing plan'
    )
    endTime: Optional[str] = Field(None, description='Exclusive end of the period.')
    startTime: Optional[str] = Field(None, description='Inclusive start of the period')


class TestService(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod1] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class BillingPlans(BaseModel):
    buildService: Optional[BuildService] = Field(
        None, description='Billing Plans for a single service'
    )
    testService: Optional[TestService] = Field(
        None, description='Billing Plans for a single service'
    )


class CurrentUsagePeriod(BaseModel):
    byAccount: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    byApp: Optional[Dict[str, Dict[str, float]]] = Field(
        None, description='A collection of  named numeric values grouped by app'
    )
    endTime: Optional[str] = Field(
        None, description='Exclusive end time of the usage period.'
    )
    startTime: Optional[str] = Field(
        None, description='Inclusive start time of the usage period'
    )


class BuildService1(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class TestService1(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class Usage(BaseModel):
    buildService: Optional[BuildService1] = Field(
        None, description='Resource usage for a single Mobile Center service'
    )
    testService: Optional[TestService1] = Field(
        None, description='Resource usage for a single Mobile Center service'
    )


class AggregatedBillingInformation(BaseModel):
    azureSubscriptionId: Optional[str] = Field(
        None,
        description='Unique identifier for the Azure subscription used for billing',
    )
    azureSubscriptionState: Optional[AzureSubscriptionState] = Field(
        None, description='State of the Azure subscription used for billing'
    )
    billingPlans: Optional[BillingPlans] = Field(
        None, description='Billing Plans section in the Billing Information'
    )
    id: Optional[str] = Field(None, description='ID of the user or organization')
    timestamp: Optional[str] = Field(
        None, description='The ISO 8601 datetime of last modification'
    )
    usage: Optional[Usage] = Field(
        None, description='Usage section in the Billing Information'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Information schema'
    )


class Owner(BaseModel):
    id: Optional[str] = None
    login: Optional[str] = None
    name: Optional[str] = None


class AlertBugTrackerRepo(BaseModel):
    description: Optional[str] = None
    id: str
    name: str
    owner: Optional[Owner] = Field(None, description='Repository owner object')
    private: Optional[bool] = None
    url: str


class AlertBugTrackerRepoOwner(BaseModel):
    id: Optional[str] = None
    login: Optional[str] = None
    name: Optional[str] = None


class RepoType(Enum):
    github = 'github'
    vsts = 'vsts'
    jira = 'jira'


class Repository(BaseModel):
    description: Optional[str] = None
    id: str
    name: str
    owner: Optional[Owner] = Field(None, description='Repository owner object')
    private: Optional[bool] = None
    url: str


class AlertBugTrackerReposResult(BaseModel):
    repo_type: Optional[RepoType] = None
    repositories: List[Repository]


class State(Enum):
    Open = 'Open'
    Closed = 'Closed'
    Ignored = 'Ignored'


class AlertCrashGroupStateChange(BaseModel):
    state: Optional[State] = None


class DefaultValue(Enum):
    Disabled = 'Disabled'
    Individual = 'Individual'
    Daily = 'Daily'
    DailyAndIndividual = 'DailyAndIndividual'


class EventType(Enum):
    crash_newCrashGroupCreated = 'crash_newCrashGroupCreated'


class Value(Enum):
    Disabled = 'Disabled'
    Individual = 'Individual'
    Daily = 'Daily'
    DailyAndIndividual = 'DailyAndIndividual'
    Default = 'Default'


class Setting(BaseModel):
    default_value: Optional[DefaultValue] = Field(
        None, description='Default frequency of event'
    )
    event_type: EventType = Field(..., description='Event Name')
    value: Value = Field(..., description='Frequency of event')


class AlertEmailSettings(BaseModel):
    settings: List[Setting] = Field(
        ..., description='The settings the user has for the app'
    )


class AlertOperationResult(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')


class Setting1(BaseModel):
    default_value: Optional[DefaultValue] = Field(
        None, description='Default frequency of event'
    )
    event_type: EventType = Field(..., description='Event Name')
    value: Value = Field(..., description='Frequency of event')


class AlertUserAppEmailSettingsResult(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    eTag: Optional[str] = Field(None, description='The ETag of the entity')
    enabled: bool = Field(
        ..., description='Allows to forcefully disable emails on app or user level'
    )
    settings: List[Setting1] = Field(
        ..., description='The settings the user has for the app'
    )
    userId: Optional[str] = Field(None, description='The unique id (UUID) of the user')
    appId: Optional[str] = Field(None, description='Application ID')
    user_enabled: bool = Field(
        ...,
        description='A flag indicating if settings are enabled at user/global level',
    )


class Setting2(BaseModel):
    default_value: Optional[DefaultValue] = Field(
        None, description='Default frequency of event'
    )
    event_type: EventType = Field(..., description='Event Name')
    value: Value = Field(..., description='Frequency of event')


class AlertUserEmailSettingsResult(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    eTag: Optional[str] = Field(None, description='The ETag of the entity')
    enabled: bool = Field(
        ..., description='Allows to forcefully disable emails on app or user level'
    )
    settings: List[Setting2] = Field(
        ..., description='The settings the user has for the app'
    )
    userId: Optional[str] = Field(None, description='The unique id (UUID) of the user')


class EventType3(Enum):
    newCrashGroupCreated = 'newCrashGroupCreated'
    newAppReleased = 'newAppReleased'


class AlertWebhook(BaseModel):
    enabled: Optional[bool] = Field(None, description='Allows eanble/disable webhook')
    event_types: List[EventType3] = Field(
        ..., description='Event types enabled for webhook'
    )
    id: Optional[str] = Field(None, description='The unique id (UUID) of the webhook')
    name: constr(max_length=512) = Field(..., description='display name of the webhook')
    url: str = Field(..., description='target url of the webhook')


class Value3(BaseModel):
    enabled: Optional[bool] = Field(None, description='Allows eanble/disable webhook')
    event_types: List[EventType3] = Field(
        ..., description='Event types enabled for webhook'
    )
    id: Optional[str] = Field(None, description='The unique id (UUID) of the webhook')
    name: constr(max_length=512) = Field(..., description='display name of the webhook')
    url: str = Field(..., description='target url of the webhook')


class AlertWebhookListResult(BaseModel):
    values: List[Value3]


class AlertWebhookPingResult(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    response_reason: Optional[str] = Field(
        None, description='Reason returned in response from calling webhook'
    )
    response_status_code: int = Field(
        ..., description='HTTP status code returned in response from calling webhook'
    )


class ExternalProviderName(Enum):
    github = 'github'
    vsts = 'vsts'
    jira = 'jira'


class AlertingAccessTokenResponse(BaseModel):
    access_token_id: str = Field(..., description='ID of the access token')
    external_account_name: str = Field(
        ...,
        description='The account name of external user that used to authenticate against the external oauth provider or basic auth',
    )
    external_provider_name: ExternalProviderName = Field(
        ..., description='External provider name'
    )
    external_user_email: str = Field(
        ...,
        description='The email of external user that used to authenticate aginst the external oauth provider',
    )


class Type1(Enum):
    github = 'github'
    vsts = 'vsts'
    jira = 'jira'


class Settings(BaseModel):
    callback_url: Optional[str] = None
    owner_name: str
    type: Type1 = Field(..., description='type of bugtracker')


class State1(Enum):
    enabled = 'enabled'
    disabled = 'disabled'
    unauthorized = 'unauthorized'


class AlertingBugtracker(BaseModel):
    event_types: Optional[List[EventType3]] = Field(
        None, description='Event types enabled for bugtracker'
    )
    settings: Optional[Settings] = Field(
        None, description='Bugtracker specific settings', discriminator='type'
    )
    state: Optional[State1] = Field(None, description='bugtracker state')
    token_id: Optional[str] = Field(None, description='ID of OAuth token')
    type: Optional[Type1] = Field(None, description='type of bugtracker')


class AlertingBugtrackerSettings(BaseModel):
    callback_url: Optional[str] = None
    owner_name: str
    type: Type1 = Field(..., description='type of bugtracker')


class AppPlatform(Enum):
    ios = 'ios'
    android = 'android'
    xamarin = 'xamarin'
    react_native = 'react-native'
    ndk = 'ndk'
    unity = 'unity'
    other = 'other'


class AlertingCrashGroup(BaseModel):
    app_display_name: Optional[str] = None
    app_platform: Optional[AppPlatform] = Field(
        None, description='SDK/Platform this thread is beeing generated from'
    )
    app_version: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    reason: Optional[str] = None
    stack_trace: Optional[List[str]] = None
    url: Optional[str] = None


class Code(Enum):
    integer_400 = 400
    integer_404 = 404
    integer_409 = 409
    integer_500 = 500


class AlertingError(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')
    code: Code = Field(
        ...,
        description='The status code return by the API. It can be 400 or 404 or 409 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed'
    )


class AlertingEvent(BaseModel):
    event_id: str = Field(
        ...,
        description='A unique identifier for this event instance. Useful for deduplication',
    )
    event_timestamp: str = Field(
        ..., description='ISO 8601 date time when event was generated'
    )
    properties: Optional[Dict[str, Any]] = Field(
        None, description='Obsolete. Use emailProperties.'
    )


class AlertingEventTypes(Enum):
    newCrashGroupCreated = 'newCrashGroupCreated'
    newAppReleased = 'newAppReleased'


class AlertingGithubBugtrackerSettings(BaseModel):
    callback_url: Optional[str] = None
    owner_name: str
    type: Type1 = Field(..., description='type of bugtracker')
    github_label: Optional[str] = None
    github_repo_id: int
    github_repo_name: str


class AlertingJiraBugtrackerSettings(BaseModel):
    callback_url: Optional[str] = None
    owner_name: str
    type: Type1 = Field(..., description='type of bugtracker')
    jira_project_id: int
    jira_project_name: str


class AlertingVstsBugtrackerSettings(BaseModel):
    callback_url: Optional[str] = None
    owner_name: str
    type: Type1 = Field(..., description='type of bugtracker')
    vsts_account_name: Optional[str] = None
    vsts_area_path: Optional[str] = None
    vsts_default_payload: Optional[Dict[str, Any]] = None
    vsts_project_id: str
    vsts_project_name: Optional[str] = None
    vsts_project_uri: str


class Plan2(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class ByAccount2(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan2] = Field(None, description='Billing Plan')


class CurrentBillingPeriod2(BaseModel):
    byAccount: Optional[ByAccount2] = Field(
        None, description='Selection of a billing plan'
    )
    endTime: Optional[str] = Field(None, description='Exclusive end of the period.')
    startTime: Optional[str] = Field(None, description='Inclusive start of the period')


class BuildService2(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod2] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class Plan3(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class ByAccount3(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan3] = Field(None, description='Billing Plan')


class CurrentBillingPeriod3(BaseModel):
    byAccount: Optional[ByAccount3] = Field(
        None, description='Selection of a billing plan'
    )
    endTime: Optional[str] = Field(None, description='Exclusive end of the period.')
    startTime: Optional[str] = Field(None, description='Inclusive start of the period')


class TestService2(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod3] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class BillingPlans1(BaseModel):
    buildService: Optional[BuildService2] = Field(
        None, description='Billing Plans for a single service'
    )
    testService: Optional[TestService2] = Field(
        None, description='Billing Plans for a single service'
    )


class BuildService3(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class TestService3(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class Usage1(BaseModel):
    buildService: Optional[BuildService3] = Field(
        None, description='Resource usage for a single Mobile Center service'
    )
    testService: Optional[TestService3] = Field(
        None, description='Resource usage for a single Mobile Center service'
    )


class AggregatedBillings(BaseModel):
    azureSubscriptionId: Optional[str] = Field(
        None,
        description='Unique identifier for the Azure subscription used for billing',
    )
    azureSubscriptionState: Optional[AzureSubscriptionState] = Field(
        None, description='State of the Azure subscription used for billing'
    )
    billingPlans: Optional[BillingPlans1] = Field(
        None, description='Billing Plans section in the Billing Information'
    )
    id: Optional[str] = Field(None, description='ID of the user or organization')
    timestamp: Optional[str] = Field(
        None, description='The ISO 8601 datetime of last modification'
    )
    usage: Optional[Usage1] = Field(
        None, description='Usage section in the Billing Information'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Information schema'
    )


class AllAccountsAggregatedBillingInformation(BaseModel):
    aggregatedBillings: Optional[AggregatedBillings] = Field(
        None, description='Aggregated Billing Information for a user or an organization'
    )


class AllItunesAppsResponse(BaseModel):
    apple_id: Optional[str] = Field(None, description='apple id for app team id.')
    bundle_id: Optional[str] = Field(None, description='bundle identifier of app')
    iconUrl: Optional[str] = Field(
        None, description='url for the app icon from app store'
    )
    name: Optional[str] = Field(None, description='App Name')


class Model(BaseModel):
    count: Optional[int] = Field(None, description='Count current of model.')
    model_name: Optional[str] = Field(None, description="Model's name.")
    previous_count: Optional[int] = Field(None, description='Count of previous model.')


class AnalyticsModels(BaseModel):
    models: Optional[List[Model]] = None
    total: Optional[int] = None


class AnalyticsReleasesParameter(BaseModel):
    distribution_group_id: str = Field(..., description='distribution group id')
    release_id: int = Field(..., description='release id')
    user_id: UUID = Field(..., description='user id')


class Release(BaseModel):
    distribution_group_id: str = Field(..., description='distribution group id')
    release_id: int = Field(..., description='release id')
    user_id: UUID = Field(..., description='user id')


class AnalyticsReleasesResponse(BaseModel):
    releases: Optional[List[Release]] = None


class AndroidBranchConfigurationProperties(BaseModel):
    automaticSigning: Optional[bool] = Field(
        None, description='Whether to apply automatic signing or not'
    )
    buildVariant: Optional[str] = Field(
        None, description='The Android build variant to build', examples=['release']
    )
    gradleWrapperPath: Optional[str] = Field(
        None,
        description='Path to the Gradle wrapper script',
        examples=['android/gradlew'],
    )
    isRoot: Optional[bool] = Field(
        None, description='Whether it is the root module or not'
    )
    keyAlias: Optional[str] = Field(None, description='The key alias')
    keyPassword: Optional[str] = Field(None, description='The key password')
    keystoreEncoded: Optional[str] = Field(
        None, description='The keystore encoded value'
    )
    keystoreFilename: Optional[str] = Field(
        None, description='The name of the keystore file'
    )
    keystorePassword: Optional[str] = Field(
        None, description='The password of the keystore'
    )
    module: Optional[str] = Field(
        None, description='The Gradle module to build', examples=['app']
    )
    runLint: Optional[bool] = Field(
        None, description='Whether to run lint checks during the build (default)'
    )
    runTests: Optional[bool] = Field(
        True, description='Whether to run unit tests during the build (default)'
    )


class SigningConfig(BaseModel):
    hasStoreFile: Optional[bool] = Field(
        None,
        description='Indicates if storeFile is specified in the signing configuration',
    )


class BuildConfiguration(BaseModel):
    name: str = Field(
        ..., description='Name of build configuration (the same as a build type name)'
    )
    signingConfig: Optional[SigningConfig] = Field(
        None, description='Android signing config. Null if not specified'
    )


class AndroidModule(BaseModel):
    buildConfigurations: Optional[List[BuildConfiguration]] = Field(
        None, description='The detected build configurations of the Android module'
    )
    buildTypes: Optional[List[str]] = Field(
        None, description='The detected build types of the Android module'
    )
    buildVariants: Optional[List[str]] = Field(
        None,
        description='The detected build variants of the Android module (matrix of product flavor + build type (debug|release))',
    )
    hasBundle: Optional[bool] = Field(
        None, description='Module contains bundle settings'
    )
    isRoot: Optional[bool] = Field(
        None, description='Whether the module is at the root level of the project'
    )
    name: str = Field(..., description='Name of the Android module')
    productFlavors: Optional[List[str]] = Field(
        None, description='The product flavors of the Android module'
    )


class BuildConfiguration1(BaseModel):
    name: str = Field(
        ..., description='Name of build configuration (the same as a build type name)'
    )
    signingConfig: Optional[SigningConfig] = Field(
        None, description='Android signing config. Null if not specified'
    )


class AndroidModule1(BaseModel):
    buildConfigurations: Optional[List[BuildConfiguration1]] = Field(
        None, description='The detected build configurations of the Android module'
    )
    buildTypes: Optional[List[str]] = Field(
        None, description='The detected build types of the Android module'
    )
    buildVariants: Optional[List[str]] = Field(
        None,
        description='The detected build variants of the Android module (matrix of product flavor + build type (debug|release))',
    )
    hasBundle: Optional[bool] = Field(
        None, description='Module contains bundle settings'
    )
    isRoot: Optional[bool] = Field(
        None, description='Whether the module is at the root level of the project'
    )
    name: str = Field(..., description='Name of the Android module')
    productFlavors: Optional[List[str]] = Field(
        None, description='The product flavors of the Android module'
    )


class AndroidProject(BaseModel):
    androidModules: List[AndroidModule1] = Field(
        ..., description='Android Gradle modules'
    )
    gradleWrapperPath: Optional[str] = Field(
        None, description='The path of the Gradle wrapper'
    )


class ClaimType(Enum):
    user_email = 'user_email'
    user_origin = 'user_origin'
    app_owner_name = 'app_owner_name'
    app_name = 'app_name'
    app_origin = 'app_origin'
    app_os = 'app_os'
    app_platform = 'app_platform'
    app_secret = 'app_secret'


class ApiTokenClaim(BaseModel):
    claim_type: Optional[ClaimType] = None
    claim_value: Optional[str] = None


class ApiTokenDeleteResponse(BaseModel):
    id: UUID = Field(..., description='The unique id (UUID) of the api token')
    token_hash: str = Field(..., description='The hashed value of api token')


class TokenScopeEnum(Enum):
    all = 'all'
    in_app_update = 'in_app_update'
    viewer = 'viewer'


class UserOrigin(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class ApiTokenGetUserResponse(BaseModel):
    token_id: UUID = Field(..., description="The token's unique id (UUID)")
    token_scope: List[TokenScopeEnum] = Field(
        ..., description="The token's scope. A list of allowed roles."
    )
    user_email: str = Field(..., description='The user email')
    user_id: UUID = Field(..., description='The unique id (UUID) of the user')
    user_origin: UserOrigin = Field(
        ..., description='The creation origin of the user who created this api token'
    )


class ScopeEnum(Enum):
    all = 'all'
    in_app_update = 'in_app_update'
    viewer = 'viewer'


class ApiTokenResponse(BaseModel):
    created_at: str = Field(..., description='The creation time')
    description: Optional[str] = Field(None, description='The description of the token')
    encrypted_token: Optional[str] = Field(
        None,
        description='The encrypted value of a token. This value will only be returned for token of type in_app_update.',
    )
    id: UUID = Field(..., description='The unique id (UUID) of the api token')
    scope: Optional[List[ScopeEnum]] = Field(
        None, description="The token's scope. A list of allowed roles."
    )


class ApiTokenResponsev2(BaseModel):
    created_at: str = Field(..., description='The creation time')
    description: Optional[str] = Field(None, description='The description of the token')
    encrypted_token: Optional[str] = Field(
        None,
        description='The encrypted value of a token. This value will only be returned for token of type in_app_update.',
    )
    id: UUID = Field(..., description='The unique id (UUID) of the api token')
    scope: Optional[List[ScopeEnum]] = Field(
        None, description="The token's scope. A list of allowed roles."
    )


class ScopeEnum2(Enum):
    all = 'all'
    viewer = 'viewer'


class ApiTokensCreateRequest(BaseModel):
    description: Optional[str] = Field(None, description='The description of the token')
    scope: Optional[List[ScopeEnum2]] = Field(
        None, description='The scope for this token.'
    )


class ApiTokensCreateResponse(BaseModel):
    api_token: str = Field(
        ..., description='The api token generated will not be accessible again'
    )
    created_at: str = Field(..., description='The creation time')
    description: Optional[str] = Field(None, description='The description of the token')
    id: str = Field(..., description='The unique id (UUID) of the api token')
    scope: Optional[List[ScopeEnum2]] = Field(
        None, description='The scope for this token.'
    )


class ApiTokensGetResponse(BaseModel):
    created_at: str = Field(..., description='The creation time')
    description: Optional[str] = Field(None, description='The description of the token')
    id: str = Field(..., description='The unique id (UUID) of the api token')
    scope: Optional[List[ScopeEnum2]] = Field(
        None, description='The scope for this token.'
    )


class ScopeEnum5(Enum):
    all = 'all'
    in_app_update = 'in_app_update'
    viewer = 'viewer'


class TokenType(Enum):
    public = 'public'
    in_app_update = 'in_app_update'
    build = 'build'
    session = 'session'
    tester_app = 'tester_app'


class ApiTokensPostRequest(BaseModel):
    description: Optional[str] = Field(None, description='The description of the token')
    encrypted_token: Optional[str] = Field(
        None, description='An encrypted value of the token.'
    )
    scope: Optional[List[ScopeEnum5]] = Field(
        None, description='The scope for this token. An array of supported roles.'
    )
    token_hash: Optional[str] = Field(None, description='The hashed value of api token')
    token_type: Optional[TokenType] = Field(
        None,
        description='The token\'s type. public:managed by the user; in_app_update:special token for in-app update scenario; buid:dedicated for CI usage for now; session:for CLI session management; tester_app: used for tester mobile app; default is "public".\'',
    )


class PrincipalType(Enum):
    app = 'app'
    user = 'user'


class ApiTokensPrivateCreateRequest(BaseModel):
    description: Optional[str] = Field(None, description='The description of the token')
    principal_id: UUID = Field(
        ..., description='The principal ID assigned to the API token'
    )
    principal_type: PrincipalType = Field(
        ..., description='The principal type assigned to the API token'
    )
    scope: Optional[List[ScopeEnum5]] = Field(
        None, description='The scope for this token (default "all").'
    )
    token_type: Optional[TokenType] = Field(
        None,
        description='The token\'s type (default "public")\n  public: managed by the user\n  in_app_update: special token for in-app update scenario\n  buid: dedicated for CI usage for now\n  session: for CLI session management\n  tester_app: used for tester mobile app',
    )


class ApiTokensPrivateCreateResponse(BaseModel):
    api_token: str = Field(
        ..., description='The api token generated will not be accessible again'
    )
    created_at: str = Field(..., description='The creation time')
    description: Optional[str] = Field(None, description='The description of the token')
    encrypted_token: Optional[str] = Field(
        None,
        description='The encrypted value of a token. This value will only be returned for token of type in_app_update.',
    )
    id: str = Field(..., description='The unique id (UUID) of the api token')
    scope: Optional[List[ScopeEnum5]] = Field(
        None, description='The scope for this token.'
    )


class AppAddRequest(BaseModel):
    name: str = Field(
        ..., description='The name of the app to be added to the distribution group'
    )


class AppBuildFeature(BaseModel):
    name: Optional[str] = None
    value: Optional[bool] = None


class AppBuildFeatures(RootModel[List[AppBuildFeature]]):
    root: List[AppBuildFeature] = Field(..., description='A list of supported features')


class Features(BaseModel):
    crash_download_raw: Optional[bool] = Field(
        None, description='App supports download of raw crashes'
    )
    crashgroup_analytics_crashfreeusers: Optional[bool] = Field(
        None, description="App supports the 'crash free user' metric"
    )
    crashgroup_analytics_impactedusers: Optional[bool] = Field(
        None, description="App supports the 'impacted users' metric"
    )
    crashgroup_modify_annotation: Optional[bool] = Field(
        None, description='App supports modification of crashgroup annotation'
    )
    crashgroup_modify_status: Optional[bool] = Field(
        None, description='App supports modification of crashgroup status'
    )
    search: Optional[bool] = Field(None, description='App supports search API')


class AppCrashesInfo(BaseModel):
    features: Features
    has_crashes: bool


class AppDeleteRequest(BaseModel):
    name: str = Field(
        ..., description='The name of the app to be deleted from the distribution group'
    )


class AppDistributionGroupUsersRequest(BaseModel):
    member_ids: Optional[List[UUID]] = None


class AppFeatures(BaseModel):
    crash_download_raw: Optional[bool] = Field(
        None, description='App supports download of raw crashes'
    )
    crashgroup_analytics_crashfreeusers: Optional[bool] = Field(
        None, description="App supports the 'crash free user' metric"
    )
    crashgroup_analytics_impactedusers: Optional[bool] = Field(
        None, description="App supports the 'impacted users' metric"
    )
    crashgroup_modify_annotation: Optional[bool] = Field(
        None, description='App supports modification of crashgroup annotation'
    )
    crashgroup_modify_status: Optional[bool] = Field(
        None, description='App supports modification of crashgroup status'
    )
    search: Optional[bool] = Field(None, description='App supports search API')


class Os(Enum):
    Android = 'Android'
    iOS = 'iOS'
    macOS = 'macOS'
    Tizen = 'Tizen'
    tvOS = 'tvOS'
    Windows = 'Windows'
    Linux = 'Linux'
    Custom = 'Custom'


class Platform(Enum):
    Java = 'Java'
    Objective_C_Swift = 'Objective-C-Swift'
    UWP = 'UWP'
    Cordova = 'Cordova'
    React_Native = 'React-Native'
    Unity = 'Unity'
    Electron = 'Electron'
    Xamarin = 'Xamarin'
    WPF = 'WPF'
    WinForms = 'WinForms'
    Unknown = 'Unknown'
    Custom = 'Custom'


class AppGroupResponse(BaseModel):
    display_name: Optional[str] = Field(None, description='The display name of the app')
    group_id: UUID = Field(
        ..., description='The unique ID (UUID) of the group that the app belongs to'
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    platform: Platform = Field(..., description='The platform of the app')
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )


class AppId(BaseModel):
    id: Optional[str] = Field(None, description='the id of the app')


class Type7(Enum):
    org = 'org'
    user = 'user'


class Owner2(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type7 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class AzureSubscription(BaseModel):
    is_billable: Optional[bool] = Field(
        None, description='If the subscription can be used for billing'
    )
    is_billing: Optional[bool] = Field(
        None, description='If the subscription is used for billing'
    )
    is_microsoft_internal: Optional[bool] = Field(
        None, description='If the subscription is internal Microsoft subscription'
    )
    subscription_id: UUID = Field(..., description='The azure subscription id')
    subscription_name: str = Field(
        ..., description='The name of the azure subscription'
    )
    tenant_id: UUID = Field(
        ..., description='The tenant id of the azure subscription belongs to'
    )


class MemberPermission(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'
    tester = 'tester'


class Origin2(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class App(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner2 = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin2 = Field(..., description='The creation origin of this app')
    platform: Platform = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Owner3(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type7 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class DistributionGroup(BaseModel):
    owner: Optional[Owner3] = Field(
        None, description="The information about the app's owner"
    )


class InviteType(Enum):
    developer = 'developer'
    tester = 'tester'


class Permission(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'
    tester = 'tester'


class InvitedBy(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin2 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission]] = Field(
        None, description='The permissions the user has for the app'
    )


class AppInvitationDetailResponse(BaseModel):
    app: App
    app_count: Optional[float] = Field(
        None, description='The number of apps in the group'
    )
    distribution_group: Optional[DistributionGroup] = Field(
        None,
        description='The organization that owns the distribution group, if it exists',
    )
    email: str = Field(..., description='The email address of the invited user')
    id: UUID = Field(..., description='The unique ID (UUID) of the invitation')
    invite_type: InviteType = Field(..., description='The invitation type')
    invited_by: InvitedBy
    is_existing_user: bool = Field(
        ..., description='Indicates whether the invited user already exists'
    )
    permissions: Optional[List[Permission]] = Field(
        None, description='The permissions the user has for the app'
    )


class Origin4(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'
    testcloud = 'testcloud'
    hockeyapp_dogfood = 'hockeyapp-dogfood'


class SourceType(Enum):
    user = 'user'
    org = 'org'
    distribution_group = 'distribution_group'
    team = 'team'
    release = 'release'


class AppMembership(BaseModel):
    app_id: Optional[str] = None
    origin: Optional[Origin4] = None
    permissions: Optional[List[str]] = None
    source_id: Optional[str] = None
    source_type: Optional[SourceType] = None
    user_id: Optional[str] = None


class Membership(BaseModel):
    app_id: Optional[str] = None
    origin: Optional[Origin4] = None
    permissions: Optional[List[str]] = None
    source_id: Optional[str] = None
    source_type: Optional[SourceType] = None
    user_id: Optional[str] = None


class AppMembershipsResponse(BaseModel):
    app_origin: Optional[str] = Field(None, description="The app's origin")
    memberships: Optional[List[Membership]] = Field(
        None,
        description='An array of all ways a user has access to the app, based on the app_memberships table.',
    )


class AppUsersWithMissingMembership(BaseModel):
    app_id: Optional[str] = None
    origin: Optional[str] = None
    permissions: Optional[List[str]] = None
    user_id: Optional[str] = None


class DistributionGroupUsersWithMissingMembership(BaseModel):
    distribution_group_id: Optional[str] = None
    origin: Optional[str] = None
    user_id: Optional[str] = None


class AppUsersMembership(BaseModel):
    app_id: Optional[str] = None
    origin: Optional[Origin4] = None
    permissions: Optional[List[str]] = None
    source_id: Optional[str] = None
    source_type: Optional[SourceType] = None
    user_id: Optional[str] = None


class DistributionGroupMembership(BaseModel):
    app_id: Optional[str] = None
    origin: Optional[Origin4] = None
    permissions: Optional[List[str]] = None
    source_id: Optional[str] = None
    source_type: Optional[SourceType] = None
    user_id: Optional[str] = None


class OrganizationAdminMembership(BaseModel):
    app_id: Optional[str] = None
    origin: Optional[Origin4] = None
    permissions: Optional[List[str]] = None
    source_id: Optional[str] = None
    source_type: Optional[SourceType] = None
    user_id: Optional[str] = None


class ExcessAppMemberships(BaseModel):
    app_users_memberships: Optional[List[AppUsersMembership]] = None
    distribution_group_memberships: Optional[List[DistributionGroupMembership]] = None
    organization_admin_memberships: Optional[List[OrganizationAdminMembership]] = None


class OrganizationAdminsWithMissingMembership(BaseModel):
    organization_id: Optional[str] = None
    origin: Optional[str] = None
    role: Optional[str] = None
    user_id: Optional[str] = None


class AppMembershipsValidationResponse(BaseModel):
    app_users_with_missing_memberships: Optional[
        List[AppUsersWithMissingMembership]
    ] = None
    distribution_group_users_with_missing_memberships: Optional[
        List[DistributionGroupUsersWithMissingMembership]
    ] = None
    excess_app_memberships: Optional[ExcessAppMemberships] = None
    organization_admins_with_missing_memberships: Optional[
        List[OrganizationAdminsWithMissingMembership]
    ] = None


class AppName(BaseModel):
    name: str


class AppPatchRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='A short text describing the app'
    )
    display_name: Optional[str] = Field(None, description='The display name of the app')
    icon_asset_id: Optional[UUID] = Field(
        None, description="The uuid for the icon's asset id from ACFUS"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    name: Optional[str] = Field(None, description='The name of the app used in URLs')
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release type value that starts with a capital letter but is otherwise lowercase',
    )


class AppRepoPatchRequest(BaseModel):
    external_user_id: Optional[str] = Field(
        None, description='The external user id from the provider'
    )
    repo_url: Optional[str] = Field(
        None, description='The absolute URL of the repository'
    )
    service_connection_id: Optional[UUID] = Field(
        None,
        description='The id of the service connection stored in customer credential store',
    )
    user_id: Optional[UUID] = Field(
        None, description='The unique id (UUID) of the user'
    )


class RepoProvider(Enum):
    github = 'github'
    bitbucket = 'bitbucket'
    vsts = 'vsts'
    gitlab = 'gitlab'


class AppRepoPostRequest(BaseModel):
    external_user_id: Optional[str] = Field(
        None, description='The external user id from the provider'
    )
    installation_id: Optional[str] = Field(
        None, description='Installation id from the provider'
    )
    repo_id: Optional[str] = Field(None, description='Repository id from the provider')
    repo_provider: Optional[RepoProvider] = Field(
        None, description='The provider of the repository'
    )
    repo_url: str = Field(..., description='The absolute URL of the repository')
    service_connection_id: Optional[UUID] = Field(
        None,
        description='The id of the service connection stored in customer credential store',
    )
    user_id: UUID = Field(
        ...,
        description='The unique id (UUID) of the user who configured the repository',
    )


class AppRepoResponse(BaseModel):
    app_id: UUID = Field(
        ...,
        description='The unique id (UUID) of the app that this repository integration belongs to',
    )
    external_user_id: Optional[str] = Field(
        None, description='User id from the provider'
    )
    id: UUID = Field(
        ..., description='The unique id (UUID) of the repository integration'
    )
    installation_id: Optional[str] = Field(
        None, description='Installation id from the provider'
    )
    repo_id: Optional[str] = Field(None, description='Repository id from the provider')
    repo_provider: Optional[RepoProvider] = Field(
        None, description='The provider of the repository'
    )
    repo_url: str = Field(..., description='The absolute URL of the repository')
    service_connection_id: Optional[UUID] = Field(
        None,
        description='The id of the service connection stored in customer credential store',
    )
    user_id: UUID = Field(
        ...,
        description='The unique id (UUID) of the user who configured the repository',
    )


class Platform2(Enum):
    Java = 'Java'
    Objective_C_Swift = 'Objective-C-Swift'
    UWP = 'UWP'
    Cordova = 'Cordova'
    React_Native = 'React-Native'
    Xamarin = 'Xamarin'
    Unity = 'Unity'
    Electron = 'Electron'
    WPF = 'WPF'
    WinForms = 'WinForms'
    Custom = 'Custom'


class AppRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='A short text describing the app'
    )
    display_name: str = Field(
        ...,
        description='The descriptive name of the app. This can contain any characters',
    )
    name: Optional[str] = Field(None, description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    platform: Platform2 = Field(..., description='The platform of the app')
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )


class Owner4(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type7 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class Origin9(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class Platform3(Enum):
    Java = 'Java'
    Objective_C_Swift = 'Objective-C-Swift'
    UWP = 'UWP'
    Cordova = 'Cordova'
    React_Native = 'React-Native'
    Unity = 'Unity'
    Electron = 'Electron'
    Xamarin = 'Xamarin'
    WPF = 'WPF'
    WinForms = 'WinForms'
    Unknown = 'Unknown'
    Custom = 'Custom'


class AppResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner4 = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin9 = Field(..., description='The creation origin of this app')
    platform: Platform3 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Owner5(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type7 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class Repository1(BaseModel):
    repo_provider: Optional[str] = None
    repo_url: Optional[str] = None


class UserPermissions(BaseModel):
    permissions: Optional[List[Permission]] = None
    user_id: Optional[UUID] = None


class AppResponseInternal(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner5 = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin9 = Field(..., description='The creation origin of this app')
    platform: Platform3 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )
    cutover_from_hockeyapp_at: Optional[str] = Field(
        None, description='The cutover date of this app'
    )
    feature_flags: Optional[List[str]] = Field(
        None, description='The feature flags that are enabled for this app'
    )
    repositories: Optional[List[Repository1]] = Field(
        None, description='The repositories associated with this app'
    )
    user_permissions: Optional[UserPermissions] = Field(
        None, description='the permissions for the specified app user'
    )


class AppOrigin(Enum):
    appcenter = 'appcenter'
    codepush = 'codepush'


class AppUserPermissionResponse(BaseModel):
    app_id: UUID = Field(..., description='The unique id (UUID) of the app')
    app_origin: AppOrigin = Field(..., description='The creation origin of this app')
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    permissions: List[Permission] = Field(
        ..., description='The permissions the user has for the app'
    )
    user_email: str = Field(..., description='The email of the user')
    user_id: UUID = Field(..., description='The unique id (UUID) of the user')


class AppVersion(BaseModel):
    app_id: str
    app_version: str
    app_version_id: str
    build_number: Optional[str] = None
    display_name: str


class Owner6(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type7 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class TeamPermission(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'


class AppWithTeamPermissionsResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner6 = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin9 = Field(..., description='The creation origin of this app')
    platform: Platform3 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )
    team_permissions: Optional[List[TeamPermission]] = Field(
        None, description='The permissions the team has for the app'
    )


class AppleCertificateDetails(BaseModel):
    base64Certificate: str = Field(
        ..., description='The certificate contents in base 64 encoded string'
    )
    password: str = Field(..., description='The password for the certificate')


class AppleCertificateNonSecretDetails(BaseModel):
    certificateValidityEndDate: str = Field(
        ..., description='The date-time till which the certificate is valid'
    )
    certificateValidityStartDate: str = Field(
        ..., description='The date-time from which the certificate is valid'
    )
    displayName: str = Field(
        ..., description='The display name (CN) of the certificate'
    )


class CredentialType(Enum):
    credentials = 'credentials'
    certificate = 'certificate'
    key = 'key'


class ServiceType(Enum):
    apple = 'apple'
    jira = 'jira'
    googleplay = 'googleplay'
    gitlab = 'gitlab'


class Data(BaseModel):
    certificateValidityEndDate: str = Field(
        ..., description='The date-time till which the certificate is valid'
    )
    certificateValidityStartDate: str = Field(
        ..., description='The date-time from which the certificate is valid'
    )
    displayName: str = Field(
        ..., description='The display name (CN) of the certificate'
    )


class AppleCertificateNonSecretDetailsResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )
    data: Data = Field(..., description='apple certificate non-secret details')


class AppleCertificateSecretDetails(BaseModel):
    base64Certificate: str = Field(
        ..., description='The certificate contents in base 64 encoded string'
    )
    certificateValidityEndDate: str = Field(
        ..., description='The date-time till which the certificate is valid'
    )
    certificateValidityStartDate: str = Field(
        ..., description='The date-time from which the certificate is valid'
    )
    displayName: str = Field(
        ..., description='The display name (CN) of the certificate'
    )
    password: str = Field(..., description='The password for the certificate')


class Data1(BaseModel):
    base64Certificate: str = Field(
        ..., description='The certificate contents in base 64 encoded string'
    )
    certificateValidityEndDate: str = Field(
        ..., description='The date-time till which the certificate is valid'
    )
    certificateValidityStartDate: str = Field(
        ..., description='The date-time from which the certificate is valid'
    )
    displayName: str = Field(
        ..., description='The display name (CN) of the certificate'
    )
    password: str = Field(..., description='The password for the certificate')


class AppleCertificateSecretDetailsResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )
    data: Data1 = Field(..., description='apple certificate secret details.')


class Data2(BaseModel):
    base64Certificate: str = Field(
        ..., description='The certificate contents in base 64 encoded string'
    )
    password: str = Field(..., description='The password for the certificate')


class AppleCertificateSecretRequest(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        'credentials',
        description='credential type of the shared connection. Values can be credentials|certificate',
    )
    data: Optional[Data2] = Field(None, description='shared connection details')
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )


class AppleConnectionNonSecretResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )


class Data3(BaseModel):
    password: Optional[str] = Field(
        None, description='password to connect to shared connection.'
    )
    username: Optional[str] = Field(
        None, description='username to connect to shared connection.'
    )


class AppleConnectionSecretRequest(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        'credentials',
        description='credential type of the shared connection. Values can be credentials|certificate',
    )
    data: Optional[Data3] = Field(None, description='shared connection details')
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )


class Data4(BaseModel):
    username: str = Field(..., description='username to connect to apple store')


class AppleConnectionSecretResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )
    data: Data4 = Field(..., description='apple secret details')


class AppleCredentialNonSecretDetailsResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )
    data: Data4 = Field(..., description='Apple credentials non-secret data')


class Data6(BaseModel):
    appSpecificPassword: Optional[str] = Field(
        None,
        description='The app specific password required for app publishing for 2FA accounts',
    )
    authCode: str = Field(
        ..., description='The 6 digit Apple OTP for Multifactor accounts'
    )
    password: str = Field(..., description='password to connect to apple store.')
    username: str = Field(..., description='username to connect to apple store.')


class AppleCredentialsMultifactorSecretRequest(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        'credentials',
        description='credential type of the shared connection. Values can be credentials|certificate',
    )
    data: Optional[Data6] = Field(None, description='shared connection details')
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )


class Data7(BaseModel):
    authCode: Optional[constr(min_length=6, max_length=6)] = Field(
        None, description='6 digit auth code'
    )
    password: Optional[str] = Field(
        None, description='password to connect to apple store.'
    )
    username: Optional[str] = Field(
        None, description='username to connect to apple store.'
    )


class AppleCredentialsSecretRequest(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        'credentials',
        description='credential type of the shared connection. Values can be credentials|certificate',
    )
    data: Optional[Data7] = Field(None, description='shared connection details')
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )


class AppleLoginRequest(BaseModel):
    cookie: Optional[str] = Field(
        None,
        description='The 30-day session cookie for multi-factor authentication backed accounts.',
    )
    password: str = Field(
        ..., description='The password for the Apple Developer account.'
    )
    team_identifier: Optional[str] = Field(
        None, description='Identifier of the team to use when logged in.'
    )
    username: str = Field(
        ..., description='The username for the Apple Developer account.'
    )


class AppleLoginResponse(BaseModel):
    successful: Optional[bool] = Field(
        None, description='True when login was successful.'
    )


class AppleMappingRequest(BaseModel):
    apple_id: Optional[str] = Field(
        None,
        description='ID of the apple application in apple store, takes precedence over bundle_identifier when both are provided',
    )
    bundle_identifier: Optional[str] = Field(
        None, description='Bundle Identifier of the apple package'
    )
    service_connection_id: str = Field(
        ...,
        description='Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.',
    )
    team_identifier: str = Field(
        ..., description='ID of the Team associated with the app in apple store'
    )


class AppleMappingResponse(BaseModel):
    app_id: Optional[str] = Field(
        None, description='ID of the apple application in Mobile Center'
    )
    apple_id: Optional[str] = Field(
        None, description='ID of the apple application in apple store'
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.',
    )
    team_identifier: Optional[str] = Field(
        None, description='ID of the Team associated with the app in apple store'
    )


class AppleMultifactorLoginResponse(BaseModel):
    cookie: Optional[str] = Field(
        None,
        description='The 30-day session Token generated by apple after successfully logging in with Multifactor authentication.',
    )
    expires: Optional[str] = Field(
        None, description='The expiry date of the cookie generated by apple'
    )
    username: Optional[str] = Field(None, description='the apple developer account.')


class AppleMultifactorSecretDetails(BaseModel):
    appSpecificPassword: Optional[str] = Field(
        None,
        description='The app specific password required for app publishing for 2FA accounts',
    )
    authCode: str = Field(
        ..., description='The 6 digit Apple OTP for Multifactor accounts'
    )
    password: str = Field(..., description='password to connect to apple store.')
    username: str = Field(..., description='username to connect to apple store.')


class AppleMutifactorLoginRequest(BaseModel):
    authcode: str = Field(
        ...,
        description='This is the six digit OTP used for completing the multi-factor authentication',
    )
    username: str = Field(
        ..., description='The username for the Apple Developer account.'
    )


class AppleSecretDetails(BaseModel):
    authCode: Optional[constr(min_length=6, max_length=6)] = Field(
        None, description='6 digit auth code'
    )
    password: Optional[str] = Field(
        None, description='password to connect to apple store.'
    )
    username: Optional[str] = Field(
        None, description='username to connect to apple store.'
    )


class AppleSecretDetailsResponse(BaseModel):
    username: str = Field(..., description='username to connect to apple store')


class AppleTestFlightGroupRequest(BaseModel):
    apple_id: Optional[str] = Field(
        None,
        description='apple_id of the app for which test flight groups need to be fetched.',
    )
    bundle_identifier: Optional[str] = Field(
        None,
        description='apple_id of the app for which test flight groups need to be fetched.',
    )
    cookie: Optional[str] = Field(
        None,
        description='The 30-day session cookie for multi-factor authentication backed accounts.',
    )
    password: Optional[str] = Field(
        None, description='The password for the Apple Developer account.'
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='The service_connection_id of the stored Apple credentials instead of username, password.',
    )
    team_identifier: Optional[str] = Field(
        None, description='Identifier of the team to use when logged in.'
    )
    username: Optional[str] = Field(
        None, description='The username for the Apple Developer account.'
    )


class AppleTestFlightGroupResponse(BaseModel):
    active: Optional[bool] = Field(
        None, description='true if group is in active state.'
    )
    appAdamId: Optional[float] = Field(None, description='apple id of the group.')
    id: Optional[str] = Field(None, description='id of the group.')
    isInternalGroup: Optional[bool] = Field(
        None, description='true if the group is an internal group.'
    )
    name: Optional[str] = Field(None, description='name of the group.')
    providerId: Optional[float] = Field(None, description='provider id of the group.')


class AppleTestFlightGroupsResponse(BaseModel):
    appleId: Optional[float] = Field(None, description='apple id of the group.')
    id: Optional[str] = Field(None, description='id of the group.')
    name: Optional[str] = Field(None, description='name of the group.')
    providerId: Optional[float] = Field(None, description='provider id of the group.')


class ApplicationStatusRequest(BaseModel):
    build_version: Optional[str] = Field(
        None,
        description='The version of build for which real time status is to be fetched.',
    )
    bundle_identifier: str = Field(
        ..., description='Bundle Identifier of application in Apple Itunes portal.'
    )
    password: str = Field(
        ..., description='The password for the Apple Developer account.'
    )
    team_identifier: Optional[str] = Field(
        None, description='Identifier of the team to use when logged in.'
    )
    track_identifier: str = Field(
        ..., description='Track Identifier for which the status is to be fetched.'
    )
    train_version: Optional[str] = Field(
        None, description='The Train version for which the status is to be fetched.'
    )
    username: str = Field(
        ..., description='The username for the Apple Developer account.'
    )


class ApplicationStatusResponse(BaseModel):
    version: Optional[str] = Field(None, description='The version of the application')
    version_type: str = Field(
        ...,
        description='The type of version being returned (production/edit/test flight).',
    )


class ArchIdentifier(BaseModel):
    architecture: str = Field(
        ...,
        description='The architecture that the UUID belongs to, i.e. armv7 or arm64.',
    )
    uuid: UUID = Field(..., description='The unique identifier.')


class AttributesValues(RootModel[Optional[Dict[str, Dict[str, Any]]]]):
    root: Optional[Dict[str, Dict[str, Any]]] = None


class State2(Enum):
    Calculating = 'Calculating'
    Ready = 'Ready'
    Disabled = 'Disabled'


class CustomProperties(Enum):
    string = 'string'
    number = 'number'
    boolean = 'boolean'
    date_time = 'date_time'


class Audience(BaseModel):
    definition: Optional[str] = Field(
        None, description='Audience definition in OData format.'
    )
    description: Optional[str] = Field(None, description='Audience description.')
    estimated_count: Optional[int] = Field(None, description='Estimated audience size.')
    name: Optional[str] = Field(None, description='Audience name.')
    state: Optional[State2] = Field(None, description='Audience state.')
    custom_properties: Optional[Dict[str, CustomProperties]] = Field(
        None, description='Custom properties used in the definition.'
    )
    enabled: Optional[bool] = True
    estimated_total_count: Optional[int] = Field(
        None, description='Estimated total audience size.'
    )
    timestamp: Optional[datetime_aliased] = Field(
        None, description='Date the audience was last refreshed.'
    )


class AudienceBlobResult(BaseModel):
    url: Optional[str] = Field(None, description='Location of the audience blob.')


class AudienceDefinition(BaseModel):
    custom_properties: Optional[Dict[str, CustomProperties]] = Field(
        None, description='Custom properties used in the definition.'
    )
    definition: constr(max_length=2000) = Field(
        ..., description='Audience definition in OData format.'
    )
    description: Optional[constr(max_length=128)] = Field(
        None, description='Audience description.'
    )
    enabled: Optional[bool] = True


class Values(Enum):
    string = 'string'
    number = 'number'
    boolean = 'boolean'
    date_time = 'date_time'


class AudienceDevicePropertiesListResult(BaseModel):
    values: Dict[str, Values] = Field(..., description='List of device properties.')


class AudienceDevicePropertyValuesListResult(BaseModel):
    values: List[str] = Field(..., description='List of device property values.')


class Value4(BaseModel):
    definition: Optional[str] = Field(
        None, description='Audience definition in OData format.'
    )
    description: Optional[str] = Field(None, description='Audience description.')
    estimated_count: Optional[int] = Field(None, description='Estimated audience size.')
    name: Optional[str] = Field(None, description='Audience name.')
    state: Optional[State2] = Field(None, description='Audience state.')


class AudienceListResult(BaseModel):
    nextLink: Optional[str] = None
    values: List[Value4] = Field(..., description='List of audiences.')


class QueryType(Enum):
    broadcast = 'broadcast'
    user_ids = 'user_ids'
    account_ids = 'account_ids'
    install_ids = 'install_ids'


class AudienceQueryDefinition(BaseModel):
    identifiers: Optional[List[str]] = Field(None, description='List of identifiers.')
    queryType: QueryType = Field(..., description='Audience Query Type')


class AudienceSummary(BaseModel):
    definition: Optional[str] = Field(
        None, description='Audience definition in OData format.'
    )
    description: Optional[str] = Field(None, description='Audience description.')
    estimated_count: Optional[int] = Field(None, description='Estimated audience size.')
    name: Optional[str] = Field(None, description='Audience name.')
    state: Optional[State2] = Field(None, description='Audience state.')


class AudienceTestResult(BaseModel):
    custom_properties: Optional[Dict[str, CustomProperties]] = Field(
        None, description='Custom properties used in the definition.'
    )
    definition: Optional[str] = Field(
        None, description='Audience definition in OData format.'
    )
    estimated_count: Optional[int] = Field(None, description='Estimated audience size.')
    estimated_total_count: Optional[int] = Field(
        None, description='Estimated total audience size.'
    )


class AutoProvisioningConfigRequest(BaseModel):
    allow_auto_provisioning: Optional[bool] = Field(
        None, description='When *true* enables auto provisioning'
    )
    apple_developer_account_key: Optional[str] = Field(
        None,
        description="A key to a secret in customer-credential-store. apple_developer_account refers to the user's developer account that is used to log into https://developer.apple.com. Normally the user's email.",
    )
    apple_distribution_certificate_key: Optional[str] = Field(
        None,
        description="A key to a secret in customer-credential-store. distribution_certificate refers to the customer's certificate (that holds the private key) that will be used to sign the app.",
    )


class AutoProvisioningConfigResponse(BaseModel):
    allow_auto_provisioning: Optional[bool] = Field(
        None, description='When *true* enables auto provisioning'
    )
    app_id: Optional[str] = Field(None, description='The identifier of the App.')
    apple_developer_account_key: Optional[str] = Field(
        None,
        description="A key to a secret in customer-credential-store. apple_developer_account refers to the user's developer account that is used to log into https://developer.apple.com. Normally the user's email.",
    )
    apple_distribution_certificate_key: Optional[str] = Field(
        None,
        description="A key to a secret in customer-credential-store. distribution_certificate refers to the cusomer's certificate (that holds the private key) that will be used to sign the app.",
    )
    destination_id: Optional[str] = Field(
        None, description='The identifier of the destination.'
    )
    id: Optional[float] = Field(None, description='The identifier of the config.')


class AvailabilityOfDevicesRequest(BaseModel):
    password: Optional[str] = Field(
        None, description='The password for the Apple Developer account.'
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='The service_connection_id of the stored Apple credentials instad of username, password.',
    )
    username: Optional[str] = Field(
        None, description='The username for the Apple Developer account.'
    )


class Ipads(BaseModel):
    available: float
    maximum: float
    registered: float


class Iphones(BaseModel):
    available: float
    maximum: float
    registered: float


class Ipods(BaseModel):
    available: float
    maximum: float
    registered: float


class Watches(BaseModel):
    available: float
    maximum: float
    registered: float


class AvailabilityOfDevicesResponse(BaseModel):
    ipads: Ipads = Field(..., description='...')
    iphones: Iphones = Field(..., description='...')
    ipods: Ipods = Field(..., description='...')
    watches: Watches = Field(..., description='...')


class AvailableAppBuilds(BaseModel):
    app_builds: Optional[List[str]] = Field(
        None, description='List of available app builds.'
    )


class AvailableVersions(BaseModel):
    total_count: Optional[int] = Field(
        None, description='The full number of versions across all pages.'
    )
    versions: Optional[List[str]] = Field(
        None, description='List of available versions.'
    )


class AvailableVersionsDiagnostics(BaseModel):
    total_count: Optional[int] = Field(
        None, description='The full number of versions across all pages.'
    )
    versions: Optional[List[str]] = Field(
        None, description='List of available versions.'
    )


class AzureSubscriptionAddRequest(BaseModel):
    is_billing: Optional[bool] = Field(
        None, description='If the subscription is used for billing'
    )
    subscription_id: UUID = Field(..., description='The azure subscription id')
    subscription_name: str = Field(
        ..., description='The name of the azure subscription'
    )
    tenant_id: UUID = Field(
        ..., description='The tenant id of the azure subscription belongs to'
    )


class AzureSubscriptionAddToAppRequest(BaseModel):
    subscription_id: UUID = Field(..., description='The azure subscription id')


class AzureSubscriptionPatchRequest(BaseModel):
    is_billing: bool = Field(..., description='If the subscription is used for billing')


class AzureSubscriptionResponse(BaseModel):
    is_billable: Optional[bool] = Field(
        None, description='If the subscription can be used for billing'
    )
    is_billing: Optional[bool] = Field(
        None, description='If the subscription is used for billing'
    )
    is_microsoft_internal: Optional[bool] = Field(
        None, description='If the subscription is internal Microsoft subscription'
    )
    subscription_id: UUID = Field(..., description='The azure subscription id')
    subscription_name: str = Field(
        ..., description='The name of the azure subscription'
    )
    tenant_id: UUID = Field(
        ..., description='The tenant id of the azure subscription belongs to'
    )


class AzureSubscriptionUpdateBillableRequest(BaseModel):
    is_billable: bool = Field(..., description='Billable status of the subscription')


class Owner7(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type7 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class BasicAppResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner7 = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )


class Build(BaseModel):
    branch_name: Optional[str] = Field(
        None, description='The branch name of the build producing the release'
    )
    commit_hash: Optional[str] = Field(
        None, description='The commit hash of the build producing the release'
    )
    commit_message: Optional[str] = Field(
        None, description='The commit message of the build producing the release'
    )


class DestinationType(Enum):
    group = 'group'
    store = 'store'
    tester = 'tester'


class Type13(Enum):
    intune = 'intune'
    googleplay = 'googleplay'
    apple = 'apple'
    none = 'none'


class Destination(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution group.',
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type13] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )
    destination_type: Optional[DestinationType] = Field(
        None, description='Destination can be either store or group.'
    )
    display_name: Optional[str] = Field(
        None, description='Display name for the group or tester'
    )


class DistributionGroup1(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution group.',
    )


class DistributionStore(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution store.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type13] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution store.',
    )


class Origin12(Enum):
    hockeyapp = 'hockeyapp'
    appcenter = 'appcenter'


class BasicReleaseDetailsResponse(BaseModel):
    build: Optional[Build] = Field(
        None, description='Build information for the release\n'
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>\n',
    )
    destinations: Optional[List[Destination]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    distribution_groups: Optional[List[DistributionGroup1]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    file_extension: Optional[str] = Field(
        None, description='The file extension of the main (user-uploaded) package file.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    origin: Optional[Origin12] = Field(None, description="The release's origin")
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Code1(Enum):
    integer_400 = 400
    integer_403 = 403
    integer_500 = 500


class Error(BaseModel):
    code: Optional[Code1] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed'
    )


class BillingError(BaseModel):
    error: Optional[Error] = None


class Plan4(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class ByAccount4(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan4] = Field(None, description='Billing Plan')


class CurrentBillingPeriod4(BaseModel):
    byAccount: Optional[ByAccount4] = Field(
        None, description='Selection of a billing plan'
    )
    endTime: Optional[str] = Field(None, description='Exclusive end of the period.')
    startTime: Optional[str] = Field(None, description='Inclusive start of the period')


class BuildService4(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod4] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class Plan5(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class ByAccount5(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan5] = Field(None, description='Billing Plan')


class CurrentBillingPeriod5(BaseModel):
    byAccount: Optional[ByAccount5] = Field(
        None, description='Selection of a billing plan'
    )
    endTime: Optional[str] = Field(None, description='Exclusive end of the period.')
    startTime: Optional[str] = Field(None, description='Inclusive start of the period')


class TestService4(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod5] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class BillingInformationPlans(BaseModel):
    buildService: Optional[BuildService4] = Field(
        None, description='Billing Plans for a single service'
    )
    testService: Optional[TestService4] = Field(
        None, description='Billing Plans for a single service'
    )


class BillingInformationSearchResult(BaseModel):
    accountId: Optional[str] = Field(None, description='The Account ID')
    accountName: Optional[str] = Field(None, description='The Account Name')
    billingInternalAccountId: Optional[str] = Field(
        None, description='The Billing Internal Account ID'
    )
    buildPlan: Optional[str] = Field(
        None, description='The ID of the Build Billing Plan'
    )
    testPlan: Optional[str] = Field(None, description='The ID of the Test Billing Plan')


class BillingInformationSearchResults(RootModel[List[BillingInformationSearchResult]]):
    root: List[BillingInformationSearchResult] = Field(
        ..., description='The results of a Billing Information search'
    )


class Plan6(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class ByAccount6(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan6] = Field(None, description='Billing Plan')


class BillingPeriod(BaseModel):
    byAccount: Optional[ByAccount6] = Field(
        None, description='Selection of a billing plan'
    )
    endTime: Optional[str] = Field(None, description='Exclusive end of the period.')
    startTime: Optional[str] = Field(None, description='Inclusive start of the period')


class BillingPlan(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class Plan7(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class BillingPlanSelection(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan7] = Field(None, description='Billing Plan')


class Result(Enum):
    NoChange = 'NoChange'
    Downgrade = 'Downgrade'
    Upgrade = 'Upgrade'


class BillingPlansChangeTypeResponse(BaseModel):
    result: Optional[Result] = None


class Plan8(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class BuildService5(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan8] = Field(None, description='Billing Plan')


class Plan9(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class TestService5(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan9] = Field(None, description='Billing Plan')


class BillingPlansSelection(BaseModel):
    buildService: Optional[BuildService5] = Field(
        None, description='Selection of a billing plan'
    )
    testService: Optional[TestService5] = Field(
        None, description='Selection of a billing plan'
    )


class BuildService6(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class TestService6(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class BillingResourceUsage(BaseModel):
    buildService: Optional[BuildService6] = Field(
        None, description='Resource usage for a single Mobile Center service'
    )
    testService: Optional[TestService6] = Field(
        None, description='Resource usage for a single Mobile Center service'
    )


class BlobInfo(BaseModel):
    size: float
    url: str


class BooleanProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: bool = Field(..., description='Boolean property value.')


class BooleanPropertyDiagnostics(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: bool = Field(..., description='Boolean property value.')


class Commit(BaseModel):
    sha: Optional[str] = Field(None, description='The commit SHA')
    url: Optional[str] = Field(None, description='The URL to the commit')


class Branch(BaseModel):
    commit: Commit
    name: str = Field(..., description='The branch name')


class BuildNumberFormat(Enum):
    buildId = 'buildId'
    timestamp = 'timestamp'


class ArtifactVersioning(BaseModel):
    buildNumberFormat: Optional[BuildNumberFormat] = None


class Android(BaseModel):
    automaticSigning: Optional[bool] = Field(
        None, description='Whether to apply automatic signing or not'
    )
    buildVariant: Optional[str] = Field(
        None, description='The Android build variant to build', examples=['release']
    )
    gradleWrapperPath: Optional[str] = Field(
        None,
        description='Path to the Gradle wrapper script',
        examples=['android/gradlew'],
    )
    isRoot: Optional[bool] = Field(
        None, description='Whether it is the root module or not'
    )
    keyAlias: Optional[str] = Field(None, description='The key alias')
    keyPassword: Optional[str] = Field(None, description='The key password')
    keystoreEncoded: Optional[str] = Field(
        None, description='The keystore encoded value'
    )
    keystoreFilename: Optional[str] = Field(
        None, description='The name of the keystore file'
    )
    keystorePassword: Optional[str] = Field(
        None, description='The password of the keystore'
    )
    module: Optional[str] = Field(
        None, description='The Gradle module to build', examples=['app']
    )
    runLint: Optional[bool] = Field(
        None, description='Whether to run lint checks during the build (default)'
    )
    runTests: Optional[bool] = Field(
        True, description='Whether to run unit tests during the build (default)'
    )


class Javascript(BaseModel):
    packageJsonPath: Optional[str] = Field(
        None,
        description='Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"',
    )
    reactNativeVersion: Optional[str] = Field(
        None, description='Version of React Native from package.json files'
    )
    runTests: Optional[bool] = Field(
        None,
        description='Whether to run Jest unit tests, via npm test, during the build',
    )


class Xamarin(BaseModel):
    args: Optional[str] = None
    configuration: Optional[str] = None
    isSimBuild: Optional[bool] = None
    monoVersion: Optional[str] = None
    p12File: Optional[str] = None
    p12Pwd: Optional[str] = None
    provProfile: Optional[str] = None
    sdkBundle: Optional[str] = None
    slnPath: Optional[str] = None
    symlink: Optional[str] = Field(
        None,
        description='Symlink of the SDK Bundle and Mono installation.\nThe build will use the associated Mono bundled with related Xamarin SDK. If both symlink and monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink is passed, the current stable Mono version will be configured for building.\n',
    )


class AppExtensionProvisioningProfileFile(BaseModel):
    fileId: Optional[str] = Field(None, description='File id from secure file storage')
    fileName: Optional[str] = Field(
        None, description='Name of uploaded provisioning profile'
    )
    targetBundleIdentifier: Optional[str] = Field(
        None, description='Target the provisioning profile is used to sign'
    )
    uploadId: Optional[str] = Field(
        None, description='Upload id to App Center File Upload Store'
    )


class Xcode(BaseModel):
    appExtensionProvisioningProfileFiles: Optional[
        List[AppExtensionProvisioningProfileFile]
    ] = None
    archiveConfiguration: Optional[str] = Field(
        None, description='The build configuration of the target to archive'
    )
    automaticSigning: Optional[bool] = None
    cartfilePath: Optional[str] = Field(
        None, description='Path to Carthage file, if present'
    )
    certificateEncoded: Optional[str] = None
    certificateFileId: Optional[str] = None
    certificateFilename: Optional[str] = None
    certificatePassword: Optional[str] = None
    certificateUploadId: Optional[str] = None
    forceLegacyBuildSystem: Optional[bool] = Field(
        None,
        description='Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.\nBy default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.\n',
    )
    podfilePath: Optional[str] = Field(
        None, description='Path to CococaPods file, if present'
    )
    projectOrWorkspacePath: Optional[str] = Field(
        None, description='Xcode project/workspace path'
    )
    provisioningProfileEncoded: Optional[str] = None
    provisioningProfileFileId: Optional[str] = None
    provisioningProfileFilename: Optional[str] = None
    provisioningProfileUploadId: Optional[str] = None
    scheme: Optional[str] = None
    targetToArchive: Optional[str] = Field(
        None, description='The target id of the selected scheme to archive'
    )
    teamId: Optional[str] = None
    xcodeProjectSha: Optional[str] = Field(
        None, description='The selected pbxproject hash to the repositroy'
    )
    xcodeVersion: Optional[str] = Field(
        None,
        description='Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default is latest stable version, at the time when the configuration is set.',
    )


class Toolsets(BaseModel):
    android: Optional[Android] = Field(
        None, description='Build configuration for Android projects'
    )
    javascript: Optional[Javascript] = Field(
        None,
        description='Build configuration when React Native, or other JavaScript tech, is part of the build steps',
    )
    xamarin: Optional[Xamarin] = Field(
        None, description='Build configuration for Xamarin projects'
    )
    xcode: Optional[Xcode] = Field(
        None, description='Build configuration when Xcode is part of the build steps'
    )


class Trigger(Enum):
    continous = 'continous'
    continuous = 'continuous'
    manual = 'manual'


class BranchConfiguration(BaseModel):
    artifactVersioning: Optional[ArtifactVersioning] = Field(
        None,
        description='The versioning configuration for artifacts built for this branch',
    )
    badgeIsEnabled: Optional[bool] = None
    cloneFromBranch: Optional[str] = Field(
        None,
        description='A configured branch name to clone from. If provided, all other parameters will be ignored. Only supported in POST requests.',
    )
    signed: Optional[bool] = None
    testsEnabled: Optional[bool] = None
    toolsets: Optional[Toolsets] = Field(
        None, description='The branch build configuration for each toolset'
    )
    trigger: Optional[Trigger] = None


class BranchConfigurationArtifactVersioning(BaseModel):
    buildNumberFormat: Optional[BuildNumberFormat] = None


class ChangedBy(BaseModel):
    displayName: Optional[str] = None
    url: Optional[str] = None


class BranchConfigurationRevision(BaseModel):
    changeType: Optional[str] = None
    changedBy: Optional[ChangedBy] = Field(
        None, description='user who made a change in branch configuration'
    )
    changedDate: Optional[str] = None
    definitionUrl: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    revision: Optional[float] = None


class BranchConfigurationRevisionAuthor(BaseModel):
    displayName: Optional[str] = None
    url: Optional[str] = None


class BranchConfigurationRevision1(BaseModel):
    changeType: Optional[str] = None
    changedBy: Optional[ChangedBy] = Field(
        None, description='user who made a change in branch configuration'
    )
    changedDate: Optional[str] = None
    definitionUrl: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    revision: Optional[float] = None


class BranchConfigurationRevisions(RootModel[List[BranchConfigurationRevision1]]):
    root: List[BranchConfigurationRevision1] = Field(
        ..., description='list of branch configuration revisions'
    )


class Xcode1(BaseModel):
    appExtensionProvisioningProfileFiles: Optional[
        List[AppExtensionProvisioningProfileFile]
    ] = None
    archiveConfiguration: Optional[str] = Field(
        None, description='The build configuration of the target to archive'
    )
    automaticSigning: Optional[bool] = None
    cartfilePath: Optional[str] = Field(
        None, description='Path to Carthage file, if present'
    )
    certificateEncoded: Optional[str] = None
    certificateFileId: Optional[str] = None
    certificateFilename: Optional[str] = None
    certificatePassword: Optional[str] = None
    certificateUploadId: Optional[str] = None
    forceLegacyBuildSystem: Optional[bool] = Field(
        None,
        description='Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.\nBy default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.\n',
    )
    podfilePath: Optional[str] = Field(
        None, description='Path to CococaPods file, if present'
    )
    projectOrWorkspacePath: Optional[str] = Field(
        None, description='Xcode project/workspace path'
    )
    provisioningProfileEncoded: Optional[str] = None
    provisioningProfileFileId: Optional[str] = None
    provisioningProfileFilename: Optional[str] = None
    provisioningProfileUploadId: Optional[str] = None
    scheme: Optional[str] = None
    targetToArchive: Optional[str] = Field(
        None, description='The target id of the selected scheme to archive'
    )
    teamId: Optional[str] = None
    xcodeProjectSha: Optional[str] = Field(
        None, description='The selected pbxproject hash to the repositroy'
    )
    xcodeVersion: Optional[str] = Field(
        None,
        description='Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default is latest stable version, at the time when the configuration is set.',
    )


class BranchConfigurationToolsets(BaseModel):
    android: Optional[Android] = Field(
        None, description='Build configuration for Android projects'
    )
    javascript: Optional[Javascript] = Field(
        None,
        description='Build configuration when React Native, or other JavaScript tech, is part of the build steps',
    )
    xamarin: Optional[Xamarin] = Field(
        None, description='Build configuration for Xamarin projects'
    )
    xcode: Optional[Xcode1] = Field(
        None, description='Build configuration when Xcode is part of the build steps'
    )


class ArtifactVersioning1(BaseModel):
    buildNumberFormat: Optional[BuildNumberFormat] = None


class Xcode2(BaseModel):
    appExtensionProvisioningProfileFiles: Optional[
        List[AppExtensionProvisioningProfileFile]
    ] = None
    archiveConfiguration: Optional[str] = Field(
        None, description='The build configuration of the target to archive'
    )
    automaticSigning: Optional[bool] = None
    cartfilePath: Optional[str] = Field(
        None, description='Path to Carthage file, if present'
    )
    certificateEncoded: Optional[str] = None
    certificateFileId: Optional[str] = None
    certificateFilename: Optional[str] = None
    certificatePassword: Optional[str] = None
    certificateUploadId: Optional[str] = None
    forceLegacyBuildSystem: Optional[bool] = Field(
        None,
        description='Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.\nBy default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.\n',
    )
    podfilePath: Optional[str] = Field(
        None, description='Path to CococaPods file, if present'
    )
    projectOrWorkspacePath: Optional[str] = Field(
        None, description='Xcode project/workspace path'
    )
    provisioningProfileEncoded: Optional[str] = None
    provisioningProfileFileId: Optional[str] = None
    provisioningProfileFilename: Optional[str] = None
    provisioningProfileUploadId: Optional[str] = None
    scheme: Optional[str] = None
    targetToArchive: Optional[str] = Field(
        None, description='The target id of the selected scheme to archive'
    )
    teamId: Optional[str] = None
    xcodeProjectSha: Optional[str] = Field(
        None, description='The selected pbxproject hash to the repositroy'
    )
    xcodeVersion: Optional[str] = Field(
        None,
        description='Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default is latest stable version, at the time when the configuration is set.',
    )


class Toolsets1(BaseModel):
    android: Optional[Android] = Field(
        None, description='Build configuration for Android projects'
    )
    javascript: Optional[Javascript] = Field(
        None,
        description='Build configuration when React Native, or other JavaScript tech, is part of the build steps',
    )
    xamarin: Optional[Xamarin] = Field(
        None, description='Build configuration for Xamarin projects'
    )
    xcode: Optional[Xcode2] = Field(
        None, description='Build configuration when Xcode is part of the build steps'
    )


class BranchConfigurationWithId(BaseModel):
    artifactVersioning: Optional[ArtifactVersioning1] = Field(
        None,
        description='The versioning configuration for artifacts built for this branch',
    )
    badgeIsEnabled: Optional[bool] = None
    cloneFromBranch: Optional[str] = Field(
        None,
        description='A configured branch name to clone from. If provided, all other parameters will be ignored. Only supported in POST requests.',
    )
    signed: Optional[bool] = None
    testsEnabled: Optional[bool] = None
    toolsets: Optional[Toolsets1] = Field(
        None, description='The branch build configuration for each toolset'
    )
    trigger: Optional[Trigger] = None
    id: int


class Branch1(BaseModel):
    commit: Commit
    name: str = Field(..., description='The branch name')


class BranchProperties(BaseModel):
    branch: Optional[Branch1] = None
    enabled: Optional[bool] = None


class LastBuild(BaseModel):
    buildNumber: str = Field(..., description='The build number')
    finishTime: Optional[str] = Field(
        None, description='The time the build was finished'
    )
    id: PositiveInt = Field(..., description='The build ID')
    lastChangedDate: Optional[str] = Field(
        None, description='The time the build status was last changed'
    )
    queueTime: str = Field(..., description='The time the build was queued')
    result: str = Field(..., description='The build result')
    sourceBranch: str = Field(..., description='The source branch name')
    sourceVersion: str = Field(..., description='The source SHA')
    startTime: Optional[str] = Field(None, description='The time the build was started')
    status: str = Field(..., description='The build status')


class BranchStatus(BaseModel):
    configured: bool
    lastBuild: Optional[LastBuild] = None


class BranchStatusCollectionItem(BaseModel):
    configured: bool
    lastBuild: Optional[LastBuild] = None


class BranchStatusCollection(RootModel[List[BranchStatusCollectionItem]]):
    root: List[BranchStatusCollectionItem] = Field(
        ..., description='A collection of branch status'
    )


class BranchYamlConfiguration(BaseModel):
    yaml: Optional[str] = Field(None, description='Azure Pipelines YAML file')


class BugTrackerType(Enum):
    github = 'github'
    vsts = 'vsts'
    jira = 'jira'


class BugTrackerIssueResult(BaseModel):
    bug_tracker_type: Optional[BugTrackerType] = None
    event_type: Optional[str] = None
    id: Optional[str] = None
    mobile_center_id: Optional[str] = None
    repo_name: Optional[str] = None
    title: Optional[str] = None
    url: Optional[str] = None


class Issue(BaseModel):
    bug_tracker_type: Optional[BugTrackerType] = None
    event_type: Optional[str] = None
    id: Optional[str] = None
    mobile_center_id: Optional[str] = None
    repo_name: Optional[str] = None
    title: Optional[str] = None
    url: Optional[str] = None


class BugTrackerIssuesResult(BaseModel):
    issues: Optional[List[Issue]] = None


class State5(Enum):
    enabled = 'enabled'
    disabled = 'disabled'
    unauthorized = 'unauthorized'


class BugTrackerStateResult(BaseModel):
    state: Optional[State5] = Field(None, description='bugtracker state')


class BugTrackerTokenId(BaseModel):
    token_id: Optional[str] = None


class Build1(BaseModel):
    buildNumber: str = Field(..., description='The build number')
    finishTime: Optional[str] = Field(
        None, description='The time the build was finished'
    )
    id: PositiveInt = Field(..., description='The build ID')
    lastChangedDate: Optional[str] = Field(
        None, description='The time the build status was last changed'
    )
    queueTime: str = Field(..., description='The time the build was queued')
    result: str = Field(..., description='The build result')
    sourceBranch: str = Field(..., description='The source branch name')
    sourceVersion: str = Field(..., description='The source SHA')
    startTime: Optional[str] = Field(None, description='The time the build was started')
    status: str = Field(..., description='The build status')


class BuildAgentQueue(BaseModel):
    queue: str


class BuildAgentQueueResponse(BaseModel):
    buildDefinition: Optional[str] = Field(
        None, description='Name of the build definition'
    )
    name: Optional[str] = Field(None, description='Name of the queue')


class BuildAgentQueuesResponseItem(BaseModel):
    buildDefinition: Optional[str] = Field(
        None, description='Name of the build definition'
    )
    name: Optional[str] = Field(None, description='Name of the queue')


class BuildAgentQueuesResponse(RootModel[List[BuildAgentQueuesResponseItem]]):
    root: List[BuildAgentQueuesResponseItem] = Field(
        ..., description='A list of queues configured in build definitions'
    )


class BuildConcurrencyResponse(BaseModel):
    committed_quantity: Optional[float] = Field(
        None,
        description='The number of pipelines committed, which can be equal or greater than the number from the billing plan',
    )
    quantity: Optional[float] = Field(
        None, description='The number of pipelines set by the billing plan'
    )


class BuildConfiguration2(BaseModel):
    name: str = Field(
        ..., description='Name of build configuration (the same as a build type name)'
    )
    signingConfig: Optional[SigningConfig] = Field(
        None, description='Android signing config. Null if not specified'
    )


class BuildInfo(BaseModel):
    branch_name: Optional[str] = Field(
        None, description='The branch name of the build producing the release'
    )
    commit_hash: Optional[str] = Field(
        None, description='The commit hash of the build producing the release'
    )
    commit_message: Optional[str] = Field(
        None, description='The commit message of the build producing the release'
    )


class BuildIssue(BaseModel):
    category: Optional[str] = None
    message: Optional[str] = None
    type: Optional[str] = None


class BuildLog(BaseModel):
    value: Optional[List[str]] = None


class BuildParams(BaseModel):
    debug: Optional[bool] = Field(None, description='Run build in debug mode')
    sourceVersion: Optional[str] = Field(
        None,
        description='Version to build which represents the full Git commit reference',
    )


class Status(Enum):
    cancelling = 'cancelling'


class BuildPatch(BaseModel):
    status: Optional[Status] = Field(
        None, description='The build status; used to cancel builds'
    )


class BuildScripts(RootModel[Any]):
    root: Any = Field(
        ...,
        description='A collection of detected pre/post buildscripts for current platform toolset',
    )


class BuildServiceStatus(BaseModel):
    message: Optional[str] = None
    os: Optional[str] = None
    service: Optional[str] = None
    status: Optional[str] = None
    url: Optional[str] = None
    valid_until: Optional[int] = None


class Issue1(BaseModel):
    category: Optional[str] = None
    message: Optional[str] = None
    type: Optional[str] = None


class Record(BaseModel):
    currentOperation: Optional[str] = None
    errorCount: Optional[float] = None
    finishTime: Optional[str] = None
    id: Optional[str] = None
    issues: Optional[List[Issue1]] = None
    name: Optional[str] = None
    order: Optional[float] = None
    percentComplete: Optional[float] = None
    result: Optional[str] = None
    startTime: Optional[str] = None
    state: Optional[str] = None
    type: Optional[str] = None
    warningCount: Optional[float] = None


class BuildTimeline(BaseModel):
    id: Optional[str] = None
    records: Optional[List[Record]] = None


class BuildTimelineRecord(BaseModel):
    currentOperation: Optional[str] = None
    errorCount: Optional[float] = None
    finishTime: Optional[str] = None
    id: Optional[str] = None
    issues: Optional[List[Issue1]] = None
    name: Optional[str] = None
    order: Optional[float] = None
    percentComplete: Optional[float] = None
    result: Optional[str] = None
    startTime: Optional[str] = None
    state: Optional[str] = None
    type: Optional[str] = None
    warningCount: Optional[float] = None


class Builds(RootModel[List[Build1]]):
    root: List[Build1] = Field(..., description='A list of builds')


class ClearProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str


class ClearPropertyDiagnostics(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str


class Origin13(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class CloseAccountOrganizationResponse(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin13 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )
    collaborators_count: float = Field(
        ..., description='The number of collaborators from the organization'
    )


class DiffPackageMap(BaseModel):
    size: float
    url: str


class ReleaseMethod(Enum):
    Upload = 'Upload'
    Promote = 'Promote'
    Rollback = 'Rollback'


class CodePushRelease(BaseModel):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    blob_url: Optional[str] = None
    diff_package_map: Optional[Dict[str, DiffPackageMap]] = None
    label: Optional[str] = None
    original_deployment: Optional[str] = Field(None, description="Set on 'Promote'")
    original_label: Optional[str] = Field(
        None, description="Set on 'Promote' and 'Rollback'"
    )
    package_hash: Optional[str] = None
    release_method: Optional[ReleaseMethod] = Field(
        None, description='The release method is unknown if unspecified'
    )
    released_by: Optional[str] = None
    size: Optional[float] = None
    upload_time: Optional[int] = None


class CodePushReleaseInfo(BaseModel):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None


class CodePushReleaseLabel(BaseModel):
    label: Optional[str] = None


class CodePushReleaseMetric(BaseModel):
    active: int
    downloaded: Optional[int] = None
    failed: Optional[int] = None
    installed: Optional[int] = None
    label: str


class CodePushReleaseModification(BaseModel):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None


class CodePushReleasePromote(BaseModel):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    label: Optional[str] = None


class CodePushReleaseUpload(BaseModel):
    id: UUID = Field(
        ...,
        description='The ID for the newly created upload. It is going to be required later in the process.',
    )
    token: str = Field(
        ..., description='The URL encoded token used for upload permissions.'
    )
    upload_domain: str = Field(
        ..., description='The URL domain used to upload the release.'
    )


class CodePushStatusMetricMetadata(BaseModel):
    app_version: Optional[str] = None
    client_unique_id: Optional[str] = None
    deployment_key: str
    label: Optional[str] = None
    previous_deployment_key: Optional[str] = None
    previous_label_or_app_version: Optional[str] = None
    status: Optional[str] = None


class ReleaseUpload(BaseModel):
    id: UUID = Field(
        ...,
        description='The ID for the newly created upload. It is going to be required later in the process.',
    )
    token: str = Field(
        ..., description='The URL encoded token used for upload permissions.'
    )
    upload_domain: str = Field(
        ..., description='The URL domain used to upload the release.'
    )


class CodePushUploadedRelease(BaseModel):
    deployment_name: Optional[str] = Field(
        None,
        description='This specifies which deployment you want to release the update to. Default is Staging.',
    )
    description: Optional[str] = Field(
        None, description='This provides an optional "change log" for the deployment.'
    )
    disabled: Optional[bool] = Field(
        None,
        description='This specifies whether an update should be downloadable by end users or not.',
    )
    mandatory: Optional[bool] = Field(
        None,
        description='This specifies whether the update should be considered mandatory or not (e.g. it includes a critical security fix).',
    )
    no_duplicate_release_error: Optional[bool] = Field(
        None,
        description='This specifies that if the update is identical to the latest release on the deployment, the CLI should generate a warning instead of an error.',
    )
    release_upload: ReleaseUpload = Field(
        ..., description='The upload metadata from the release initialization step.'
    )
    rollout: Optional[int] = Field(
        None,
        description='This specifies the percentage of users (as an integer between 1 and 100) that should be eligible to receive this update.',
    )
    target_binary_version: str = Field(
        ..., description='the binary version of the application'
    )


class Author(BaseModel):
    date: Optional[str] = Field(None, description='Date and time of the commit')
    email: Optional[str] = Field(None, description="Author's email")
    name: Optional[str] = Field(None, description='Author name')


class Commit3(BaseModel):
    author: Optional[Author] = None
    message: Optional[str] = Field(None, description='Commit message')


class CommitDetails(BaseModel):
    sha: Optional[str] = Field(None, description='The commit SHA')
    url: Optional[str] = Field(None, description='The URL to the commit')
    commit: Optional[Commit3] = None


class Commit4(BaseModel):
    author: Optional[Author] = None
    message: Optional[str] = Field(None, description='Commit message')


class CommitDetailsListItem(BaseModel):
    sha: Optional[str] = Field(None, description='The commit SHA')
    url: Optional[str] = Field(None, description='The URL to the commit')
    commit: Optional[Commit4] = None


class CommitDetailsList(RootModel[List[CommitDetailsListItem]]):
    root: List[CommitDetailsListItem] = Field(..., description='A list of commits')


class Details(BaseModel):
    app_start_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='Application launch timestamp (example: 1985-04-12T23:20:50.52Z).\n',
    )
    carrier_country: Optional[str] = Field(
        None, description='Carrier country code (for mobile devices).\n'
    )
    carrier_name: Optional[str] = Field(
        None, description='Carrier name (for mobile devices).\n'
    )
    locale: str = Field(..., description='Language code (example: en_US).\n')
    os_build: Optional[str] = Field(
        None, description='OS build code (example: LMY47X).\n'
    )
    rooted: bool = Field(
        ...,
        description='Whether the device where the crash occurred is rooted or jailbroken\n',
    )
    screen_size: str = Field(
        ..., description='Screen size of the device in pixels (example: 640x480).\n'
    )


class CrashAttachment(BaseModel):
    app_id: str
    attachment_id: str
    blob_location: str
    content_type: str
    crash_id: str
    created_time: datetime_aliased
    file_name: str
    size: float


class CrashAttachmentLocation(BaseModel):
    uri: str


class Crash1(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class CrashCounts(BaseModel):
    count: Optional[int] = Field(None, description='Total crash count.')
    crashes: Optional[List[Crash1]] = Field(
        None, description='The total crash count for day.'
    )


class CrashDeleteCounter(BaseModel):
    app_id: Optional[str] = None
    attachments_deleted: Optional[int] = None
    blobs_failed: Optional[int] = None
    blobs_succeeded: Optional[int] = None
    crash_group_id: Optional[str] = None
    crash_id: Optional[str] = None
    crashes_deleted: Optional[int] = None


class CrashDetails(BaseModel):
    app_start_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='Application launch timestamp (example: 1985-04-12T23:20:50.52Z).\n',
    )
    carrier_country: Optional[str] = Field(
        None, description='Carrier country code (for mobile devices).\n'
    )
    carrier_name: Optional[str] = Field(
        None, description='Carrier name (for mobile devices).\n'
    )
    locale: str = Field(..., description='Language code (example: en_US).\n')
    os_build: Optional[str] = Field(
        None, description='OS build code (example: LMY47X).\n'
    )
    rooted: bool = Field(
        ...,
        description='Whether the device where the crash occurred is rooted or jailbroken\n',
    )
    screen_size: str = Field(
        ..., description='Screen size of the device in pixels (example: 640x480).\n'
    )


class DailyPercentage(BaseModel):
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')
    percentage: Optional[float] = Field(None, description='Percentage of the object.')


class CrashFreeDevicePercentages(BaseModel):
    average_percentage: Optional[float] = Field(None, description='Average percentage.')
    daily_percentages: Optional[List[DailyPercentage]] = Field(
        None, description='The crash-free percentage per day.'
    )


class Language(Enum):
    JavaScript = 'JavaScript'
    CSharp = 'CSharp'
    Objective_C = 'Objective-C'
    Objective_Cpp = 'Objective-Cpp'
    Cpp = 'Cpp'
    C = 'C'
    Swift = 'Swift'
    Java = 'Java'
    Unknown = 'Unknown'


class ReasonFrame(BaseModel):
    app_code: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    class_method: Optional[bool] = Field(None, description='is a class method')
    class_name: Optional[str] = Field(None, description='name of the class')
    code_formatted: Optional[str] = Field(None, description='Formatted frame string')
    code_raw: Optional[str] = Field(None, description='Unformatted Frame string')
    exception_type: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    framework_name: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    method_params: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    os_exception_type: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class Status1(Enum):
    open = 'open'
    closed = 'closed'
    ignored = 'ignored'


class CrashGroup(BaseModel):
    annotation: str
    app_version: str
    build: str
    count: int
    crash_group_id: str
    crash_reason: str
    display_id: str
    exception: Optional[str] = None
    fatal: bool = Field(..., description='Crash or handled exception')
    first_occurrence: datetime_aliased
    impacted_users: Optional[int] = None
    last_occurrence: datetime_aliased
    new_crash_group_id: str
    reason_frame: Optional[ReasonFrame] = Field(
        None, description='frame belonging to the reason of the crash'
    )
    status: Status1


class CrashGroupAndVersion(BaseModel):
    app_version: Optional[str] = None
    crash_group_id: Optional[str] = None


class CrashGroupCarrier(BaseModel):
    carrier_name: Optional[str] = Field(None, description='Carrier name.')
    crash_count: Optional[int] = Field(None, description='Crash count of carrier.')


class Carrier(BaseModel):
    carrier_name: Optional[str] = Field(None, description='Carrier name.')
    crash_count: Optional[int] = Field(None, description='Crash count of carrier.')


class CrashGroupCarriers(BaseModel):
    carriers: Optional[List[Carrier]] = None
    crash_count: Optional[int] = None


class CrashGroupChange(BaseModel):
    annotation: Optional[str] = None
    status: Optional[Status1] = None


class CrashGroup1(BaseModel):
    app_version: Optional[str] = None
    crash_group_id: Optional[str] = None


class CrashGroupContainer(BaseModel):
    crash_groups: List[CrashGroup1] = Field(..., min_length=1)


class CrashGroupLanguage(BaseModel):
    crash_count: Optional[int] = Field(None, description='Count of languages.')
    language_name: Optional[str] = Field(None, description='Language name.')


class Language1(BaseModel):
    crash_count: Optional[int] = Field(None, description='Count of languages.')
    language_name: Optional[str] = Field(None, description='Language name.')


class CrashGroupLanguages(BaseModel):
    crash_count: Optional[int] = None
    languages: Optional[List[Language1]] = None


class CrashGroupModel(BaseModel):
    crash_count: Optional[int] = Field(None, description='Count of model.')
    model_name: Optional[str] = Field(None, description="Model's name.")


class Model1(BaseModel):
    crash_count: Optional[int] = Field(None, description='Count of model.')
    model_name: Optional[str] = Field(None, description="Model's name.")


class CrashGroupModels(BaseModel):
    crash_count: Optional[int] = None
    models: Optional[List[Model1]] = None


class CrashGroupOperatingSystem(BaseModel):
    crash_count: Optional[int] = Field(None, description='Count of OS.')
    operating_system_name: Optional[str] = Field(None, description='OS name.')


class OperatingSystem(BaseModel):
    crash_count: Optional[int] = Field(None, description='Count of OS.')
    operating_system_name: Optional[str] = Field(None, description='OS name.')


class CrashGroupOperatingSystems(BaseModel):
    crash_count: Optional[int] = None
    operating_systems: Optional[List[OperatingSystem]] = None


class CrashGroupPlace(BaseModel):
    crash_count: Optional[int] = Field(None, description='Count of places.')
    place_name: Optional[str] = Field(None, description='Place name.')


class Place(BaseModel):
    crash_count: Optional[int] = Field(None, description='Count of places.')
    place_name: Optional[str] = Field(None, description='Place name.')


class CrashGroupPlaces(BaseModel):
    crash_count: Optional[int] = None
    places: Optional[List[Place]] = None


class CrashGroupStatusEnum(Enum):
    open = 'open'
    closed = 'closed'
    ignored = 'ignored'


class Language2(Enum):
    JavaScript = 'JavaScript'
    CSharp = 'CSharp'
    Objective_C = 'Objective-C'
    Objective_Cpp = 'Objective-Cpp'
    Cpp = 'Cpp'
    C = 'C'
    Swift = 'Swift'
    Java = 'Java'
    Unknown = 'Unknown'


class ReasonFrame1(BaseModel):
    app_code: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    class_method: Optional[bool] = Field(None, description='is a class method')
    class_name: Optional[str] = Field(None, description='name of the class')
    code_formatted: Optional[str] = Field(None, description='Formatted frame string')
    code_raw: Optional[str] = Field(None, description='Unformatted Frame string')
    exception_type: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    framework_name: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    method_params: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    os_exception_type: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class CrashGroup2(BaseModel):
    annotation: str
    app_version: str
    build: str
    count: int
    crash_group_id: str
    crash_reason: str
    display_id: str
    exception: Optional[str] = None
    fatal: bool = Field(..., description='Crash or handled exception')
    first_occurrence: datetime_aliased
    impacted_users: Optional[int] = None
    last_occurrence: datetime_aliased
    new_crash_group_id: str
    reason_frame: Optional[ReasonFrame1] = Field(
        None, description='frame belonging to the reason of the crash'
    )
    status: Status1


class CrashGroupsContainer(BaseModel):
    continuation_token: Optional[str] = Field(
        None,
        description='Cassandra request continuation token. The token is used for pagination.',
    )
    crash_groups: List[CrashGroup2]
    limited_result_set: bool


class CrashOverall(BaseModel):
    crash_count: Optional[int] = None
    device_count: Optional[int] = None


class CrashRawLocation(BaseModel):
    uri: str


class Overall(BaseModel):
    crash_count: Optional[int] = None
    device_count: Optional[int] = None


class CrashesOverallItem(BaseModel):
    app_version: Optional[str] = None
    crash_group_id: Optional[str] = None
    overall: Optional[Overall] = None


class CrashesOverall(RootModel[List[CrashesOverallItem]]):
    root: List[CrashesOverallItem] = Field(
        ...,
        description='List of crash groups with overall crashes count and affected users.',
    )


class CrashingAppDetail(BaseModel):
    appId: Optional[str] = Field(None, description='application identifier')
    appVersion: Optional[str] = Field(None, description='application version')
    crashGroupId: Optional[str] = Field(None, description='crash group identifier')


class CreateAccessKeyRequest(BaseModel):
    createdBy: Optional[str] = Field(
        None, description='Name of creator current access key'
    )
    friendlyName: Optional[str] = Field(
        None, description='Friendly name of the access key'
    )
    ttl: Optional[float] = Field(None, description='Time to live of the access key')


class CreateAccessKeyResponse(BaseModel):
    accessKey: Optional[AccessKey] = None


class CreateGdprTestData(BaseModel):
    accountId: Optional[UUID] = None
    appId: Optional[UUID] = None
    appName: Optional[str] = None
    userEmail: Optional[str] = None
    userName: Optional[str] = None


class CreateReleaseUploadResponse(BaseModel):
    id: UUID = Field(
        ...,
        description='The ID for the newly created upload. It is going to be required later in the process.',
    )
    package_asset_id: UUID = Field(
        ...,
        description='The associated asset ID in the file management service associated with this uploaded.',
    )
    token: str = Field(..., description='The access token used for upload permissions.')
    upload_domain: str = Field(
        ..., description='The URL domain used to upload the release.'
    )
    url_encoded_token: str = Field(
        ...,
        description='The access token used for upload permissions (URL encoded to use as a single query parameter).',
    )


class SecretJson(BaseModel):
    id_token: Optional[str] = Field(None, description='the id token of user')
    refresh_token: Optional[str] = Field(None, description='the refresh token for user')
    refresh_token_expiry: Optional[str] = Field(
        None, description='the expiry of refresh token'
    )


class CreateStoreSecretRequest(BaseModel):
    secret_json: Optional[SecretJson] = None
    tenant_id: Optional[str] = Field(None, description='the tenant id for user')


class CreateStoreSecretResponse(BaseModel):
    secret_id: Optional[str] = Field(None, description='the secret id for store secret')


class CustomProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str


class Device(BaseModel):
    app_build: str = Field(..., description="The app's build number, e.g. 42.\n")
    app_namespace: Optional[str] = Field(
        None,
        description='The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.\n',
    )
    app_version: str = Field(..., description='Application version name, e.g. 1.1.0\n')
    carrier_code: Optional[str] = Field(
        None, description='Carrier country code (for mobile devices).\n'
    )
    carrier_country: Optional[str] = Field(None, description='Carrier country.\n')
    carrier_name: Optional[str] = Field(
        None, description='Carrier name (for mobile devices).\n'
    )
    live_update_deployment_key: Optional[str] = Field(
        None,
        description='Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.\n',
    )
    live_update_package_hash: Optional[str] = Field(
        None,
        description='Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.\n',
    )
    live_update_release_label: Optional[str] = Field(
        None,
        description="Label that is used to identify application code 'version' released via Live Update beacon running on device\n",
    )
    locale: str = Field(..., description='Language code (example: en_US).\n')
    model: Optional[str] = Field(None, description='Device model (example: iPad2,3).\n')
    oem_name: Optional[str] = Field(
        None, description='Device manufacturer (example: HTC).\n'
    )
    os_api_level: Optional[int] = Field(
        None, description='API level when applicable like in Android (example: 15).\n'
    )
    os_build: Optional[str] = Field(
        None, description='OS build code (example: LMY47X).\n'
    )
    os_name: str = Field(
        ...,
        description='OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.\n',
    )
    os_version: str = Field(..., description='OS version (example: 9.3.0).\n')
    screen_size: Optional[str] = Field(
        None, description='Screen size of the device in pixels (example: 640x480).\n'
    )
    sdk_name: str = Field(
        ...,
        description='Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".\n',
    )
    sdk_version: str = Field(
        ...,
        description='Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".\n',
    )
    time_zone_offset: conint(ge=-840, le=840) = Field(
        ...,
        description='The offset in minutes from UTC for the device time zone, including daylight savings time.\n',
    )
    wrapper_runtime_version: Optional[str] = Field(
        None,
        description='Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.\n',
    )
    wrapper_sdk_name: Optional[str] = Field(
        None,
        description='Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".\n',
    )
    wrapper_sdk_version: Optional[str] = Field(
        None,
        description='Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.\n',
    )


class Type15(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class Property(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str


class CustomPropertyLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type15 = Field(..., description='Log type.\n')
    properties: Optional[List[Property]] = Field(
        None, description='Custom property changes.', max_length=60, min_length=1
    )


class CustomPropertyLogDiagnostics(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type15 = Field(..., description='Log type.\n')
    properties: Optional[List[Property]] = Field(
        None, description='Custom property changes.', max_length=60, min_length=1
    )


class CustomPropertyDiagnostics(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str


class DailySession(BaseModel):
    count: Optional[int] = None
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class DataSubjectRighBlobContainerInfo(BaseModel):
    blobPath: str
    sasUri: str


class Type17(Enum):
    CustomerAccountId = 'CustomerAccountId'
    CustomerUserId = 'CustomerUserId'


class DataSubjectRightCustomerIdRequest(BaseModel):
    dataSubjectIdentifier: Optional[str] = Field(
        None,
        description='customer account id (b2c identifier) / customer user id (free form text) depending on the value of the fied `type`',
    )
    type: Optional[Type17] = Field(
        None, description='type of the customer dataSubjectIdentifier'
    )


class DataSubjectRightEmailRequest(BaseModel):
    email: str = Field(
        ..., description='Email used for cancel delete with x-authz-bypass headers'
    )


class RequestType(Enum):
    Unsupported = 'Unsupported'
    Delete = 'Delete'
    Purge = 'Purge'
    UndoDelete = 'UndoDelete'
    Scheduled = 'Scheduled'
    AppDelete = 'AppDelete'
    AppPurge = 'AppPurge'
    AppUndoDelete = 'AppUndoDelete'
    Export = 'Export'
    CustomerAccountDelete = 'CustomerAccountDelete'
    CustomerAccountExport = 'CustomerAccountExport'
    CustomerUserDelete = 'CustomerUserDelete'
    CustomerUserExport = 'CustomerUserExport'


class Status4(Enum):
    None_ = 'None'
    Created = 'Created'
    Queued = 'Queued'
    InProgress = 'InProgress'
    Completed = 'Completed'
    Failed = 'Failed'


class DataSubjectRightOperation(BaseModel):
    appId: Optional[str] = Field(
        None, description='Application identifier if applicable'
    )
    context: str = Field(
        ...,
        description='JSON object decribing what to delete (TODO - make separate definition?)',
    )
    operationId: UUID = Field(..., description='Unique operation identifier')
    participant: str = Field(..., description='Participant to execute the response')
    participantData: Optional[str] = Field(
        None,
        description='String field to be used by participant for any intermediate statuses or data they need to save',
    )
    requestId: UUID = Field(..., description='Unique request identifier')
    requestType: RequestType = Field(..., description='Request type')
    status: Status4 = Field(..., description='Operation status')


class DataSubjectRightQueueInfo(BaseModel):
    expiresAt: datetime_aliased
    queueName: str
    sasUri: AnyUrl


class DataSubjectRightResponse(BaseModel):
    createdAt: datetime_aliased = Field(
        ..., description='ISO 8601 format timestamp of when request was created.'
    )
    token: UUID = Field(..., description='Unique request identifier')


class DataSubjectRightStatusResponse(BaseModel):
    message: str = Field(..., description='explanation message of the status')
    sasUrl: Optional[str] = Field(
        None,
        description='Azure Storage shared access signature (SAS) URL for exported user data.',
    )
    sasUrlExpired: Optional[bool] = Field(
        None,
        description='Whether Azure Storage shared access signature (SAS) URL has expired or not.',
    )
    status: Status4 = Field(..., description='Status of data subject right request')


class DataSubjectRightUpdateStatusOperation(BaseModel):
    participantData: Optional[str] = Field(
        None,
        description='String field to be used by participant for any intermediate statuses or data they need to save',
    )
    requestId: str = Field(..., description='Request identifier of the operation')
    status: Status4 = Field(..., description='Operation status')


class DateTimeCounts(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class DateTimeDecimalCounts(BaseModel):
    count: Optional[float] = Field(None, description='Decimal count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class DateTimeDownloadReleaseCount(BaseModel):
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')
    total: Optional[int] = None
    unique: Optional[int] = None


class Count(BaseModel):
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')
    total: Optional[int] = None
    unique: Optional[int] = None


class DateTimeDownloadReleaseCounts(BaseModel):
    counts: Optional[List[Count]] = Field(None, description='Release counts per day.')
    total: Optional[int] = None
    unique: Optional[int] = None


class DateTimePercentages(BaseModel):
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')
    percentage: Optional[float] = Field(None, description='Percentage of the object.')


class DateTimeProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: datetime_aliased = Field(..., description='Date time property value.')


class DateTimePropertyDiagnostics(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: datetime_aliased = Field(..., description='Date time property value.')


class Release1(BaseModel):
    release: str = Field(..., description='Release Id.\n')


class DeleteReleasesContainer(BaseModel):
    releases: List[Release1] = Field(..., min_length=1)


class LatestRelease(BaseModel):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    blob_url: Optional[str] = None
    diff_package_map: Optional[Dict[str, DiffPackageMap]] = None
    label: Optional[str] = None
    original_deployment: Optional[str] = Field(None, description="Set on 'Promote'")
    original_label: Optional[str] = Field(
        None, description="Set on 'Promote' and 'Rollback'"
    )
    package_hash: Optional[str] = None
    release_method: Optional[ReleaseMethod] = Field(
        None, description='The release method is unknown if unspecified'
    )
    released_by: Optional[str] = None
    size: Optional[float] = None
    upload_time: Optional[int] = None


class Deployment(BaseModel):
    key: Optional[str] = None
    latest_release: Optional[LatestRelease] = None
    name: str


class LatestRelease1(BaseModel):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    blob_url: Optional[str] = None
    diff_package_map: Optional[Dict[str, DiffPackageMap]] = None
    label: Optional[str] = None
    original_deployment: Optional[str] = Field(None, description="Set on 'Promote'")
    original_label: Optional[str] = Field(
        None, description="Set on 'Promote' and 'Rollback'"
    )
    package_hash: Optional[str] = None
    release_method: Optional[ReleaseMethod] = Field(
        None, description='The release method is unknown if unspecified'
    )
    released_by: Optional[str] = None
    size: Optional[float] = None
    upload_time: Optional[int] = None


class DeploymentInternal(BaseModel):
    key: Optional[str] = None
    latest_release: Optional[LatestRelease1] = None
    name: str
    id: Optional[str] = None


class DeploymentModification(BaseModel):
    name: constr(min_length=1, max_length=1000)


class Type18(Enum):
    intune = 'intune'
    googleplay = 'googleplay'
    apple = 'apple'
    none = 'none'


class Destination1(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution group.',
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type18] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )
    destination_type: Optional[DestinationType] = Field(
        None, description='Destination can be either store or group.'
    )
    display_name: Optional[str] = Field(
        None, description='Display name for the group or tester'
    )


class Type19(Enum):
    store = 'store'
    group = 'group'
    tester = 'tester'


class DestinationDetails(BaseModel):
    id: str
    type: Type19


class DestinationError(BaseModel):
    code: Optional[str] = Field(
        None,
        description='Error Codes:<br>\n<b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not valid.<br>\n<b>store_release_bad_request</b>: Proper package release details for the store is not provided.<br>\n<b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid developer credentials.<br>\n<b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the release version and already existing version in the store.<br>\n<b>store_release_promotion</b>: Release already distributed, promoting a release is not supported.<br>\n<b>store_track_deactivated</b>: One or more tracks would be deactivated with this release. This is not supported yet.<br>\n<b>store_release_not_found</b>: App with the given package name is not found in the store.<br>\n<b>store_release_not_available</b>: The release is not available.<br>\n<b>internal_server_error</b>: Failed to distribute to a destination due to an internal server error.\n',
    )
    id: Optional[str] = None
    message: Optional[str] = None
    name: Optional[str] = None


class DestinationId(BaseModel):
    id: Optional[str] = Field(
        None,
        description="Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.",
    )
    name: Optional[str] = Field(
        None,
        description="Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.",
    )


class DeviceAvailability(BaseModel):
    available: float
    maximum: float
    registered: float


class Image(BaseModel):
    full: Optional[str] = None
    thumb: Optional[str] = None


class Cpu(BaseModel):
    core: Optional[str] = None
    frequency: Optional[str] = None
    text: Optional[str] = None


class Full(BaseModel):
    frameUrl: Optional[str] = None
    height: Optional[float] = None
    screen: Optional[List[float]] = None
    width: Optional[float] = None


class Grid(BaseModel):
    frameUrl: Optional[str] = None
    height: Optional[float] = None
    screen: Optional[List[float]] = None
    width: Optional[float] = None


class DeviceFrame(BaseModel):
    full: Optional[Full] = None
    grid: Optional[Grid] = None


class Dimensions(BaseModel):
    depth: Optional[Dict[str, Any]] = None
    height: Optional[Dict[str, Any]] = None
    width: Optional[Dict[str, Any]] = None


class Memory(BaseModel):
    formattedSize: Optional[str] = None


class Resolution(BaseModel):
    height: Optional[str] = None
    ppi: Optional[str] = None
    width: Optional[str] = None


class ScreenSize(BaseModel):
    cm: Optional[str] = None
    in_: Optional[str] = Field(None, alias='in')


class Model2(BaseModel):
    availabilityCount: Optional[float] = None
    cpu: Optional[Cpu] = Field(None, description='CPU data for device')
    deviceFrame: Optional[DeviceFrame] = None
    dimensions: Optional[Dimensions] = Field(
        None, description='Physical device dimensions'
    )
    formFactor: Optional[str] = None
    manufacturer: Optional[str] = None
    memory: Optional[Memory] = Field(None, description='Memory data for device')
    model: Optional[str] = None
    name: Optional[str] = None
    platform: Optional[str] = None
    releaseDate: Optional[str] = None
    resolution: Optional[Resolution] = Field(
        None, description='Device screen resolution'
    )
    screenRotation: Optional[float] = None
    screenSize: Optional[ScreenSize] = Field(
        None, description='Physical device screen dimensions'
    )


class DeviceConfiguration(BaseModel):
    id: Optional[UUID] = Field(
        None, description='The unique id of the device configuration'
    )
    image: Optional[Image] = None
    marketShare: Optional[float] = None
    model: Optional[Model2] = None
    name: Optional[str] = Field(
        None, description='The name of the device model and OS version'
    )
    os: Optional[str] = None
    osName: Optional[str] = None
    tier: Optional[float] = Field(None, description='The tier')


class DeviceConfigurationResponse(BaseModel):
    data_url: str = Field(
        ..., description='A data URL containing a signed mobileconfig profile'
    )


class DeviceCpu(BaseModel):
    core: Optional[str] = None
    frequency: Optional[str] = None
    text: Optional[str] = None


class DeviceDimensions(BaseModel):
    depth: Optional[Dict[str, Any]] = None
    height: Optional[Dict[str, Any]] = None
    width: Optional[Dict[str, Any]] = None


class DeviceFrame1(BaseModel):
    full: Optional[Full] = None
    grid: Optional[Grid] = None


class DeviceFrameDefinition(BaseModel):
    frameUrl: Optional[str] = None
    height: Optional[float] = None
    screen: Optional[List[float]] = None
    width: Optional[float] = None


class DeviceInfoRequest(BaseModel):
    imei: Optional[str] = Field(
        None,
        description="The device's International Mobile Equipment Identity number. Always empty or undefined at present.",
    )
    model: str = Field(
        ..., description='The model identifier of the device, in the format iDeviceM,N'
    )
    os_build: Optional[str] = Field(
        None,
        description='The build number of the last known OS version running on the device',
    )
    os_version: Optional[str] = Field(
        None, description='The last known OS version running on the device'
    )
    owner_id: Optional[str] = Field(
        None, description='The user ID of the device owner.'
    )
    serial: Optional[str] = Field(
        None,
        description="The device's serial number. Always empty or undefined at present.",
    )
    udid: str = Field(..., description='The Unique Device IDentifier of the device')


class DeviceInfoResponse(BaseModel):
    device_name: str = Field(
        ..., description='The device description, in the format "iPhone 7 Plus (A1784)"'
    )
    full_device_name: Optional[str] = Field(
        None, description='A combination of the device model name and the owner name.'
    )
    imei: Optional[str] = Field(
        None,
        description="The device's International Mobile Equipment Identity number. Always empty or undefined at present.",
    )
    model: str = Field(
        ..., description='The model identifier of the device, in the format iDeviceM,N'
    )
    os_build: str = Field(
        ..., description='The last known OS version running on the device'
    )
    os_version: str = Field(
        ..., description='The last known OS version running on the device'
    )
    owner_id: Optional[str] = Field(
        None, description='The user ID of the device owner.'
    )
    registered_at: Optional[str] = Field(
        None, description='Timestamp of when the device was registered in ISO format.'
    )
    serial: Optional[str] = Field(
        None,
        description="The device's serial number. Always empty or undefined at present.",
    )
    status: str = Field(..., description='The provisioning status of the device.')
    udid: str = Field(..., description='The Unique Device IDentifier of the device')


class DeviceList(BaseModel):
    devices: List[str]


class DeviceMemory(BaseModel):
    formattedSize: Optional[str] = None


class DeviceFrame2(BaseModel):
    full: Optional[Full] = None
    grid: Optional[Grid] = None


class DeviceModel(BaseModel):
    availabilityCount: Optional[float] = None
    cpu: Optional[Cpu] = Field(None, description='CPU data for device')
    deviceFrame: Optional[DeviceFrame2] = None
    dimensions: Optional[Dimensions] = Field(
        None, description='Physical device dimensions'
    )
    formFactor: Optional[str] = None
    manufacturer: Optional[str] = None
    memory: Optional[Memory] = Field(None, description='Memory data for device')
    model: Optional[str] = None
    name: Optional[str] = None
    platform: Optional[str] = None
    releaseDate: Optional[str] = None
    resolution: Optional[Resolution] = Field(
        None, description='Device screen resolution'
    )
    screenRotation: Optional[float] = None
    screenSize: Optional[ScreenSize] = Field(
        None, description='Physical device screen dimensions'
    )


class DeviceRegistrationUrl(BaseModel):
    registration_url: str = Field(
        ...,
        description='The url that can be navigated to in order to start the device registration process.',
    )


class DeviceResolution(BaseModel):
    height: Optional[str] = None
    ppi: Optional[str] = None
    width: Optional[str] = None


class DeviceScreenSize(BaseModel):
    cm: Optional[str] = None
    in_: Optional[str] = Field(None, alias='in')


class DeviceSelection(BaseModel):
    shortId: str = Field(..., description='Identifier of the device selection')


class Image1(BaseModel):
    thumb: Optional[str] = None


class Model3(BaseModel):
    formFactor: Optional[str] = None
    manufacturer: Optional[str] = None
    name: Optional[str] = None
    releaseDate: Optional[str] = None


class DeviceConfiguration1(BaseModel):
    id: Optional[UUID] = Field(
        None, description='The unique id of the device configuration'
    )
    image: Optional[Image1] = None
    model: Optional[Model3] = None
    os: Optional[str] = None
    osName: Optional[str] = None


class Owner8(BaseModel):
    displayName: Optional[str] = Field(None, description='Display name of the account')
    id: str = Field(..., description='Account ID')
    name: str = Field(..., description='Name of the account')
    type: str = Field(..., description='Type of account')


class DeviceSet(BaseModel):
    deviceConfigurations: List[DeviceConfiguration1]
    id: str = Field(..., description='Identifier of the device set')
    manufacturerCount: Optional[float] = Field(
        None,
        description="The number of manufacturers in the device set's device selection",
    )
    name: str = Field(..., description='Name of the device set')
    osVersionCount: Optional[float] = Field(
        None,
        description="The number of os versions in the device set's device selection",
    )
    owner: Owner8 = Field(
        ..., description='The owner of a device set', title='Device Set Owner'
    )
    slug: Optional[str] = Field(None, description='Slug of the device set')


class DeviceSetConfiguration(BaseModel):
    id: Optional[UUID] = Field(
        None, description='The unique id of the device configuration'
    )
    image: Optional[Image1] = None
    model: Optional[Model3] = None
    os: Optional[str] = None
    osName: Optional[str] = None


class DeviceSetModel(BaseModel):
    formFactor: Optional[str] = None
    manufacturer: Optional[str] = None
    name: Optional[str] = None
    releaseDate: Optional[str] = None


class DeviceSetOwner(BaseModel):
    displayName: Optional[str] = Field(None, description='Display name of the account')
    id: str = Field(..., description='Account ID')
    name: str = Field(..., description='Name of the account')
    type: str = Field(..., description='Type of account')


class DeviceSetUpdate(BaseModel):
    devices: List[str] = Field(..., description='List of device IDs')
    name: str = Field(..., description='The name of the device set')


class DeviceDiagnostics(BaseModel):
    app_build: str = Field(..., description="The app's build number, e.g. 42.\n")
    app_namespace: Optional[str] = Field(
        None,
        description='The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.\n',
    )
    app_version: str = Field(..., description='Application version name, e.g. 1.1.0\n')
    carrier_code: Optional[str] = Field(
        None, description='Carrier country code (for mobile devices).\n'
    )
    carrier_country: Optional[str] = Field(None, description='Carrier country.\n')
    carrier_name: Optional[str] = Field(
        None, description='Carrier name (for mobile devices).\n'
    )
    live_update_deployment_key: Optional[str] = Field(
        None,
        description='Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.\n',
    )
    live_update_package_hash: Optional[str] = Field(
        None,
        description='Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.\n',
    )
    live_update_release_label: Optional[str] = Field(
        None,
        description="Label that is used to identify application code 'version' released via Live Update beacon running on device\n",
    )
    locale: str = Field(..., description='Language code (example: en_US).\n')
    model: Optional[str] = Field(None, description='Device model (example: iPad2,3).\n')
    oem_name: Optional[str] = Field(
        None, description='Device manufacturer (example: HTC).\n'
    )
    os_api_level: Optional[int] = Field(
        None, description='API level when applicable like in Android (example: 15).\n'
    )
    os_build: Optional[str] = Field(
        None, description='OS build code (example: LMY47X).\n'
    )
    os_name: str = Field(
        ...,
        description='OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.\n',
    )
    os_version: str = Field(..., description='OS version (example: 9.3.0).\n')
    screen_size: Optional[str] = Field(
        None, description='Screen size of the device in pixels (example: 640x480).\n'
    )
    sdk_name: str = Field(
        ...,
        description='Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".\n',
    )
    sdk_version: str = Field(
        ...,
        description='Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".\n',
    )
    time_zone_offset: conint(ge=-840, le=840) = Field(
        ...,
        description='The offset in minutes from UTC for the device time zone, including daylight savings time.\n',
    )
    wrapper_runtime_version: Optional[str] = Field(
        None,
        description='Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.\n',
    )
    wrapper_sdk_name: Optional[str] = Field(
        None,
        description='Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".\n',
    )
    wrapper_sdk_version: Optional[str] = Field(
        None,
        description='Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.\n',
    )


class DiagnosticIdResponse(BaseModel):
    diagnostic_id: Optional[str] = Field(None, description='diagnostic id')


class Frame(BaseModel):
    address: Optional[str] = Field(None, description='address of the frame')
    app_code: bool = Field(..., description="this line isn't from any framework")
    class_method: Optional[bool] = Field(None, description='is a class method')
    class_name: Optional[str] = Field(None, description='name of the class')
    code_formatted: str = Field(..., description='Formatted frame string')
    code_raw: str = Field(..., description='Raw frame string')
    file: Optional[str] = Field(None, description='name of the file')
    framework_name: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    method_params: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    relevant: Optional[bool] = Field(None, description='frame should be shown always')


class Platform6(Enum):
    ios = 'ios'
    android = 'android'
    xamarin = 'xamarin'
    react_native = 'react-native'
    ndk = 'ndk'
    unity = 'unity'
    other = 'other'


class DiagnosticsException(BaseModel):
    frames: List[Frame] = Field(..., description='frames of the excetpion')
    inner_exceptions: Optional[List[DiagnosticsException]] = None
    platform: Optional[Platform6] = Field(
        None, description='SDK/Platform this thread is beeing generated from'
    )
    reason: Optional[str] = Field(None, description='Reason of the exception')
    relevant: Optional[bool] = Field(None, description='relevant exception (crashed)')
    type: Optional[str] = Field(
        None,
        description='Type of the exception (NSSomethingException, NullPointerException)',
    )


class DiagnosticsStackFrame(BaseModel):
    address: Optional[str] = Field(None, description='address of the frame')
    app_code: bool = Field(..., description="this line isn't from any framework")
    class_method: Optional[bool] = Field(None, description='is a class method')
    class_name: Optional[str] = Field(None, description='name of the class')
    code_formatted: str = Field(..., description='Formatted frame string')
    code_raw: str = Field(..., description='Raw frame string')
    file: Optional[str] = Field(None, description='name of the file')
    framework_name: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    method_params: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    relevant: Optional[bool] = Field(None, description='frame should be shown always')


class Frame1(BaseModel):
    address: Optional[str] = Field(None, description='address of the frame')
    app_code: bool = Field(..., description="this line isn't from any framework")
    class_method: Optional[bool] = Field(None, description='is a class method')
    class_name: Optional[str] = Field(None, description='name of the class')
    code_formatted: str = Field(..., description='Formatted frame string')
    code_raw: str = Field(..., description='Raw frame string')
    file: Optional[str] = Field(None, description='name of the file')
    framework_name: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    method_params: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    relevant: Optional[bool] = Field(None, description='frame should be shown always')


class DiagnosticsThread(BaseModel):
    crashed: Optional[bool] = Field(None, description='True if this thread crashed')
    exception: Optional[DiagnosticsException] = None
    frames: List[Frame1] = Field(..., description='frames of that thread')
    platform: Optional[Platform6] = Field(
        None, description='SDK/Platform this thread is beeing generated from'
    )
    relevant: Optional[bool] = Field(
        None,
        description='Shows if a thread is relevant or not. Is false if all frames are non relevant, otherwise true',
    )
    title: str = Field(..., description='name of the thread')


class DistributionGroupAADGroupBase(BaseModel):
    aad_group_id: Optional[UUID] = Field(None, description='The id of the aad group')
    display_name: Optional[str] = Field(
        None, description='The display name of the aad group'
    )


class DistributionGroupAADGroupPostResponse(BaseModel):
    aad_group_id: Optional[UUID] = Field(
        None, description='The AAD unique id (UUID) of the AAD group.'
    )
    display_name: Optional[str] = Field(
        None, description='The display name of the AAD group'
    )
    id: Optional[UUID] = Field(
        None, description='The internal unique id (UUID) of the AAD group.'
    )


class AadGroup(BaseModel):
    aad_group_id: Optional[UUID] = Field(None, description='The id of the aad group')
    display_name: Optional[str] = Field(
        None, description='The display name of the aad group'
    )


class DistributionGroupAADGroupRequest(BaseModel):
    aad_groups: Optional[List[AadGroup]] = Field(
        None, description='The list of aad group ids and names to add'
    )


class DistributionGroupAADGroupResponse(BaseModel):
    aad_group_id: Optional[UUID] = Field(
        None, description='The AAD unique id (UUID) of the AAD group.'
    )
    display_name: Optional[str] = Field(
        None, description='The display name of the AAD group'
    )
    distribution_group_name: Optional[str] = Field(
        None, description='The distribution group of the AAD group'
    )
    id: Optional[UUID] = Field(
        None, description='The internal unique id (UUID) of the AAD group.'
    )
    is_aad_group: Optional[bool] = None


class DistributionGroupAADGroupsDeleteRequest(BaseModel):
    aad_group_ids: Optional[List[str]] = Field(
        None, description='The list of aad group ids'
    )


class DistributionGroupAadGroupsDeleteResponse(BaseModel):
    aad_group_id: Optional[UUID] = Field(None, description='The aad id of the group')
    code: Optional[str] = Field(None, description='The code of the result')
    message: Optional[int] = Field(None, description='The message of the result')
    status: int = Field(..., description='The status code of the result')


class App1(BaseModel):
    name: str = Field(
        ..., description='The name of the app to be added to the distribution group'
    )


class DistributionGroupAppAddRequest(BaseModel):
    apps: Optional[List[App1]] = Field(
        None, description='The list of apps to add to distribution group'
    )


class App2(BaseModel):
    name: str = Field(
        ..., description='The name of the app to be deleted from the distribution group'
    )


class DistributionGroupAppsDeleteRequest(BaseModel):
    apps: Optional[List[App2]] = Field(
        None,
        description='The list of apps to delete from the distribution group',
        min_length=1,
    )


class GroupType(Enum):
    Default = 'Default'
    HockeyAppDefault = 'HockeyAppDefault'
    MicrosoftDogfooding = 'MicrosoftDogfooding'


class User(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: Optional[UUID] = Field(None, description='The unique id (UUID) of the user')
    invite_pending: Optional[bool] = Field(
        None,
        description='Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".',
    )
    name: Optional[str] = Field(
        None, description='The unique name that is used to identify the user.'
    )


class DistributionGroupDetailsResponse(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin13 = Field(
        ..., description='The creation origin of this distribution group'
    )
    group_type: Optional[GroupType] = Field(
        None,
        description='Type of group (Default, HockeyAppDefault or MicrosoftDogfooding)',
    )
    is_shared: bool = Field(
        ..., description='Whether the distribution group is shared group or not'
    )
    notified_user_count: float = Field(
        ...,
        description='The count of non-pending users in the distribution group who will be notified by new releases',
    )
    total_apps_count: float = Field(
        ..., description='The count of apps associated with this distribution group'
    )
    total_user_count: float = Field(
        ..., description='The count of users in the distribution group'
    )
    users: List[User] = Field(..., description='The distribution group users')


class DistributionGroupPatchRequest(BaseModel):
    is_public: Optional[bool] = Field(
        None, description='Whether the distribution group is public'
    )
    name: Optional[str] = Field(None, description='The name of the distribution group')


class DistributionGroupPrivateResponse(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin13 = Field(
        ..., description='The creation origin of this distribution group'
    )
    group_type: Optional[GroupType] = Field(None, description='Type of group')


class Origin16(Enum):
    hockeyapp = 'hockeyapp'
    appcenter = 'appcenter'


class DistributionGroupRelease(BaseModel):
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    id: int = Field(..., description='ID identifying this unique release.')
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    mandatory_update: bool = Field(
        ...,
        description='A boolean which determines whether the release is a mandatory update or not.',
    )
    origin: Optional[Origin16] = Field(None, description="The release's origin")
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class DistributionGroupReleasesResponseItem(BaseModel):
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    id: int = Field(..., description='ID identifying this unique release.')
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    mandatory_update: bool = Field(
        ...,
        description='A boolean which determines whether the release is a mandatory update or not.',
    )
    origin: Optional[Origin16] = Field(None, description="The release's origin")
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class DistributionGroupReleasesResponse(
    RootModel[List[DistributionGroupReleasesResponseItem]]
):
    root: List[DistributionGroupReleasesResponseItem] = Field(
        ...,
        description='Response for getting a list of releases in a distribution group',
    )


class DistributionGroupRequest(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The display name of the distribution group. If not specified, the name will be used.',
    )
    name: str = Field(..., description='The name of the distribution group')


class Origin18(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class DistributionGroupResponse(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin18 = Field(
        ..., description='The creation origin of this distribution group'
    )


class DistributionGroupTesterGetResponse(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The full name of the tester. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the tester')
    name: str = Field(
        ..., description='The unique name that is used to identify the tester.'
    )


class DistributionGroupUserDeleteResponse(BaseModel):
    code: Optional[str] = Field(None, description='The code of the result')
    message: Optional[int] = Field(None, description='The message of the result')
    status: int = Field(..., description='The status code of the result')
    user_email: Optional[str] = Field(None, description='The email of the user')


class DistributionGroupUserGetResponse(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: Optional[UUID] = Field(None, description='The unique id (UUID) of the user')
    invite_pending: Optional[bool] = Field(
        None,
        description='Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".',
    )
    name: Optional[str] = Field(
        None, description='The unique name that is used to identify the user.'
    )


class DistributionGroupUserPostResponse(BaseModel):
    code: Optional[str] = Field(None, description='The code of the result')
    invite_pending: Optional[bool] = Field(
        None,
        description='Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".',
    )
    message: Optional[str] = Field(None, description='The message of the result')
    status: int = Field(..., description='The status code of the result')
    user_email: Optional[str] = Field(None, description='The email of the user')


class DistributionGroupUserRequest(BaseModel):
    user_emails: Optional[List[str]] = Field(
        None, description='The list of emails of the users', min_length=1
    )


class AadGroup1(BaseModel):
    aad_group_id: Optional[UUID] = Field(
        None, description='The AAD unique id (UUID) of the AAD group.'
    )
    display_name: Optional[str] = Field(
        None, description='The display name of the AAD group'
    )
    id: Optional[UUID] = Field(
        None, description='The internal unique id (UUID) of the AAD group.'
    )


class DistributionGroupWithUsersResponse(BaseModel):
    aad_groups: Optional[List[AadGroup1]] = Field(
        None, description='The distribution group aad groups'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: Optional[bool] = Field(
        None, description='Whether the distribution group is public'
    )
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    notified_user_count: float = Field(
        ...,
        description='The count of non-pending users in the distribution group who will be notified by new releases',
    )
    total_groups_count: Optional[float] = Field(
        None, description='The count of aad groups in the distribution group'
    )
    total_user_count: float = Field(
        ..., description='The count of users in the distribution group'
    )
    users: List[User] = Field(..., description='The distribution group users')


class DistributionGroupWithoutIsLatest(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )


class DistributionGroupsUserVerifyRequest(BaseModel):
    distribution_group_ids: List[UUID] = Field(
        ..., description='An array of distribution group ids'
    )


class Destination2(BaseModel):
    id: str
    type: Type19


class DistributionRequest(BaseModel):
    destinations: Optional[List[Destination2]] = Field(
        None,
        description='Array of objects {id:string, type:string} with "id" being the distribution group ID, store ID, or tester email, and "type" being "group", "store", or "tester"',
    )
    mandatoryUpdate: Optional[bool] = None
    notifyTesters: Optional[bool] = True
    releaseNotes: Optional[str] = Field(None, description='The release notes')


class DistributionResponse(BaseModel):
    status: Optional[str] = Field(None, description='Status of the Request')
    upload_id: Optional[str] = Field(None, description='A unique ID of the upload')


class DistributionSettingsResponse(BaseModel):
    default_public: bool = Field(
        ...,
        description='Is this app using the "Default to Public Distribution Groups" logic',
    )


class Type21(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class DistributionStartSessionLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type21 = Field(..., description='Log type.\n')
    distribution_group_id: UUID = Field(..., description='Distribution Group ID.\n')


class Type22(Enum):
    intune = 'intune'
    googleplay = 'googleplay'
    apple = 'apple'
    none = 'none'


class DistributionStore1(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution store.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type22] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution store.',
    )


class DistributionStoreWithoutIsLatest(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution store.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type22] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )


class DownloadContainer(BaseModel):
    uri: str = Field(..., description='Download URI')


class EmailVerificationRequest(BaseModel):
    token: str = Field(
        ..., description='The verification token that was sent to the user'
    )


class Error2(BaseModel):
    code: Optional[Code1] = Field(
        None,
        description='The status code return by the API. It can be 400 or 403 or 500.',
    )
    message: Optional[str] = Field(
        None, description='The reason for the request failed.'
    )


class Error1(BaseModel):
    error: Optional[Error2] = None


class ErrorAppBuilds(BaseModel):
    appBuilds: Optional[List[str]] = None


class ErrorAttachment(BaseModel):
    appId: Optional[str] = None
    attachmentId: Optional[str] = None
    blobLocation: Optional[str] = None
    contentType: Optional[str] = None
    crashId: Optional[str] = None
    createdTime: Optional[datetime_aliased] = None
    fileName: Optional[str] = None
    size: Optional[int] = None


class ErrorAttachmentLocation(BaseModel):
    uri: Optional[str] = None


class ErrorAttachmentText(BaseModel):
    content: Optional[str] = None


class ErrorAttachments(RootModel[List[ErrorAttachment]]):
    root: List[ErrorAttachment]


class Error3(BaseModel):
    count: Optional[int] = Field(None, description='count of the object')
    datetime: Optional[str] = Field(None, description='the ISO 8601 datetime')


class ErrorCounts(BaseModel):
    count: Optional[int] = Field(None, description='total error count')
    errors: Optional[List[Error3]] = Field(
        None, description='the total error count for day'
    )


class ErrorDateTimeCounts(BaseModel):
    count: Optional[int] = Field(None, description='count of the object')
    datetime: Optional[str] = Field(None, description='the ISO 8601 datetime')


class ErrorDateTimePercentages(BaseModel):
    datetime: Optional[str] = Field(None, description='the ISO 8601 datetime')
    percentage: Optional[float] = Field(None, description='percentage of the object')


class ErrorDeleteCounter(BaseModel):
    appId: Optional[str] = None
    attachmentsDeleted: Optional[int] = None
    blobsFailed: Optional[int] = None
    blobsSucceeded: Optional[int] = None
    errorGroupId: Optional[str] = None
    errorId: Optional[str] = None
    errorsDeleted: Optional[int] = None


class Code3(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class ErrorDetails(BaseModel):
    code: Code3
    message: str


class Code4(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'


class ErrorDetailsv2(BaseModel):
    code: Code4
    message: str


class ErrorDownload(BaseModel):
    pass


class ErrorDownloadLink(BaseModel):
    link: str


class DailyPercentage1(BaseModel):
    datetime: Optional[str] = Field(None, description='the ISO 8601 datetime')
    percentage: Optional[float] = Field(None, description='percentage of the object')


class ErrorFreeDevicePercentages(BaseModel):
    averagePercentage: Optional[float] = Field(None, description='Average percentage')
    dailyPercentages: Optional[List[DailyPercentage1]] = Field(
        None, description='The error-free percentage per day.'
    )


class State6(Enum):
    open = 'open'
    closed = 'closed'
    ignored = 'ignored'


class ReasonFrame2(BaseModel):
    appCode: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    classMethod: Optional[bool] = Field(None, description='is a class method')
    className: Optional[str] = Field(None, description='name of the class')
    codeFormatted: Optional[str] = Field(None, description='Formatted frame string')
    codeRaw: Optional[str] = Field(None, description='Unformatted Frame string')
    exceptionType: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    frameworkName: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    methodParams: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    osExceptionType: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class ErrorGroup(BaseModel):
    annotation: Optional[str] = None
    state: State6
    appBuild: Optional[str] = None
    appVersion: str
    codeRaw: Optional[str] = None
    count: int
    deviceCount: int
    errorGroupId: str
    exceptionAppCode: Optional[bool] = None
    exceptionClassMethod: Optional[bool] = None
    exceptionClassName: Optional[str] = None
    exceptionFile: Optional[str] = None
    exceptionLine: Optional[str] = None
    exceptionMessage: Optional[str] = None
    exceptionMethod: Optional[str] = None
    exceptionType: Optional[str] = None
    firstOccurrence: datetime_aliased
    hidden: Optional[bool] = None
    lastOccurrence: datetime_aliased
    reasonFrames: Optional[List[ReasonFrame2]] = None


class ReasonFrame3(BaseModel):
    appCode: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    classMethod: Optional[bool] = Field(None, description='is a class method')
    className: Optional[str] = Field(None, description='name of the class')
    codeFormatted: Optional[str] = Field(None, description='Formatted frame string')
    codeRaw: Optional[str] = Field(None, description='Unformatted Frame string')
    exceptionType: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    frameworkName: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    methodParams: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    osExceptionType: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class ErrorGroupListItem(BaseModel):
    appBuild: Optional[str] = None
    appVersion: str
    codeRaw: Optional[str] = None
    count: int
    deviceCount: int
    errorGroupId: str
    exceptionAppCode: Optional[bool] = None
    exceptionClassMethod: Optional[bool] = None
    exceptionClassName: Optional[str] = None
    exceptionFile: Optional[str] = None
    exceptionLine: Optional[str] = None
    exceptionMessage: Optional[str] = None
    exceptionMethod: Optional[str] = None
    exceptionType: Optional[str] = None
    firstOccurrence: datetime_aliased
    hidden: Optional[bool] = None
    lastOccurrence: datetime_aliased
    reasonFrames: Optional[List[ReasonFrame3]] = None
    annotation: Optional[str] = None
    state: State6


class ErrorGroupModel(BaseModel):
    errorCount: Optional[int] = Field(None, description='count of errors in a model')
    modelCode: Optional[str] = Field(None, description='model code')
    modelName: Optional[str] = Field(None, description='model name')


class Model5(BaseModel):
    errorCount: Optional[int] = Field(None, description='count of errors in a model')
    modelCode: Optional[str] = Field(None, description='model code')
    modelName: Optional[str] = Field(None, description='model name')


class ErrorGroupModels(BaseModel):
    errorCount: Optional[int] = None
    models: Optional[List[Model5]] = None


class ErrorGroupOperatingSystem(BaseModel):
    errorCount: Optional[int] = Field(None, description='count of OS')
    operatingSystemName: Optional[str] = Field(None, description='OS name')


class OperatingSystem1(BaseModel):
    errorCount: Optional[int] = Field(None, description='count of OS')
    operatingSystemName: Optional[str] = Field(None, description='OS name')


class ErrorGroupOperatingSystems(BaseModel):
    errorCount: Optional[int] = None
    operatingSystems: Optional[List[OperatingSystem1]] = None


class ErrorGroupState(BaseModel):
    annotation: Optional[str] = None
    state: State6


class ReasonFrame4(BaseModel):
    appCode: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    classMethod: Optional[bool] = Field(None, description='is a class method')
    className: Optional[str] = Field(None, description='name of the class')
    codeFormatted: Optional[str] = Field(None, description='Formatted frame string')
    codeRaw: Optional[str] = Field(None, description='Unformatted Frame string')
    exceptionType: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    frameworkName: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    methodParams: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    osExceptionType: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class ErrorGroup1(BaseModel):
    appBuild: Optional[str] = None
    appVersion: str
    codeRaw: Optional[str] = None
    count: int
    deviceCount: int
    errorGroupId: str
    exceptionAppCode: Optional[bool] = None
    exceptionClassMethod: Optional[bool] = None
    exceptionClassName: Optional[str] = None
    exceptionFile: Optional[str] = None
    exceptionLine: Optional[str] = None
    exceptionMessage: Optional[str] = None
    exceptionMethod: Optional[str] = None
    exceptionType: Optional[str] = None
    firstOccurrence: datetime_aliased
    hidden: Optional[bool] = None
    lastOccurrence: datetime_aliased
    reasonFrames: Optional[List[ReasonFrame4]] = None
    annotation: Optional[str] = None
    state: State6


class ErrorGroups(BaseModel):
    errorGroups: Optional[List[ErrorGroup1]] = None
    nextLink: Optional[str] = None


class ReasonFrame5(BaseModel):
    appCode: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    classMethod: Optional[bool] = Field(None, description='is a class method')
    className: Optional[str] = Field(None, description='name of the class')
    codeFormatted: Optional[str] = Field(None, description='Formatted frame string')
    codeRaw: Optional[str] = Field(None, description='Unformatted Frame string')
    exceptionType: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    frameworkName: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    methodParams: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    osExceptionType: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class ErrorGroup2(BaseModel):
    appBuild: Optional[str] = None
    appVersion: str
    codeRaw: Optional[str] = None
    count: int
    deviceCount: int
    errorGroupId: str
    exceptionAppCode: Optional[bool] = None
    exceptionClassMethod: Optional[bool] = None
    exceptionClassName: Optional[str] = None
    exceptionFile: Optional[str] = None
    exceptionLine: Optional[str] = None
    exceptionMessage: Optional[str] = None
    exceptionMethod: Optional[str] = None
    exceptionType: Optional[str] = None
    firstOccurrence: datetime_aliased
    hidden: Optional[bool] = None
    lastOccurrence: datetime_aliased
    reasonFrames: Optional[List[ReasonFrame5]] = None
    annotation: Optional[str] = None
    state: State6


class ErrorGroupsSearchResult(BaseModel):
    errorGroups: Optional[List[ErrorGroup2]] = None
    hasMoreResults: Optional[bool] = None


class ErrorLocation(BaseModel):
    uri: Optional[str] = None


class Type24(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class ErrorLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type24 = Field(..., description='Log type.\n')
    app_launch_toffset: Optional[int] = Field(
        None,
        description='Corresponds to the number of milliseconds elapsed between the time the error occurred and the app was launched.\n',
    )
    id: UUID = Field(..., description='Error identifier.')
    session_id: UUID = Field(..., description='Session ID.\n')


class ErrorLogDiagnostics(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type24 = Field(..., description='Log type.\n')
    app_launch_toffset: Optional[int] = Field(
        None,
        description='Corresponds to the number of milliseconds elapsed between the time the error occurred and the app was launched.\n',
    )
    id: UUID = Field(..., description='Error identifier.')
    session_id: UUID = Field(..., description='Session ID.\n')


class Code5(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Error4(BaseModel):
    code: Code5
    message: str


class ErrorResponse(BaseModel):
    error: Error4


class Code6(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'


class Error5(BaseModel):
    code: Code6
    message: str


class ErrorResponsev2(BaseModel):
    error: Error5


class RetentionInDays(Enum):
    integer_28 = 28


class ErrorRetentionSettings(BaseModel):
    retention_in_days: RetentionInDays


class Error6(BaseModel):
    country: Optional[str] = None
    deviceName: Optional[str] = None
    errorId: Optional[str] = None
    hasAttachments: Optional[bool] = None
    hasBreadcrumbs: Optional[bool] = None
    language: Optional[str] = None
    osType: Optional[str] = None
    osVersion: Optional[str] = None
    timestamp: Optional[datetime_aliased] = None
    userId: Optional[str] = None


class ErrorsSearchResult(BaseModel):
    errors: Optional[List[Error6]] = None
    hasMoreResults: Optional[bool] = None


class Event(BaseModel):
    count: Optional[int] = None
    count_per_device: Optional[float] = None
    count_per_session: Optional[float] = None
    device_count: Optional[int] = None
    id: Optional[str] = None
    name: Optional[str] = None
    previous_count: Optional[int] = Field(
        None, description='The event count of previous time range of the event.'
    )
    previous_device_count: Optional[int] = Field(
        None, description='The device count of previous time range of the event.'
    )


class CountItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class EventCount(BaseModel):
    count: Optional[List[CountItem]] = None
    previous_total_count: Optional[int] = None
    total_count: Optional[int] = None


class CountPerDeviceItem(BaseModel):
    count: Optional[float] = Field(None, description='Decimal count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class EventCountPerDevice(BaseModel):
    avg_count_per_device: Optional[float] = None
    count_per_device: Optional[List[CountPerDeviceItem]] = None
    previous_avg_count_per_device: Optional[float] = None


class CountPerSessionItem(BaseModel):
    count: Optional[float] = Field(None, description='Decimal count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class EventCountPerSession(BaseModel):
    avg_count_per_session: Optional[float] = None
    count_per_session: Optional[List[CountPerSessionItem]] = None
    previous_avg_count_per_session: Optional[float] = None


class DevicesCountItem(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class EventDeviceCount(BaseModel):
    devices_count: Optional[List[DevicesCountItem]] = None
    previous_total_devices_with_event: Optional[int] = None
    total_devices: Optional[int] = None
    total_devices_with_event: Optional[int] = None


class EventLog(BaseModel):
    properties: Optional[Dict[str, str]] = Field(
        None, description='Additional key/value pair parameters.\n'
    )
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type24 = Field(..., description='Log type.\n')
    id: UUID = Field(..., description='Unique identifier for this event.\n')
    name: str = Field(..., description='Name of the event.\n')
    session_id: UUID = Field(..., description='Session ID.\n')


class EventLogDiagnostics(BaseModel):
    properties: Optional[Dict[str, str]] = Field(
        None, description='Additional key/value pair parameters.\n'
    )
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type24 = Field(..., description='Log type.\n')
    id: UUID = Field(..., description='Unique identifier for this event.\n')
    name: str = Field(..., description='Name of the event.\n')
    session_id: UUID = Field(..., description='Session ID.\n')


class EventProperties(BaseModel):
    event_properties: Optional[List[str]] = None


class EventPropertyValue(BaseModel):
    count: Optional[int] = Field(
        None, description='The count of the the event property value.'
    )
    name: Optional[str] = Field(None, description='The event property value name.')
    previous_count: Optional[int] = Field(
        None,
        description='The count of previous time range of the event property value.',
    )


class Value5(BaseModel):
    count: Optional[int] = Field(
        None, description='The count of the the event property value.'
    )
    name: Optional[str] = Field(None, description='The event property value name.')
    previous_count: Optional[int] = Field(
        None,
        description='The count of previous time range of the event property value.',
    )


class EventPropertyValues(BaseModel):
    total: Optional[int] = Field(None, description='The total property value counts.')
    values: Optional[List[Value5]] = Field(
        None, description='The event property values.'
    )


class EventResponseResult(BaseModel):
    request_id: str = Field(..., description='Unique request identifier for tracking')


class EventType6(Enum):
    crash_newCrashGroupCreated = 'crash_newCrashGroupCreated'


class Value6(Enum):
    Disabled = 'Disabled'
    Individual = 'Individual'
    Daily = 'Daily'
    DailyAndIndividual = 'DailyAndIndividual'
    Default = 'Default'


class EventSetting(BaseModel):
    default_value: Optional[DefaultValue] = Field(
        None, description='Default frequency of event'
    )
    event_type: EventType6 = Field(..., description='Event Name')
    value: Value6 = Field(..., description='Frequency of event')


class Events(BaseModel):
    events: Optional[List[Event]] = None
    total: Optional[int] = Field(None, description='The total count of events.')
    total_devices: Optional[int] = Field(
        None, description='The active device over this period.'
    )


class Frame2(BaseModel):
    address: Optional[str] = Field(None, description='address of the frame')
    app_code: bool = Field(..., description="this line isn't from any framework")
    class_method: Optional[bool] = Field(None, description='is a class method')
    class_name: Optional[str] = Field(None, description='name of the class')
    code_formatted: str = Field(..., description='Formatted frame string')
    code_raw: str = Field(..., description='Raw frame string')
    file: Optional[str] = Field(None, description='name of the file')
    framework_name: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    method_params: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    relevant: Optional[bool] = Field(None, description='frame should be shown always')


class Exception(BaseModel):
    frames: List[Frame2] = Field(..., description='frames of the excetpion')
    inner_exceptions: Optional[List[Exception]] = None
    platform: Optional[Platform6] = Field(
        None, description='SDK/Platform this thread is beeing generated from'
    )
    reason: Optional[str] = Field(None, description='Reason of the exception')
    relevant: Optional[bool] = Field(None, description='relevant exception (crashed)')
    type: Optional[str] = Field(
        None,
        description='Type of the exception (NSSomethingException, NullPointerException)',
    )


class ExportEntity(Enum):
    crashes = 'crashes'
    errors = 'errors'
    attachments = 'attachments'
    no_logs = 'no_logs'


class Type28(Enum):
    blob_storage_connection_string = 'blob_storage_connection_string'
    application_insights_instrumentation_key = (
        'application_insights_instrumentation_key'
    )
    blob_storage_linked_subscription = 'blob_storage_linked_subscription'
    application_insights_linked_subscription = (
        'application_insights_linked_subscription'
    )


class BlobPathFormatKind(Enum):
    WithoutAppId = 'WithoutAppId'
    WithAppId = 'WithAppId'


class ExportBlobConfiguration(BaseModel):
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type28 = Field(..., description='Type of export configuration')
    blob_path_format_kind: Optional[BlobPathFormatKind] = Field(
        None,
        description="The path to the blob when enum set to 'WithoutAppId' is 'year/month/day/hour/minute' and when set to 'WithAppId' is 'appId/year/month/day/hour/minute'",
    )


class ExportConfiguration(BaseModel):
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type28 = Field(..., description='Type of export configuration')


class ExportConfigurationAppInsightsKey(BaseModel):
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type28 = Field(..., description='Type of export configuration')
    instrumentation_key: str = Field(
        ..., description='Instrumentation key for Application Insights resource'
    )


class ExportConfigurationAppInsightsLinkedSubscription(BaseModel):
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type28 = Field(..., description='Type of export configuration')
    subscription_id: str = Field(
        ..., description='Id of customer subscription linked in App Center'
    )


class ExportConfigurationBlobStorageConnectionString(BaseModel):
    blob_path_format_kind: Optional[BlobPathFormatKind] = Field(
        None,
        description="The path to the blob when enum set to 'WithoutAppId' is 'year/month/day/hour/minute' and when set to 'WithAppId' is 'appId/year/month/day/hour/minute'",
    )
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type28 = Field(..., description='Type of export configuration')
    connection_string: str = Field(
        ..., description='Connection string for blob storage account'
    )


class ExportConfigurationBlobStorageLinkedSubscription(BaseModel):
    blob_path_format_kind: Optional[BlobPathFormatKind] = Field(
        None,
        description="The path to the blob when enum set to 'WithoutAppId' is 'year/month/day/hour/minute' and when set to 'WithAppId' is 'appId/year/month/day/hour/minute'",
    )
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type28 = Field(..., description='Type of export configuration')
    subscription_id: str = Field(
        ..., description='Id of customer subscription linked in App Center'
    )


class ExportConfiguration1(BaseModel):
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type28 = Field(..., description='Type of export configuration')


class ExportType(Enum):
    BlobStorage = 'BlobStorage'
    AppInsights = 'AppInsights'


class State11(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'
    Pending = 'Pending'
    Deleted = 'Deleted'
    Invalid = 'Invalid'


class Value7(BaseModel):
    creation_time: str = Field(..., description='Creation time in ISO 8601 format')
    export_configuration: Optional[ExportConfiguration1] = Field(
        None, description='Export configuration', discriminator='type'
    )
    export_entities: Optional[List[ExportEntity]] = None
    export_type: ExportType = Field(
        ..., description='Target resource type of export configuration'
    )
    id: str = Field(..., description='Export configuration id')
    last_run_time: Optional[str] = Field(
        None,
        description='Latest time in ISO 8601 format when export completed successfully',
    )
    resource_group: Optional[str] = Field(
        None, description='resource group for the storage account/App Insights resource'
    )
    resource_name: Optional[str] = Field(
        None, description='Storage accout or Appinsights resource name'
    )
    state: State11 = Field(..., description='State of the export job')
    state_info: Optional[str] = Field(
        None, description='Additional information about export configuration state'
    )


class ExportConfigurationListResult(BaseModel):
    nextLink: Optional[str] = None
    total: Optional[int] = Field(None, description='the total count of exports')
    values: List[Value7]


class ExportConfiguration2(BaseModel):
    backfill: Optional[bool] = Field(
        None,
        description='Field to determine if backfilling should occur. The default value is true. If set to false export starts from date and time of config creation.',
    )
    export_entities: Optional[List[ExportEntity]] = None
    resource_group: Optional[str] = Field(
        None, description='The resource group name on azure'
    )
    resource_name: Optional[str] = Field(None, description='The resource name on azure')
    type: Type28 = Field(..., description='Type of export configuration')


class ExportConfigurationResult(BaseModel):
    creation_time: str = Field(..., description='Creation time in ISO 8601 format')
    export_configuration: Optional[ExportConfiguration2] = Field(
        None, description='Export configuration', discriminator='type'
    )
    export_entities: Optional[List[ExportEntity]] = None
    export_type: ExportType = Field(
        ..., description='Target resource type of export configuration'
    )
    id: str = Field(..., description='Export configuration id')
    last_run_time: Optional[str] = Field(
        None,
        description='Latest time in ISO 8601 format when export completed successfully',
    )
    resource_group: Optional[str] = Field(
        None, description='resource group for the storage account/App Insights resource'
    )
    resource_name: Optional[str] = Field(
        None, description='Storage accout or Appinsights resource name'
    )
    state: State11 = Field(..., description='State of the export job')
    state_info: Optional[str] = Field(
        None, description='Additional information about export configuration state'
    )


class ExternalRepositoryProvider(Enum):
    github = 'github'


class AppCategory(BaseModel):
    name: Optional[str] = Field(None, description='display name for the app category')


class TargetAudience(BaseModel):
    name: Optional[str] = Field(
        None, description='display name for the target audience/group'
    )


class IntuneDetails(BaseModel):
    app_category: Optional[AppCategory] = None
    secret_json: Optional[SecretJson] = None
    target_audience: Optional[TargetAudience] = None
    tenant_id: Optional[str] = Field(None, description='tenant id of the intune store')


class Track(Enum):
    production = 'production'
    alpha = 'alpha'
    beta = 'beta'
    testflight_internal = 'testflight-internal'
    testflight_external = 'testflight-external'


class Type36(Enum):
    googleplay = 'googleplay'
    apple = 'apple'
    intune = 'intune'


class ExternalStoreRequest(BaseModel):
    intune_details: Optional[IntuneDetails] = None
    name: Optional[str] = Field(
        None,
        description='name of the store. In case of googleplay, and Apple store this is fixed to Production.',
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.',
    )
    track: Optional[Track] = Field(
        None,
        description='track of the store. Can be production, alpha & beta for googleplay. Can be production, testflight-internal & testflight-external for Apple Store.',
    )
    type: Optional[Type36] = Field(None, description='store Type')


class AppCategory1(BaseModel):
    id: Optional[str] = Field(None, description='ID for the category.')
    name: Optional[str] = Field(None, description='display name for the app category')


class TargetAudience1(BaseModel):
    id: Optional[str] = Field(None, description='ID for the target audience/group.')
    name: Optional[str] = Field(
        None, description='display name for the target audience/group'
    )


class IntuneDetails1(BaseModel):
    app_category: Optional[AppCategory1] = None
    target_audience: Optional[TargetAudience1] = None


class ExternalStoreResponse(BaseModel):
    created_by: Optional[str] = Field(
        None, description='The ID of the principal that created the store.'
    )
    created_by_principal_type: Optional[str] = Field(
        None, description='The type of the principal that created the store.'
    )
    id: Optional[str] = Field(None, description='Store id')
    intune_details: Optional[IntuneDetails1] = Field(
        None, description='Store details for intune'
    )
    name: Optional[str] = Field(None, description='Store Name')
    service_connection_id: Optional[str] = Field(
        None,
        description='Id for the shared service connection. In case of Apple / GooglePlay stores, this connection will be used to connect to the Apple / Google stores in App Center.',
    )
    track: Optional[Track] = Field(None, description='Store track')
    type: Optional[str] = Field(None, description='Store Type')


class ExternalUserRequest(BaseModel):
    app_invitation: Optional[str] = Field(
        None, description='The token of the app invitation which lead to signup'
    )
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    name: Optional[str] = Field(
        None,
        description='The unique name that is used to identify the user. If no explicit value is given, a default will be auto-generated from the `display_name` value',
    )
    organization_invitation: Optional[str] = Field(
        None,
        description='The token of the organization invitation which lead to signup',
    )
    tester_invitation: Optional[str] = Field(
        None, description='The token of the test invitation which lead to signup'
    )


class ExternallyHostedReleaseCreateRequest(BaseModel):
    build_number: Optional[str] = Field(
        None, description='The build number of the uploaded binary'
    )
    build_version: str = Field(
        ..., description='The build version of the uploaded binary'
    )
    external_download_url: str = Field(
        ..., description="The external URL to the release's binary."
    )


class Failure(BaseModel):
    message: str


class FeatureCreateRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='The friendly name of the feature'
    )
    display_name: str = Field(
        ..., description='The full (friendly) name of the feature.'
    )
    name: str = Field(..., description='The unique name of the feature')
    state: Optional[int] = Field(None, description='The state of the feature')


class FeatureFlagsResponse(BaseModel):
    feature_flags: List[str]


class FeaturePatchRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='The friendly name of the feature'
    )
    display_name: Optional[str] = Field(
        None, description='The full (friendly) name of the feature.'
    )
    state: Optional[int] = Field(None, description='The state of the feature')


class FeatureResponse(BaseModel):
    created_at: Optional[str] = Field(
        None, description='The creation date of the feature'
    )
    description: Optional[str] = Field(
        None, description='The description of the feature'
    )
    display_name: str = Field(..., description='The friendly name of the feature')
    name: str = Field(..., description='The unique name of the feature')
    state: int = Field(
        ..., description='The state (unset, enabled, disabled) of the feature'
    )
    updated_at: Optional[str] = Field(
        None, description='The date the feature was last updated at'
    )


class FileAsset(BaseModel):
    id: Optional[str] = None
    location: Optional[str] = None
    token: Optional[str] = None
    uploadDomain: Optional[str] = None
    uploadWindowLocation: Optional[str] = None
    urlEncodedToken: Optional[str] = None


class FileValidationDetails(BaseModel):
    certificateUploadId: Optional[str] = None
    p12password: str


class FilterReleasesContainer(BaseModel):
    releases: Optional[List[Release1]] = None


class Version(BaseModel):
    build: str = Field(..., description='App build number.\n')
    version: str = Field(..., description='App version.\n')


class FilterVersionsContainer(BaseModel):
    versions: Optional[List[Version]] = None


class Type37(Enum):
    org = 'org'
    user = 'user'


class Owner9(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type37 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class Origin19(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class Platform9(Enum):
    Java = 'Java'
    Objective_C_Swift = 'Objective-C-Swift'
    UWP = 'UWP'
    Cordova = 'Cordova'
    React_Native = 'React-Native'
    Unity = 'Unity'
    Electron = 'Electron'
    Xamarin = 'Xamarin'
    WPF = 'WPF'
    WinForms = 'WinForms'
    Unknown = 'Unknown'
    Custom = 'Custom'


class App3(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner9 = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin19 = Field(..., description='The creation origin of this app')
    platform: Platform9 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class Origin20(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class Organization(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin20 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class GDPRInvitationDetailResponse(BaseModel):
    app: Optional[App3] = None
    invitation_id: UUID = Field(..., description='The id of the invitation')
    organization: Optional[Organization] = None


class GDPRPurgeVerifyRequest(BaseModel):
    id: str = Field(..., description='deployment id')
    key: str = Field(..., description='deployment key')


class GDPRPurgeVerifyResponse(BaseModel):
    success: bool = Field(
        ..., description='indicate whether GDPR purge operation succeeds or not'
    )


class GDPRValidationRequest(BaseModel):
    hockeyapp_release_ids: Optional[List[int]] = Field(
        None, description='a list of release ids to validate (HA flow)'
    )
    release_ids: List[int] = Field(
        ..., description='a list of release ids to validate (AC flow)'
    )
    release_upload_ids: Optional[List[str]] = Field(
        None, description='a list of release uploads ids to validate'
    )


class GdprVerificationResult(BaseModel):
    message: Optional[str] = Field(
        None, description='Optional error message if the verification failed.'
    )
    status: Optional[bool] = Field(
        None,
        description='Verification status. True means that the verification was successfull.',
    )


class GeneralDistributionGroupDetailsResponse(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin20 = Field(
        ..., description='The creation origin of this distribution group'
    )
    is_shared: bool = Field(
        ..., description='Whether the distribution group is shared group or not'
    )
    owner_app_id: Optional[UUID] = Field(
        None,
        description='If distribution group is owned by an app, this is the unique app ID',
    )
    owner_org_id: Optional[UUID] = Field(
        None,
        description='If distribution group is owned by an org, this is the unique org ID',
    )


class Type38(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class GenericLog(BaseModel):
    account_id: Optional[str] = Field(
        None, description='Account ID of the authenticated user.\n'
    )
    auth_provider: Optional[str] = Field(None, description='Auth service provider.\n')
    device: Device = Field(..., description='Device characteristics.')
    event_id: Optional[str] = Field(None, description='Event ID.\n')
    event_name: Optional[str] = Field(None, description='Event name.\n')
    install_id: UUID = Field(..., description='Install ID.\n')
    message_id: Optional[str] = Field(None, description='Message ID.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='event specific properties.\n'
    )
    session_id: Optional[UUID] = Field(None, description='Session ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type38 = Field(..., description='Log type.\n')


class Log(BaseModel):
    account_id: Optional[str] = Field(
        None, description='Account ID of the authenticated user.\n'
    )
    auth_provider: Optional[str] = Field(None, description='Auth service provider.\n')
    device: Device = Field(..., description='Device characteristics.')
    event_id: Optional[str] = Field(None, description='Event ID.\n')
    event_name: Optional[str] = Field(None, description='Event name.\n')
    install_id: UUID = Field(..., description='Install ID.\n')
    message_id: Optional[str] = Field(None, description='Message ID.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='event specific properties.\n'
    )
    session_id: Optional[UUID] = Field(None, description='Session ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type38 = Field(..., description='Log type.\n')


class GenericLogContainer(BaseModel):
    exceeded_max_limit: Optional[bool] = Field(
        None,
        description='indicates if the number of available logs are more than the max allowed return limit(100).',
    )
    last_received_log_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='the timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.',
    )
    logs: List[Log] = Field(..., description='the list of logs', min_length=0)


class Log1(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    event_id: Optional[str] = Field(None, description='Event ID.\n')
    event_name: Optional[str] = Field(None, description='Event name.\n')
    install_id: UUID = Field(..., description='Install ID.\n')
    message_id: Optional[str] = Field(None, description='Message ID.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='event specific properties.\n'
    )
    session_id: Optional[UUID] = Field(None, description='Session ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type38 = Field(..., description='Log type.\n')


class GenericLogContainerDiagnostics(BaseModel):
    exceeded_max_limit: Optional[bool] = Field(
        None,
        description='indicates if the number of available logs are more than the max allowed return limit(100).',
    )
    last_received_log_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='the timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.',
    )
    logs: List[Log1] = Field(..., description='the list of logs', min_length=0)


class GenericLogDiagnostics(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    event_id: Optional[str] = Field(None, description='Event ID.\n')
    event_name: Optional[str] = Field(None, description='Event name.\n')
    install_id: UUID = Field(..., description='Install ID.\n')
    message_id: Optional[str] = Field(None, description='Message ID.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='event specific properties.\n'
    )
    session_id: Optional[UUID] = Field(None, description='Session ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type38 = Field(..., description='Log type.\n')


class GetInAppUpdateTokenResponse(BaseModel):
    token: str = Field(
        ..., description='The api token generated will not be accessible again'
    )


class GetOrCreateRepositoryProviderMappingRequest(BaseModel):
    external_account_name: Optional[str] = Field(
        None,
        description='The account name given by the external provider. If provided, create an organization and the mapping. If not, create mapping with user.',
    )


class UploadStatus(Enum):
    uploadStarted = 'uploadStarted'
    uploadFinished = 'uploadFinished'
    readyToBePublished = 'readyToBePublished'
    malwareDetected = 'malwareDetected'
    error = 'error'


class GetReleaseStatusResponse(BaseModel):
    error_details: Optional[str] = Field(
        None,
        description="Details describing what went wrong processing the upload. Will only be set if status = 'error'.",
    )
    id: UUID = Field(..., description='The ID for the upload.')
    release_distinct_id: Optional[float] = Field(
        None,
        description="The distinct ID of the release. Will only be set when the status = 'readyToBePublished'.",
    )
    release_url: Optional[Any] = Field(
        None,
        description="The URL of the release. Will only be set when the status = 'readyToBePublished'.",
    )
    upload_status: UploadStatus = Field(..., description='The current upload status.')


class Release3(BaseModel):
    release: str = Field(..., description='Release Id.\n')
    distribution_group: Optional[str] = Field(
        None, description='Distribution group Id.\n'
    )


class GetReleasesContainer(BaseModel):
    releases: List[Release3] = Field(..., min_length=1)


class AccountType(Enum):
    User = 'User'
    Organization = 'Organization'


class GitHubAccount(BaseModel):
    accountType: Optional[AccountType] = Field(
        None, description='Type of GitHub account'
    )
    id: Optional[int] = Field(None, description='Id of GitHub account')


class GitHubAccountLite(BaseModel):
    id: Optional[str] = Field(None, description='GitHub Account Id')
    login: Optional[str] = Field(None, description='GitHub Account Login Name')
    type: Optional[str] = Field(None, description='GitHub Account Type')
    url: Optional[str] = Field(None, description='GitHub Account Url')


class Type42(Enum):
    org = 'org'
    user = 'user'


class GitHubBillingAccount(BaseModel):
    display_name: str = Field(..., description="The account's display name")
    id: str = Field(..., description='The unique id (UUID) of the account')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type42 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class Repo(BaseModel):
    id: Optional[float] = Field(None, description='The repository id')


class GitHubBranchLite(BaseModel):
    ref: Optional[str] = Field(None, description='The repository name')
    repo: Optional[Repo] = Field(
        None, description='The lite version of GitHub repository'
    )
    sha: Optional[str] = Field(None, description='The discription of repository')


class Account(BaseModel):
    id: Optional[str] = Field(None, description='GitHub Account Id')
    login: Optional[str] = Field(None, description='GitHub Account Login Name')
    type: Optional[str] = Field(None, description='GitHub Account Type')
    url: Optional[str] = Field(None, description='GitHub Account Url')


class GitHubInstallationLite(BaseModel):
    account: Optional[Account] = Field(None, description='The GitHub Installation')
    app_id: Optional[float] = Field(None, description='GitHub Installation App Id')
    id: Optional[float] = Field(None, description='GitHub Installation Id')


class GitHubInstallationRepository(BaseModel):
    clone_url: Optional[str] = Field(
        None, description='URL used to clone the repository'
    )
    default_branch: Optional[str] = Field(
        None, description='The default branch for the repo'
    )
    description: Optional[str] = Field(
        None, description='The discription of repository'
    )
    fork: Optional[bool] = Field(None, description='Whether the repository is a fork')
    language: Optional[str] = Field(None, description='The language in the repository')
    name: Optional[str] = Field(None, description='The repository name')
    updated_at: Optional[str] = Field(None, description='The repository updated time')


class GitHubInstallationRepositories(RootModel[List[GitHubInstallationRepository]]):
    root: List[GitHubInstallationRepository] = Field(
        ...,
        description='A list of the repositories which is accessible by GitHub App Installation',
    )


class GitHubMarketplacePlan(BaseModel):
    id: Optional[int] = Field(None, description='Id of the GitHub plan')


class Account1(BaseModel):
    accountType: Optional[AccountType] = Field(
        None, description='Type of GitHub account'
    )
    id: Optional[int] = Field(None, description='Id of GitHub account')


class Plan10(BaseModel):
    id: Optional[int] = Field(None, description='Id of the GitHub plan')


class GitHubMarketplacePurchase(BaseModel):
    account: Optional[Account1] = Field(None, description='GitHub account information')
    plan: Optional[Plan10] = Field(None, description='GitHub Marketplace plan')


class Base(BaseModel):
    ref: Optional[str] = Field(None, description='The repository name')
    repo: Optional[Repo] = Field(
        None, description='The lite version of GitHub repository'
    )
    sha: Optional[str] = Field(None, description='The discription of repository')


class Head(BaseModel):
    ref: Optional[str] = Field(None, description='The repository name')
    repo: Optional[Repo] = Field(
        None, description='The lite version of GitHub repository'
    )
    sha: Optional[str] = Field(None, description='The discription of repository')


class GitHubPullRequestLite(BaseModel):
    base: Optional[Base] = Field(None, description='The lite version of GitHub branch')
    head: Optional[Head] = Field(None, description='The lite version of GitHub branch')


class GitHubRepositoryLite(BaseModel):
    id: Optional[float] = Field(None, description='The repository id')


class GlobalFeatureFlagsResponse(BaseModel):
    value: Dict[str, str] = Field(
        ...,
        description='The dictionary of global state values indexed by feature flag names',
    )


class GooglePlayConnectionNonSecretResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )


class Data8(BaseModel):
    password: Optional[str] = Field(
        None, description='password to connect to shared connection.'
    )
    username: Optional[str] = Field(
        None, description='username to connect to shared connection.'
    )


class GooglePlayConnectionSecretRequest(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        'credentials',
        description='credential type of the shared connection. Values can be credentials|certificate',
    )
    data: Optional[Data8] = Field(None, description='shared connection details')
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )


class GooglePlayConnectionSecretResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )
    data: Dict[str, Any] = Field(..., description='google play secret details')


class GooglePlayCredentialNonSecretDetailsResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )
    data: Dict[str, Any] = Field(
        ..., description='Google Play credentials non-secret details'
    )


class AdminRole(Enum):
    superAdmin = 'superAdmin'
    admin = 'admin'
    devOps = 'devOps'
    customerSupport = 'customerSupport'
    notAdmin = 'notAdmin'


class GrantAdminRoleRequest(BaseModel):
    admin_role: AdminRole = Field(..., description='The new admin_role')


class HandledError(BaseModel):
    country: Optional[str] = None
    deviceName: Optional[str] = None
    errorId: Optional[str] = None
    hasAttachments: Optional[bool] = None
    hasBreadcrumbs: Optional[bool] = None
    language: Optional[str] = None
    osType: Optional[str] = None
    osVersion: Optional[str] = None
    timestamp: Optional[datetime_aliased] = None
    userId: Optional[str] = None


class ReasonFrame6(BaseModel):
    appCode: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    classMethod: Optional[bool] = Field(None, description='is a class method')
    className: Optional[str] = Field(None, description='name of the class')
    codeFormatted: Optional[str] = Field(None, description='Formatted frame string')
    codeRaw: Optional[str] = Field(None, description='Unformatted Frame string')
    exceptionType: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    frameworkName: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    methodParams: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    osExceptionType: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class HandledErrorDetails(BaseModel):
    country: Optional[str] = None
    deviceName: Optional[str] = None
    errorId: Optional[str] = None
    hasAttachments: Optional[bool] = None
    hasBreadcrumbs: Optional[bool] = None
    language: Optional[str] = None
    osType: Optional[str] = None
    osVersion: Optional[str] = None
    timestamp: Optional[datetime_aliased] = None
    userId: Optional[str] = None
    appLaunchTimestamp: Optional[datetime_aliased] = Field(
        None,
        description="Timestamp when the app was launched, example: '2017-03-13T18:05:42Z'.\n",
    )
    carrierName: Optional[str] = Field(
        None, description='Carrier name (for mobile devices).\n'
    )
    jailbreak: Optional[bool] = Field(
        None, description='Flag indicating if device is jailbroken\n'
    )
    name: Optional[str] = None
    properties: Optional[Dict[str, str]] = None
    reasonFrames: Optional[List[ReasonFrame6]] = None


class Type43(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class HandledErrorLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type43 = Field(..., description='Log type.\n')
    error_id: UUID = Field(..., description='Error ID.\n')


class HandledErrorReasonFrame(BaseModel):
    appCode: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    classMethod: Optional[bool] = Field(None, description='is a class method')
    className: Optional[str] = Field(None, description='name of the class')
    codeFormatted: Optional[str] = Field(None, description='Formatted frame string')
    codeRaw: Optional[str] = Field(None, description='Unformatted Frame string')
    exceptionType: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    frameworkName: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language2] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    methodParams: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    osExceptionType: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class HandledErrors(BaseModel):
    errors: Optional[List[Error6]] = Field(None, description='Errors list.')
    nextLink: Optional[str] = None


class HanledErrorLogDiagnostics(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type43 = Field(..., description='Log type.\n')
    error_id: UUID = Field(..., description='Error ID.\n')


class HasBuildUploadedResponse(BaseModel):
    has_build_uploaded: Optional[bool] = Field(
        None, description='true if a build has been uploaded, false otherwise'
    )


class HasTestflightMetadataResponse(BaseModel):
    has_testflight_metadata: Optional[bool] = Field(
        None, description='true if the app has the testflight metadata, false otherwise'
    )


class HockeyAppCompatibilityReleaseResponse(BaseModel):
    appsize: Optional[int] = None
    bundle_identifier: Optional[str] = None
    device_family: Optional[str] = None
    external: Optional[bool] = None
    id: Optional[int] = None
    install_url: Optional[str] = None
    mandatory: Optional[bool] = None
    minimum_os_version: Optional[str] = None
    notes: Optional[str] = None
    shortversion: Optional[str] = None
    uploaded_at: Optional[str] = None
    version: Optional[str] = None


class ProviderName(Enum):
    github = 'github'
    aad = 'aad'
    facebook = 'facebook'
    google = 'google'


class IdentityProvidersListManagementItem(BaseModel):
    created_at: Optional[str] = Field(None, description='Creation date-time')
    provider_name: Optional[ProviderName] = Field(
        None, description='The name of the identity provider type'
    )
    provider_user_id: Optional[str] = Field(None, description='The external user id')
    updated_at: Optional[str] = Field(None, description='Last update date-time')
    user_id: Optional[str] = Field(None, description='The account id (UUID)')


class IdentityProvidersListManagement(
    RootModel[List[IdentityProvidersListManagementItem]]
):
    root: List[IdentityProvidersListManagementItem] = Field(
        ..., description='The identity providers'
    )


class InternalBulkAppResponse(BaseModel):
    app_name: Optional[str] = Field(None, description='The name of the app')
    owner_display_name: Optional[str] = Field(
        None, description='The display name of the owner'
    )


class PortalSubdomain(Enum):
    install_ = 'install.'


class InternalUserRequest(BaseModel):
    app_invitation: Optional[str] = Field(
        None, description='The token of the app invitation which lead to signup'
    )
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    organization_invitation: Optional[str] = Field(
        None,
        description='The token of the organization invitation which lead to signup',
    )
    password: str = Field(
        ...,
        description='The password of the user. Needs to be at least 8 characters long and contain at least one lower- and one uppercase letter.',
    )
    portal_subdomain: Optional[PortalSubdomain] = Field(
        None,
        description='The sub-domain of the portal from which this request was made. Will be used to build the invitation link.',
    )
    tester_invitation: Optional[str] = Field(
        None, description='The token of the test invitation which lead to signup'
    )


class Status7(Enum):
    Complete = 'Complete'
    NeedsVerification = 'NeedsVerification'


class InternalUserSignupResponse(BaseModel):
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    external_provider: Optional[str] = Field(
        None, description='The name of the external auth provider'
    )
    external_user_id: Optional[str] = Field(
        None, description='The user ID given by the external provider'
    )
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    status: Optional[Status7] = Field(
        None, description='The current status of the user record after signup'
    )


class IntuneAppCategory(BaseModel):
    name: Optional[str] = Field(None, description='display name for the app category')


class IntuneAppCategoryResponse(BaseModel):
    id: Optional[str] = Field(None, description='ID for the category.')
    name: Optional[str] = Field(None, description='display name for the app category')


class IntuneAppsRequest(BaseModel):
    created_month: Optional[str] = Field(None, description='PartitionKey year-month')


class IntuneAppsResponse(BaseModel):
    app_id: Optional[str] = Field(None, description='App id')
    created_month: Optional[str] = Field(None, description='PartitionKey year-month')
    refreshStatus: Optional[str] = Field(None, description='Refresh Status')


class ValueItem(BaseModel):
    displayName: Optional[str] = Field(
        None, description='the display name for the category'
    )
    id: Optional[str] = Field(None, description='the id of the category')
    lastModifiedDateTime: Optional[str] = Field(
        None, description='modified date for category'
    )


class IntuneCategories(BaseModel):
    odata_context: Optional[str] = Field(
        None, alias='odata.context', description='context'
    )
    value: Optional[List[ValueItem]] = Field(
        None, description='categories for intune app'
    )


class IntuneCategoryValue(BaseModel):
    displayName: Optional[str] = Field(
        None, description='the display name for the category'
    )
    id: Optional[str] = Field(None, description='the id of the category')
    lastModifiedDateTime: Optional[str] = Field(
        None, description='modified date for category'
    )


class IntuneGroup(BaseModel):
    displayName: Optional[str] = Field(
        None, description='the display name of the group'
    )
    id: Optional[str] = Field(None, description='the id of the Group')
    securityEnabled: Optional[bool] = Field(
        None, description='species if it is a security group'
    )


class IntuneGroupValue(BaseModel):
    displayName: Optional[str] = Field(
        None, description='the display name of the group'
    )
    id: Optional[str] = Field(None, description='the id of the Group')


class ValueItem1(BaseModel):
    displayName: Optional[str] = Field(
        None, description='the display name of the group'
    )
    id: Optional[str] = Field(None, description='the id of the Group')


class IntuneGroups(BaseModel):
    odata_context: Optional[str] = Field(
        None, alias='odata.context', description='context'
    )
    value: Optional[List[ValueItem1]] = Field(
        None, description='categories for intune app'
    )


class IntuneSecretDetails(BaseModel):
    id_token: Optional[str] = Field(None, description='the id token of user')
    refresh_token: Optional[str] = Field(None, description='the refresh token for user')
    refresh_token_expiry: Optional[str] = Field(
        None, description='the expiry of refresh token'
    )


class AppCategory2(BaseModel):
    name: Optional[str] = Field(None, description='display name for the app category')


class TargetAudience2(BaseModel):
    name: Optional[str] = Field(
        None, description='display name for the target audience/group'
    )


class IntuneStoreRequest(BaseModel):
    app_category: Optional[AppCategory2] = None
    secret_json: Optional[SecretJson] = None
    target_audience: Optional[TargetAudience2] = None
    tenant_id: Optional[str] = Field(None, description='tenant id of the intune store')


class AppCategory3(BaseModel):
    id: Optional[str] = Field(None, description='ID for the category.')
    name: Optional[str] = Field(None, description='display name for the app category')


class TargetAudience3(BaseModel):
    id: Optional[str] = Field(None, description='ID for the target audience/group.')
    name: Optional[str] = Field(
        None, description='display name for the target audience/group'
    )


class IntuneStoreResponse(BaseModel):
    app_category: Optional[AppCategory3] = None
    target_audience: Optional[TargetAudience3] = None


class IntuneTargetAudience(BaseModel):
    name: Optional[str] = Field(
        None, description='display name for the target audience/group'
    )


class IntuneTargetAudienceResponse(BaseModel):
    id: Optional[str] = Field(None, description='ID for the target audience/group.')
    name: Optional[str] = Field(
        None, description='display name for the target audience/group'
    )


class Type45(Enum):
    org = 'org'
    user = 'user'


class Owner10(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type45 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class Origin22(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class App4(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner10 = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin22 = Field(..., description='The creation origin of this app')
    platform: Platform9 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class InvitedBy1(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin22 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission]] = Field(
        None, description='The permissions the user has for the app'
    )


class Origin24(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class Organization1(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin24 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class InvitationDetailResponse(BaseModel):
    app: Optional[App4] = None
    invitation_id: UUID = Field(..., description='The id of the invitation')
    invited_by: InvitedBy1
    organization: Optional[Organization1] = None


class IosAppExtensionInfo(BaseModel):
    name: str = Field(..., description='App extension name')
    targetBundleIdentifier: str = Field(
        ..., description='App extension bundle identifier'
    )


class ItunesAppsRequest(BaseModel):
    cookie: Optional[str] = Field(
        None,
        description='The 30-day session cookie for multi-factor authentication backed accounts.',
    )
    password: Optional[str] = Field(
        None, description='The password for the Apple Developer account.'
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='The service_connection_id of the stored Apple credentials instead of username, password.',
    )
    team_identifier: Optional[str] = Field(
        None, description='Identifier of the team to use when logged in.'
    )
    username: Optional[str] = Field(
        None, description='The username for the Apple Developer account.'
    )


class ItunesTeamsRequest(BaseModel):
    cookie: Optional[str] = Field(
        None,
        description='The 30-day session cookie for multi-factor authentication backed accounts.',
    )
    password: Optional[str] = Field(
        None, description='The password for the Apple Developer account.'
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='The service_connection_id of the stored Apple credentials instead of username, password.',
    )
    username: Optional[str] = Field(
        None, description='The username for the Apple Developer account.'
    )


class ItunesTeamsResponse(BaseModel):
    teamId: Optional[str] = Field(None, description='Itunes team id.')
    teamName: Optional[str] = Field(None, description='Itunes Team Name')


class JavaScriptBranchConfigurationProperties(BaseModel):
    packageJsonPath: Optional[str] = Field(
        None,
        description='Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"',
    )
    reactNativeVersion: Optional[str] = Field(
        None, description='Version of React Native from package.json files'
    )
    runTests: Optional[bool] = Field(
        None,
        description='Whether to run Jest unit tests, via npm test, during the build',
    )


class JavaScriptSolution(BaseModel):
    packageJsonPath: str = Field(
        ..., description='The path to the detected package.json'
    )
    reactNativeVersion: Optional[str] = Field(
        None, description='Version of React Native from package.json files'
    )


class JavascriptSolution(BaseModel):
    packageJsonPath: str = Field(
        ..., description='The path to the detected package.json'
    )
    reactNativeVersion: Optional[str] = Field(
        None, description='Version of React Native from package.json files'
    )


class JavaScriptToolset(BaseModel):
    javascriptSolutions: Optional[List[JavascriptSolution]] = Field(
        None, description='The React Native solutions detected'
    )
    packageJsonPaths: List[str] = Field(
        ..., description='Paths for detected package.json files'
    )


class JiraConnectionNonSecretResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )


class Data9(BaseModel):
    baseUrl: str = Field(..., description='baseUrl to connect to jira instance')
    password: str = Field(..., description='password to connect to jira instance')
    username: str = Field(..., description='username to connect to jira instance')


class JiraConnectionSecretRequest(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        'credentials',
        description='credential type of the shared connection. Values can be credentials|certificate',
    )
    data: Optional[Data9] = Field(None, description='shared connection details')
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )


class Data10(BaseModel):
    baseUrl: str = Field(..., description='baseUrl to connect to jira instance')
    username: str = Field(..., description='username to connect to jira instance')


class JiraConnectionSecretResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )
    data: Data10 = Field(..., description='jira secret details')


class JiraCredentialNonSecretDetailsResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )
    data: Data10 = Field(..., description='Jira credentials non-secret details')


class JiraSecretDetails(BaseModel):
    baseUrl: str = Field(..., description='baseUrl to connect to jira instance')
    password: str = Field(..., description='password to connect to jira instance')
    username: str = Field(..., description='username to connect to jira instance')


class JiraSecretDetailsResponse(BaseModel):
    baseUrl: str = Field(..., description='baseUrl to connect to jira instance')
    username: str = Field(..., description='username to connect to jira instance')


class Language13(BaseModel):
    count: Optional[int] = Field(None, description='Count current of language.')
    language_name: Optional[str] = Field(None, description="Language's name.")
    previous_count: Optional[int] = Field(
        None, description='Count of previous lanugage.'
    )


class Languages(BaseModel):
    languages: Optional[List[Language13]] = None
    total: Optional[int] = None


class LegacyAccount(BaseModel):
    email: Optional[str] = Field(None, description="The calling user's email.")
    linkedProviders: Optional[List[str]] = Field(
        None,
        description='Array of linked authentication providers associated with the account.',
    )
    name: Optional[str] = Field(
        None, description='The account name of the calling user.'
    )


class Account2(BaseModel):
    email: Optional[str] = Field(None, description="The calling user's email.")
    linkedProviders: Optional[List[str]] = Field(
        None,
        description='Array of linked authentication providers associated with the account.',
    )
    name: Optional[str] = Field(
        None, description='The account name of the calling user.'
    )


class LegacyAccountResponse(BaseModel):
    account: Optional[Dict[str, Account2]] = Field(
        None, description='Object containing the account information.'
    )


class Collaborators(BaseModel):
    isCurrentAccount: Optional[bool] = Field(
        None, description='Is current collaborator the same as current account.'
    )
    permission: Optional[str] = Field(
        None, description='Which permission does current account has.'
    )


class LegacyApp(BaseModel):
    collaborators: Optional[Dict[str, Collaborators]] = None
    deployments: Optional[List[str]] = None
    name: Optional[str] = Field(None, description='The app name.')


class App5(BaseModel):
    collaborators: Optional[Dict[str, Collaborators]] = None
    deployments: Optional[List[str]] = None
    name: Optional[str] = Field(None, description='The app name.')


class LegacyAppListResponse(BaseModel):
    apps: Optional[List[App5]] = None


class App6(BaseModel):
    collaborators: Optional[Dict[str, Collaborators]] = None
    deployments: Optional[List[str]] = None
    name: Optional[str] = Field(None, description='The app name.')


class LegacyAppResponse(BaseModel):
    app: Optional[App6] = None


class LegacyAuthenticationResponse(BaseModel):
    authenticated: Optional[bool] = Field(
        None, description='The authentication status of the user.'
    )


class LegacyCodePushApp(BaseModel):
    manuallyProvisionDeployments: Optional[bool] = Field(
        None,
        description='Whether the user provided their own deployments. Not currently in use.',
    )
    name: str = Field(..., description='The app name.')
    os: Optional[str] = Field(None, description='The app os.')
    platform: Optional[str] = Field(None, description='The app platform.')


class LegacyCodePushRelease(BaseModel):
    appVersion: Optional[str] = Field(None, description='The version of the release')
    blobUrl: Optional[str] = Field(
        None, description='Location (URL) of release package'
    )
    diffPackageMap: Optional[Dict[str, Any]] = Field(
        None,
        description='Object containing URL and size of changed package hashes contained in the release',
    )
    isDisabled: Optional[bool] = Field(
        None, description='Flag used to determine if release is disabled'
    )
    isMandatory: Optional[bool] = Field(
        None, description='Flag used to determine if release is mandatory'
    )
    label: Optional[str] = Field(None, description='Release label (aka release name)')
    manifestBlobUrl: Optional[str] = Field(
        None, description="The URL location of the package's manifest file."
    )
    releaseMethod: Optional[str] = Field(
        None, description='Method used to deploy release'
    )
    releasedByUserId: Optional[str] = Field(
        None, description='User ID that triggered most recent release'
    )
    rollout: Optional[int] = Field(
        None, description='Percentage (out of 100) that release is deployed to'
    )
    size: Optional[int] = Field(None, description='Size of release package')
    uploadTime: Optional[int] = Field(
        None, description='Release upload time as epoch Unix timestamp'
    )


class LegacyCodePushReleaseInfo(BaseModel):
    appVersion: Optional[str] = None
    description: Optional[str] = None
    isDisabled: Optional[bool] = None
    isMandatory: Optional[bool] = None
    rollout: Optional[int] = None


class LegacyCodePushReleaseModification(BaseModel):
    packageInfo: Dict[str, Any] = Field(
        ..., description='The release package information'
    )


class Package(BaseModel):
    appVersion: Optional[str] = Field(None, description='The version of the release')
    blobUrl: Optional[str] = Field(
        None, description='Location (URL) of release package'
    )
    diffPackageMap: Optional[Dict[str, Any]] = Field(
        None,
        description='Object containing URL and size of changed package hashes contained in the release',
    )
    isDisabled: Optional[bool] = Field(
        None, description='Flag used to determine if release is disabled'
    )
    isMandatory: Optional[bool] = Field(
        None, description='Flag used to determine if release is mandatory'
    )
    label: Optional[str] = Field(None, description='Release label (aka release name)')
    manifestBlobUrl: Optional[str] = Field(
        None, description="The URL location of the package's manifest file."
    )
    releaseMethod: Optional[str] = Field(
        None, description='Method used to deploy release'
    )
    releasedByUserId: Optional[str] = Field(
        None, description='User ID that triggered most recent release'
    )
    rollout: Optional[int] = Field(
        None, description='Percentage (out of 100) that release is deployed to'
    )
    size: Optional[int] = Field(None, description='Size of release package')
    uploadTime: Optional[int] = Field(
        None, description='Release upload time as epoch Unix timestamp'
    )


class LegacyCodePushReleaseResponse(BaseModel):
    package: Package


class LegacyCodePushStatusMetricMetadata(BaseModel):
    appVersion: Optional[str] = None
    clientUniqueId: Optional[str] = None
    deploymentKey: Optional[str] = None
    label: Optional[str] = None
    previousDeploymentKey: Optional[str] = None
    previousLabelOrAppVersion: Optional[str] = None
    status: Optional[str] = None


class LegacyCollaborator(BaseModel):
    isCurrentAccount: Optional[bool] = Field(
        None, description='Is current collaborator the same as current account.'
    )
    permission: Optional[str] = Field(
        None, description='Which permission does current account has.'
    )


class LegacyCollaborators(BaseModel):
    collaborators: Optional[Dict[str, Collaborators]] = None


class LegacyDeployment(BaseModel):
    createdTime: Optional[int] = Field(
        None,
        description='Time at which the deployment was created as a Unix timestamp.',
    )
    id: Optional[str] = Field(
        None, description='The ID of the deployment (internal use only).'
    )
    key: Optional[str] = Field(None, description='Deployment key (aka Deployment Id)')
    name: str = Field(..., description='Updated deployment name')
    package: Optional[Package] = None


class AllOf(BaseModel):
    appVersion: Optional[str] = Field(None, description='The version of the release')
    blobUrl: Optional[str] = Field(
        None, description='Location (URL) of release package'
    )
    diffPackageMap: Optional[Dict[str, Any]] = Field(
        None,
        description='Object containing URL and size of changed package hashes contained in the release',
    )
    isDisabled: Optional[bool] = Field(
        None, description='Flag used to determine if release is disabled'
    )
    isMandatory: Optional[bool] = Field(
        None, description='Flag used to determine if release is mandatory'
    )
    label: Optional[str] = Field(None, description='Release label (aka release name)')
    manifestBlobUrl: Optional[str] = Field(
        None, description="The URL location of the package's manifest file."
    )
    releaseMethod: Optional[str] = Field(
        None, description='Method used to deploy release'
    )
    releasedByUserId: Optional[str] = Field(
        None, description='User ID that triggered most recent release'
    )
    rollout: Optional[int] = Field(
        None, description='Percentage (out of 100) that release is deployed to'
    )
    size: Optional[int] = Field(None, description='Size of release package')
    uploadTime: Optional[int] = Field(
        None, description='Release upload time as epoch Unix timestamp'
    )


class LegacyDeploymentHistory(BaseModel):
    allOf: Optional[AllOf] = None
    description: Optional[str] = Field(
        None, description='The description of the release.'
    )
    originalDeployment: Optional[str] = Field(
        None,
        description="The original deployment of the release, if it's ever been promoted.",
    )
    originalLabel: Optional[str] = Field(
        None,
        description="The original label of the release, if it's ever been updated.",
    )
    packageHash: Optional[str] = Field(
        None, description="The package's hash value (internal use)."
    )


class HistoryItem(BaseModel):
    allOf: Optional[AllOf] = None
    description: Optional[str] = Field(
        None, description='The description of the release.'
    )
    originalDeployment: Optional[str] = Field(
        None,
        description="The original deployment of the release, if it's ever been promoted.",
    )
    originalLabel: Optional[str] = Field(
        None,
        description="The original label of the release, if it's ever been updated.",
    )
    packageHash: Optional[str] = Field(
        None, description="The package's hash value (internal use)."
    )


class LegacyDeploymentHistoryResponse(BaseModel):
    history: Optional[List[HistoryItem]] = Field(
        None, description="Array containing the deployment's package history."
    )


class LegacyDeploymentMetric(BaseModel):
    active: int = Field(
        ...,
        description='The number of devices that have this release installed currently',
    )
    downloaded: Optional[int] = Field(
        None, description='The number of times this release has been downloaded'
    )
    failed: Optional[int] = Field(
        None,
        description='The number of times this release has failed to be installed on a device',
    )
    installed: Optional[int] = Field(
        None,
        description='The number of times this release has been installed on a device',
    )


class Metrics(BaseModel):
    active: int = Field(
        ...,
        description='The number of devices that have this release installed currently',
    )
    downloaded: Optional[int] = Field(
        None, description='The number of times this release has been downloaded'
    )
    failed: Optional[int] = Field(
        None,
        description='The number of times this release has failed to be installed on a device',
    )
    installed: Optional[int] = Field(
        None,
        description='The number of times this release has been installed on a device',
    )


class LegacyDeploymentMetricsResponse(BaseModel):
    metrics: Optional[Dict[str, Metrics]] = Field(
        None,
        description="Object containing a property named after each release label, which contains an object that contains that release's metrics.",
    )


class Deployment1(BaseModel):
    createdTime: Optional[int] = Field(
        None,
        description='Time at which the deployment was created as a Unix timestamp.',
    )
    id: Optional[str] = Field(
        None, description='The ID of the deployment (internal use only).'
    )
    key: Optional[str] = Field(None, description='Deployment key (aka Deployment Id)')
    name: str = Field(..., description='Updated deployment name')
    package: Optional[Package] = None


class LegacyDeploymentResponse(BaseModel):
    deployment: Optional[Dict[str, Deployment1]] = None


class Deployment2(BaseModel):
    createdTime: Optional[int] = Field(
        None,
        description='Time at which the deployment was created as a Unix timestamp.',
    )
    id: Optional[str] = Field(
        None, description='The ID of the deployment (internal use only).'
    )
    key: Optional[str] = Field(None, description='Deployment key (aka Deployment Id)')
    name: str = Field(..., description='Updated deployment name')
    package: Optional[Package] = None


class LegacyDeploymentsResponse(BaseModel):
    deployments: Optional[List[Deployment2]] = None


class UpdateInfo(BaseModel):
    appVersion: Optional[str] = None
    description: Optional[str] = None
    isDisabled: Optional[bool] = None
    isMandatory: Optional[bool] = None
    rollout: Optional[int] = None
    downloadURL: Optional[str] = None
    isAvailable: bool
    label: Optional[str] = None
    packageHash: Optional[str] = None
    packageSize: Optional[float] = None
    shouldRunBinaryVersion: Optional[bool] = None
    updateAppVersion: Optional[bool] = None


class LegacyUpdateCheckResponse(BaseModel):
    updateInfo: UpdateInfo


class LegacyUpdateInfoData(BaseModel):
    appVersion: Optional[str] = None
    description: Optional[str] = None
    isDisabled: Optional[bool] = None
    isMandatory: Optional[bool] = None
    rollout: Optional[int] = None
    downloadURL: Optional[str] = None
    isAvailable: bool
    label: Optional[str] = None
    packageHash: Optional[str] = None
    packageSize: Optional[float] = None
    shouldRunBinaryVersion: Optional[bool] = None
    updateAppVersion: Optional[bool] = None


class LinkAADtoUserRequest(BaseModel):
    aad_tenant_ids: List[UUID] = Field(
        ...,
        description='An array of AAD tenant data needed to link the user to the tenants',
    )
    role: Optional[Role] = Field(None, description='The role of the user to be added')


class Type46(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class Log2(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type46 = Field(..., description='Log type.\n')


class Log3(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type46 = Field(..., description='Log type.\n')


class LogContainer(BaseModel):
    exceeded_max_limit: Optional[bool] = Field(
        None,
        description='indicates if the number of available logs are more than the max allowed return limit(100).',
    )
    last_received_log_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='the timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.',
    )
    logs: List[Log3] = Field(..., description='the list of logs', min_length=0)


class LogFlowBooleanProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: bool = Field(..., description='Boolean property value.')


class LogFlowClearProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str


class LogFlowCustomProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str


class Type48(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class LogFlowCustomPropertyLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')
    properties: Optional[List[Property]] = Field(
        None, description='Custom property changes.', max_length=60, min_length=1
    )


class LogFlowDateTimeProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: datetime_aliased = Field(..., description='Date time property value.')


class LogFlowDevice(BaseModel):
    app_build: str = Field(..., description="The app's build number, e.g. 42.\n")
    app_namespace: Optional[str] = Field(
        None,
        description='The bundle identifier, package identifier, or namespace, depending on what the individual plattforms use,  .e.g com.microsoft.example.\n',
    )
    app_version: str = Field(..., description='Application version name, e.g. 1.1.0\n')
    carrier_code: Optional[str] = Field(
        None, description='Carrier country code (for mobile devices).\n'
    )
    carrier_country: Optional[str] = Field(None, description='Carrier country.\n')
    carrier_name: Optional[str] = Field(
        None, description='Carrier name (for mobile devices).\n'
    )
    live_update_deployment_key: Optional[str] = Field(
        None,
        description='Identifier of environment that current application release belongs to, deployment key then maps to environment like Production, Staging.\n',
    )
    live_update_package_hash: Optional[str] = Field(
        None,
        description='Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps identify the Release version on device or need to download updates in future.\n',
    )
    live_update_release_label: Optional[str] = Field(
        None,
        description="Label that is used to identify application code 'version' released via Live Update beacon running on device\n",
    )
    locale: str = Field(..., description='Language code (example: en_US).\n')
    model: Optional[str] = Field(None, description='Device model (example: iPad2,3).\n')
    oem_name: Optional[str] = Field(
        None, description='Device manufacturer (example: HTC).\n'
    )
    os_api_level: Optional[int] = Field(
        None, description='API level when applicable like in Android (example: 15).\n'
    )
    os_build: Optional[str] = Field(
        None, description='OS build code (example: LMY47X).\n'
    )
    os_name: str = Field(
        ...,
        description='OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS, macOS, tvOS, Windows.\n',
    )
    os_version: str = Field(..., description='OS version (example: 9.3.0).\n')
    screen_size: Optional[str] = Field(
        None, description='Screen size of the device in pixels (example: 640x480).\n'
    )
    sdk_name: str = Field(
        ...,
        description='Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios", "hockeysdk.android".\n',
    )
    sdk_version: str = Field(
        ...,
        description='Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".\n',
    )
    time_zone_offset: conint(ge=-840, le=840) = Field(
        ...,
        description='The offset in minutes from UTC for the device time zone, including daylight savings time.\n',
    )
    wrapper_runtime_version: Optional[str] = Field(
        None,
        description='Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or other.\n',
    )
    wrapper_sdk_name: Optional[str] = Field(
        None,
        description='Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g. "appcenter.xamarin", "hockeysdk.cordova".\n',
    )
    wrapper_sdk_version: Optional[str] = Field(
        None,
        description='Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for example Xamarin.Android wraps Android), the Xamarin specific version is populated into this field while sdkVersion refers to the original Android SDK.\n',
    )


class LogFlowErrorLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')
    app_launch_toffset: Optional[int] = Field(
        None,
        description='Corresponds to the number of milliseconds elapsed between the time the error occurred and the app was launched.\n',
    )
    id: UUID = Field(..., description='Error identifier.')
    session_id: UUID = Field(..., description='Session ID.\n')


class LogFlowEventLog(BaseModel):
    properties: Optional[Dict[str, str]] = Field(
        None, description='Additional key/value pair parameters.\n'
    )
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')
    id: UUID = Field(..., description='Unique identifier for this event.\n')
    name: str = Field(..., description='Name of the event.\n')
    session_id: UUID = Field(..., description='Session ID.\n')


class LogFlowGenericLog(BaseModel):
    account_id: Optional[str] = Field(
        None, description='Account ID of the authenticated user.\n'
    )
    auth_provider: Optional[str] = Field(None, description='Auth service provider.\n')
    device: Device = Field(..., description='Device characteristics.')
    event_id: Optional[str] = Field(None, description='Event ID.\n')
    event_name: Optional[str] = Field(None, description='Event name.\n')
    install_id: UUID = Field(..., description='Install ID.\n')
    message_id: Optional[str] = Field(None, description='Message ID.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='event specific properties.\n'
    )
    session_id: Optional[UUID] = Field(None, description='Session ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')


class Log4(BaseModel):
    account_id: Optional[str] = Field(
        None, description='Account ID of the authenticated user.\n'
    )
    auth_provider: Optional[str] = Field(None, description='Auth service provider.\n')
    device: Device = Field(..., description='Device characteristics.')
    event_id: Optional[str] = Field(None, description='Event ID.\n')
    event_name: Optional[str] = Field(None, description='Event name.\n')
    install_id: UUID = Field(..., description='Install ID.\n')
    message_id: Optional[str] = Field(None, description='Message ID.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='event specific properties.\n'
    )
    session_id: Optional[UUID] = Field(None, description='Session ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')


class LogFlowGenericLogContainer(BaseModel):
    exceeded_max_limit: Optional[bool] = Field(
        None,
        description='indicates if the number of available logs are more than the max allowed return limit(100).',
    )
    last_received_log_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='the timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.',
    )
    logs: List[Log4] = Field(..., description='the list of logs', min_length=0)


class LogFlowLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')


class Log5(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')


class LogFlowLogContainer(BaseModel):
    exceeded_max_limit: Optional[bool] = Field(
        None,
        description='indicates if the number of available logs are more than the max allowed return limit(100).',
    )
    last_received_log_timestamp: Optional[datetime_aliased] = Field(
        None,
        description='the timestamp of the last log received. This value can be used as the start time parameter in the consecutive API call.',
    )
    logs: List[Log5] = Field(..., description='the list of logs', min_length=0)


class LogFlowLogWithProperties(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='Additional key/value pair parameters.\n'
    )


class LogFlowNumberProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: float = Field(..., description='Number property value.')


class LogFlowPageLog(BaseModel):
    properties: Optional[Dict[str, str]] = Field(
        None, description='Additional key/value pair parameters.\n'
    )
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')
    name: str = Field(..., description='Name of the page.\n')
    session_id: UUID = Field(..., description='Session ID.\n')


class LogFlowStartServiceLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')
    services: Optional[List[str]] = Field(
        None,
        description='The list of services of the AppCenter Start API call.',
        min_length=1,
    )


class LogFlowStartSessionLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type48 = Field(..., description='Log type.\n')
    session_id: UUID = Field(..., description='Session ID.\n')


class LogFlowStringProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: constr(max_length=128) = Field(..., description='String property value.')


class LogTraceDefinition(BaseModel):
    app_secret: str
    expiration: Optional[datetime_aliased] = None
    install_id: Optional[str] = None


class Type59(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class LogWithProperties(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type59 = Field(..., description='Log type.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='Additional key/value pair parameters.\n'
    )


class LogWithPropertiesDiagnostics(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type59 = Field(..., description='Log type.\n')
    properties: Optional[Dict[str, str]] = Field(
        None, description='Additional key/value pair parameters.\n'
    )


class LogDiagnostics(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type59 = Field(..., description='Log type.\n')


class MSAUser(BaseModel):
    hexcid: str = Field(..., description="the user's CID")


class Result1(Enum):
    clean = 'clean'
    infected = 'infected'
    error = 'error'


class MalwareScanResultPayload(BaseModel):
    requestId: UUID = Field(..., description='Scan request identifier')
    result: Result1 = Field(..., description='Scan result')


class Origin25(Enum):
    hockeyapp = 'hockeyapp'
    appcenter = 'appcenter'


class ManagementReleaseDetailsResponse(BaseModel):
    buildVersion: Optional[str] = Field(
        None,
        description="The release's buildVersion.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )
    createdAt: Optional[str] = Field(
        None, description='UTC time the release was created in ISO 8601 format.'
    )
    deletedAt: Optional[str] = Field(
        None, description='UTC time the release was created in ISO 8601 format.'
    )
    distinctId: Optional[int] = Field(
        None, description='ID identifying this unique release.'
    )
    enabled: Optional[bool] = Field(
        None,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    origin: Optional[Origin25] = Field(None, description="The release's origin")
    sortVersion: Optional[str] = Field(None, description="The release's sortVersion.")
    version: Optional[str] = Field(
        None,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )


class MemberDevicesInfoResponse(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    device_name: str = Field(
        ..., description='The device description, in the format "iPhone 7 Plus (A1784)"'
    )
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    full_device_name: Optional[str] = Field(
        None, description='A combination of the device model name and the owner name.'
    )
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    imei: Optional[str] = Field(
        None,
        description="The device's International Mobile Equipment Identity number. Always empty or undefined at present.",
    )
    invite_pending: Optional[bool] = Field(
        None,
        description='Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".',
    )
    model: str = Field(
        ..., description='The model identifier of the device, in the format iDeviceM,N'
    )
    name: Optional[str] = Field(
        None, description='The unique name that is used to identify the user.'
    )
    os_build: str = Field(
        ..., description='The last known OS version running on the device'
    )
    os_version: str = Field(
        ..., description='The last known OS version running on the device'
    )
    owner_id: Optional[str] = Field(
        None, description='The user ID of the device owner.'
    )
    registered_at: Optional[str] = Field(
        None, description='Timestamp of when the device was registered in ISO format.'
    )
    serial: Optional[str] = Field(
        None,
        description="The device's serial number. Always empty or undefined at present.",
    )
    status: str = Field(..., description='The provisioning status of the device.')
    udid: str = Field(..., description='The Unique Device IDentifier of the device')


class MessageEnvelope(BaseModel):
    message: Optional[Dict[str, Any]] = Field(None, description='Body of the message')
    messageId: Optional[str] = Field(None, description='Unique id of the message')
    messageType: Optional[str] = Field(None, description='Type of the message')


class MetricsValues(RootModel[Optional[Dict[str, float]]]):
    root: Optional[Dict[str, float]] = None


class MetricsValuesByApp(RootModel[Optional[Dict[str, Dict[str, float]]]]):
    root: Optional[Dict[str, Dict[str, float]]] = Field(
        None, description='A collection of named numeric values'
    )


class Model6(BaseModel):
    count: Optional[int] = Field(None, description='Count current of model.')
    model_name: Optional[str] = Field(None, description="Model's name.")
    previous_count: Optional[int] = Field(None, description='Count of previous model.')


class Module(RootModel[Optional[Dict[str, bool]]]):
    root: Optional[Dict[str, bool]] = None


class Modules(BaseModel):
    modules: Optional[Dict[str, Dict[str, bool]]] = None


class NativeCrashLog(RootModel[str]):
    root: str


class AppReleaseProperties(BaseModel):
    app_display_name: str
    app_name: str
    bundle_identifier: str
    distribution_group_id: Optional[str] = None
    fingerprint: Optional[str] = None
    icon_link: Optional[str] = None
    install_link: str
    installable: Optional[bool] = None
    mandatory_update: Optional[bool] = None
    min_os: Optional[str] = None
    platform: str
    provisioning_profile_name: Optional[str] = None
    provisioning_profile_type: Optional[str] = None
    release_id: str
    release_notes: Optional[str] = None
    short_version: str
    size: int
    uploaded_at: str = Field(..., description='Date and time in ISO 8601 format')
    version: str


class NewAppReleaseAlertingEvent(BaseModel):
    event_id: str = Field(
        ...,
        description='A unique identifier for this event instance. Useful for deduplication',
    )
    event_timestamp: str = Field(
        ..., description='ISO 8601 date time when event was generated'
    )
    properties: Optional[Dict[str, Any]] = Field(
        None, description='Obsolete. Use emailProperties.'
    )
    app_release_properties: Optional[AppReleaseProperties] = Field(
        None, description='Properties of new application release'
    )
    disable_webhook: Optional[bool] = Field(
        None, description='indicate whether notify via webhook or not'
    )
    user_ids: Optional[List[str]] = Field(
        None,
        description='List of users who need to receive an email notification. If this is not null, then only sending emails will be triggered even if the event requires calling webhooks or doing other actions.',
    )


class CrashGroupProperties(BaseModel):
    app_display_name: str
    app_platform: str
    app_version: str
    id: str
    name: str
    reason: str
    stack_trace: List[str]
    url: str


class NewCrashGroupAlertingEvent(BaseModel):
    event_id: str = Field(
        ...,
        description='A unique identifier for this event instance. Useful for deduplication',
    )
    event_timestamp: str = Field(
        ..., description='ISO 8601 date time when event was generated'
    )
    properties: Optional[Dict[str, Any]] = Field(
        None, description='Obsolete. Use emailProperties.'
    )
    crash_group_properties: Optional[CrashGroupProperties] = Field(
        None, description='Properties of new crash group'
    )


class NodeVersion(BaseModel):
    current: Optional[bool] = Field(
        None, description='If the Node version is default for AppCenter'
    )
    name: Optional[str] = Field(None, description='The version name')


class NodeVersions(RootModel[List[NodeVersion]]):
    root: List[NodeVersion] = Field(..., description='A list of Node versions')


class Release4(BaseModel):
    distribution_group: Optional[str] = Field(
        None, description='Distribution group Id.\n'
    )
    release: str = Field(..., description='Release Id.\n')
    user_id: Optional[UUID] = Field(
        None,
        description='Unique user Id.  Will generate a new user Id if not provided.\n',
    )


class NotifyReleasesContainer(BaseModel):
    releases: List[Release4] = Field(..., min_length=1)


class NumberProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: float = Field(..., description='Number property value.')


class NumberPropertyDiagnostics(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: float = Field(..., description='Number property value.')


class OS(BaseModel):
    count: Optional[int] = Field(None, description='Count current of OS.')
    os_name: Optional[str] = Field(None, description='OS name.')
    previous_count: Optional[int] = Field(None, description='Count of previous OS.')


class Ose(BaseModel):
    count: Optional[int] = Field(None, description='Count current of OS.')
    os_name: Optional[str] = Field(None, description='OS name.')
    previous_count: Optional[int] = Field(None, description='Count of previous OS.')


class OSes(BaseModel):
    oses: Optional[List[Ose]] = None
    total: Optional[int] = None


class OperationStatus(Enum):
    None_ = 'None'
    Created = 'Created'
    Queued = 'Queued'
    InProgress = 'InProgress'
    Completed = 'Completed'
    Failed = 'Failed'


class OptimizelyUserMetaDataRequest(BaseModel):
    metadata: Optional[Dict[str, Any]] = None


class OptimizelyUserMetaDataResponse(BaseModel):
    metadata: Optional[Dict[str, Any]] = None
    userId: Optional[str] = None


class OrgComplianceSettingsRequest(BaseModel):
    certificate_connection_id: str = Field(
        ...,
        description='certificate connection id to wrap and resign the app after wrapping',
    )


class OrgComplianceSettingsResponse(BaseModel):
    certificate_connection_id: str = Field(
        ...,
        description='certificate connection id to wrap and resign the app after wrapping',
    )
    id: str = Field(
        ...,
        description='The internal unique id (UUID) of the organization compliance setting',
    )
    is_mam_enabled: Optional[bool] = Field(
        None, description='flag to tell if mam warpping is enabled on the Org'
    )
    org_id: str = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )


class Type62(Enum):
    org = 'org'
    user = 'user'


class Owner11(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type62 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class OrgDistributionGroupAppResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner11 = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    origin: Optional[str] = Field(None, description='The creation origin of this app')
    platform: Optional[str] = Field(None, description='The platform of the app')


class Origin26(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class Owner12(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type62 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class Origin27(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class App7(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner12 = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    app_secret: str = Field(
        ...,
        description='A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics',
    )
    azure_subscription: Optional[AzureSubscription] = None
    created_at: Optional[str] = Field(None, description='The created date of this app')
    member_permissions: Optional[List[MemberPermission]] = Field(
        None, description='The permissions of the calling user'
    )
    origin: Origin27 = Field(..., description='The creation origin of this app')
    platform: Platform9 = Field(..., description='The platform of the app')
    updated_at: Optional[str] = Field(
        None, description='The last updated date of this app'
    )


class OrgDistributionGroupDetailsResponse(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The name of the distribution group'
    )
    id: UUID = Field(..., description='The unique ID of the distribution group')
    is_public: bool = Field(..., description='Whether the distribution group is public')
    name: str = Field(
        ..., description='The name of the distribution group used in URLs'
    )
    origin: Origin26 = Field(
        ..., description='The creation origin of this distribution group'
    )
    apps: List[App7] = Field(
        ..., description='The apps associated with the distribution group'
    )
    total_apps_count: float = Field(
        ..., description='The count of apps associated with this distribution group'
    )
    total_users_count: float = Field(
        ..., description='The count of users in the distribution group'
    )


class OrgNameAvailabilityResponse(BaseModel):
    available: bool = Field(
        ..., description='The availability status of the requested org name'
    )
    name: str = Field(..., description='The generated org name')


class UserRole(Enum):
    admin = 'admin'
    collaborator = 'collaborator'


class OrgUserPermissionResponse(BaseModel):
    orgId: UUID = Field(..., description='The unique id (UUID) of the org')
    userRole: UserRole = Field(..., description='The user role for the org')


class OrganizationAadGroupPatchRequest(BaseModel):
    role: Optional[Role] = Field(
        None, description="The user's role in the organizatiion"
    )


class InvitedBy2(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin27 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission]] = Field(
        None, description='The permissions the user has for the app'
    )


class Origin29(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'


class Organization2(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin29 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class OrganizationInvitationDetailResponse(BaseModel):
    email: str = Field(..., description='The email address of the invited user')
    id: UUID = Field(..., description='The unique ID (UUID) of the invitation')
    invited_by: InvitedBy2
    is_existing_user: bool = Field(
        ..., description='Indicates whether the invited user already exists'
    )
    organization: Organization2
    role: Optional[str] = Field(
        None, description='The role assigned to the invited user'
    )


class OrganizationInvitationSimpleDetailResponse(BaseModel):
    email: str = Field(..., description='The email address of the invited user')
    id: UUID = Field(..., description='The unique ID (UUID) of the invitation')
    role: str = Field(..., description='The role assigned to the invited user')


class OrganizationPatchRequest(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The full (friendly) name of the organization.'
    )
    name: Optional[str] = Field(
        None, description='The name of the organization used in URLs'
    )


class OrganizationRequest(BaseModel):
    display_name: Optional[str] = Field(
        None, description='The display name of the organization'
    )
    name: Optional[str] = Field(
        None, description='The name of the organization used in URLs'
    )


class OrganizationResponse(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin29 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )


class OrganizationResponseInternal(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin29 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )
    feature_flags: Optional[List[str]] = Field(
        None, description='The feature flags that are enabled for this organization'
    )


class OrganizationResponseManagement(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description='The URL to a user-uploaded Avatar image'
    )
    created_at: str = Field(..., description='The creation date of this organization')
    display_name: str = Field(..., description='The display name of the organization')
    id: UUID = Field(
        ..., description='The internal unique id (UUID) of the organization.'
    )
    name: str = Field(..., description='The slug name of the organization')
    origin: Origin29 = Field(
        ..., description='The creation origin of this organization'
    )
    updated_at: str = Field(
        ..., description='The date the organization was last updated at'
    )
    feature_flags: Optional[List[str]] = Field(
        None, description='The feature flags that are enabled for this organization'
    )
    email: Optional[str] = Field(
        None, description='The organization email, if the app was synced from HockeyApp'
    )


class OrganizationUserPatchRequest(BaseModel):
    role: Optional[Role] = Field(
        None, description="The user's role in the organizatiion"
    )


class OrganizationUserResponse(BaseModel):
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    joined_at: str = Field(
        ..., description='The date when the user joined the organization'
    )
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    role: str = Field(..., description='The role the user has within the organization')


class Owner13(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type62 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class PackageHashToBlobInfoMap1(BaseModel):
    size: float
    url: str


class PackageHashToBlobInfoMap(
    RootModel[Optional[Dict[str, PackageHashToBlobInfoMap1]]]
):
    root: Optional[Dict[str, PackageHashToBlobInfoMap1]] = None


class Type65(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class PageLog(BaseModel):
    properties: Optional[Dict[str, str]] = Field(
        None, description='Additional key/value pair parameters.\n'
    )
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type65 = Field(..., description='Log type.\n')
    name: str = Field(..., description='Name of the page.\n')
    session_id: UUID = Field(..., description='Session ID.\n')


class PageLogDiagnostics(BaseModel):
    properties: Optional[Dict[str, str]] = Field(
        None, description='Additional key/value pair parameters.\n'
    )
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type65 = Field(..., description='Log type.\n')
    name: str = Field(..., description='Name of the page.\n')
    session_id: UUID = Field(..., description='Session ID.\n')


class PasswordUpdateRequest(BaseModel):
    new_password: str = Field(
        ...,
        description='The new password that will be set for the user. Needs to be at least 8 characters long and contain at least one lower- and one uppercase letter.',
    )
    old_password: Optional[str] = Field(
        None, description='The old password, if needed.'
    )


class PatchReleaseAssetIdRequest(BaseModel):
    ipa_uuids: Optional[str] = Field(
        None, description='The ipa UUIDs for this release, as a serialized JSON array'
    )
    package_asset_id: UUID = Field(
        ..., description='The release new package id in ACFUS'
    )
    upload_id: UUID = Field(
        ..., description='The release upload id used to upload the release'
    )


class PatchReleaseRequest(BaseModel):
    dest_publish_id: Optional[str] = Field(None, description='Destination Publish Id')
    error_contextId: Optional[str] = Field(
        None, description='contextId for failed error message'
    )
    error_details: Optional[str] = Field(
        None, description='failure error details from store'
    )
    is_wrapper_request: Optional[bool] = Field(
        None, description='request is for wrapping or not'
    )
    status: Optional[str] = Field(None, description='updated status of release')
    wrap_package_url: Optional[str] = Field(
        None, description='package url for wrapping request'
    )


class UploadStatus1(Enum):
    uploadFinished = 'uploadFinished'
    uploadCanceled = 'uploadCanceled'


class PatchReleaseUploadStatusRequest(BaseModel):
    upload_status: UploadStatus1 = Field(
        ..., description='The new status of the release upload'
    )


class UploadStatus2(Enum):
    uploadStarted = 'uploadStarted'
    uploadFinished = 'uploadFinished'
    uploadCanceled = 'uploadCanceled'
    readyToBePublished = 'readyToBePublished'
    malwareDetected = 'malwareDetected'
    error = 'error'


class PatchReleaseUploadStatusResponse(BaseModel):
    id: UUID = Field(..., description='The ID for the upload.')
    upload_status: UploadStatus2 = Field(..., description='The current upload status.')


class PatchRepoInfo(BaseModel):
    external_user_id: Optional[str] = Field(None, description='The external user ID')


class Sample(BaseModel):
    cpu: Optional[float] = None
    elapsed_secs: Optional[float] = Field(None, alias='elapsed-secs')
    mem: Optional[float] = None


class Step(BaseModel):
    avg_cpu: Optional[float] = Field(None, alias='avg-cpu')
    avg_mem: Optional[float] = Field(None, alias='avg-mem')
    elapsed_secs: Optional[float] = Field(None, alias='elapsed-secs')
    elapsed_secs_end: Optional[float] = Field(None, alias='elapsed-secs-end')
    elapsed_secs_start: Optional[float] = Field(None, alias='elapsed-secs-start')
    id: Optional[str] = None
    name: Optional[str] = None
    samples: Optional[List[Sample]] = None


class PerformanceData(BaseModel):
    elapsed_secs: float = Field(..., alias='elapsed-secs')
    elapsed_secs_end: float = Field(..., alias='elapsed-secs-end')
    elapsed_secs_start: float = Field(..., alias='elapsed-secs-start')
    id: str
    steps: List[Step]


class Event2(BaseModel):
    id: Optional[str] = None
    millis: Optional[float] = None
    name: Optional[str] = None
    type: Optional[str] = None


class VideoMetadata(BaseModel):
    events: Optional[List[Event2]] = None


class Video(BaseModel):
    video_metadata: VideoMetadata
    video_url: str


class PerformanceReport(BaseModel):
    device_snapshot_id: Optional[str] = None
    performance_data: Optional[PerformanceData] = None
    video: Optional[Video] = None


class Place1(BaseModel):
    code: Optional[str] = Field(None, description='The place code.')
    count: Optional[int] = Field(None, description='The count of the this place.')
    previous_count: Optional[int] = Field(
        None, description='The count of previous time range of the place.'
    )


class Places(BaseModel):
    places: Optional[List[Place1]] = None
    total: Optional[int] = None


class PostCreateReleaseUploadRequest(BaseModel):
    build_number: Optional[str] = Field(None, description='User defined build number')
    build_version: Optional[str] = Field(None, description='User defined build version')


class PostExternalDownloadUrl(BaseModel):
    download_url: Optional[str] = Field(None, description='The new download URL')


class PostPlaceholderReleaseUploadForDeleteRequest(BaseModel):
    error_details: Optional[str] = Field(
        None,
        description='Additional details to identify why the placeholder ReleaseUpload is being created.',
    )


class Provider(Enum):
    github = 'github'


class PostRepositoryProviderMappingRequest(BaseModel):
    account_id: UUID = Field(
        ...,
        description='App Center account id to link to this provider and external id',
    )
    external_account_id: str = Field(
        ..., description='Id of user in the external provider service'
    )
    provider: Provider = Field(
        ..., description='Supported external providers of source control repositories'
    )


class PostRestoreAppRequest(BaseModel):
    responsibleAdminId: UUID = Field(
        ...,
        description='The internal unique id (UUID) of the account of the user, who makes the request.',
    )


class Data12(BaseModel):
    base64Certificate: str = Field(
        ..., description='The certificate contents in base 64 encoded string'
    )
    certificateValidityEndDate: str = Field(
        ..., description='The date-time till which the certificate is valid'
    )
    certificateValidityStartDate: str = Field(
        ..., description='The date-time from which the certificate is valid'
    )
    displayName: str = Field(
        ..., description='The display name (CN) of the certificate'
    )
    password: str = Field(..., description='The password for the certificate')


class PrivateAppleCertificateSecretResponse(BaseModel):
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    id: str = Field(..., description='id of the shared connection')
    is2FA: Optional[bool] = Field(
        None, description='if the account is a 2FA account or not'
    )
    isValid: Optional[bool] = Field(
        None, description='whether the credentials are valid or not'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )
    data: Data12 = Field(..., description='apple secret details')


class Data13(BaseModel):
    authCode: Optional[constr(min_length=6, max_length=6)] = Field(
        None, description='6 digit auth code'
    )
    password: Optional[str] = Field(
        None, description='password to connect to apple store.'
    )
    username: Optional[str] = Field(
        None, description='username to connect to apple store.'
    )


class PrivateAppleCredentialsSecretResponse(BaseModel):
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    id: str = Field(..., description='id of the shared connection')
    is2FA: Optional[bool] = Field(
        None, description='if the account is a 2FA account or not'
    )
    isValid: Optional[bool] = Field(
        None, description='whether the credentials are valid or not'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )
    data: Data13 = Field(..., description='apple secret details')


class PrivateAppleSecretResponse(BaseModel):
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    id: str = Field(..., description='id of the shared connection')
    is2FA: Optional[bool] = Field(
        None, description='if the account is a 2FA account or not'
    )
    isValid: Optional[bool] = Field(
        None, description='whether the credentials are valid or not'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )


class Origin33(Enum):
    hockeyapp = 'hockeyapp'
    appcenter = 'appcenter'


class PrivateBasicReleaseDetailsResponse(BaseModel):
    destination_type: Optional[DestinationType] = Field(
        None,
        description='The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>\n',
    )
    distribution_group_id: Optional[str] = Field(
        None, description='the destination id of release where it is distributed.'
    )
    id: Optional[int] = Field(None, description='ID identifying this unique release.')
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    is_latest: Optional[bool] = Field(
        None, description='Indicates if this is the latest release in the group.'
    )
    mandatory_update: Optional[bool] = Field(
        None,
        description='A boolean which determines whether the release is a mandatory update or not.',
    )
    origin: Optional[Origin33] = Field(None, description="The release's origin")
    publishing_status: Optional[str] = Field(
        None, description='the publishing status of the distributed release'
    )
    short_version: Optional[str] = Field(
        None,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: Optional[str] = Field(
        None, description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: Optional[str] = Field(
        None,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class AppCategory4(BaseModel):
    name: Optional[str] = Field(None, description='display name for the app category')


class TargetAudience4(BaseModel):
    name: Optional[str] = Field(
        None, description='display name for the target audience/group'
    )


class IntuneDetails2(BaseModel):
    app_category: Optional[AppCategory4] = None
    target_audience: Optional[TargetAudience4] = None
    tenant_id: Optional[str] = Field(None, description='tenant id of the intune store')


class Type67(Enum):
    intune = 'intune'


class PrivateCreateStoreRequest(BaseModel):
    intune_details: Optional[IntuneDetails2] = None
    name: Optional[str] = Field(None, description='name of the store.')
    type: Optional[Type67] = Field(None, description='store Type')


class PrivateGooglePlayConnectionSecretResponse(BaseModel):
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    id: str = Field(..., description='id of the shared connection')
    is2FA: Optional[bool] = Field(
        None, description='if the account is a 2FA account or not'
    )
    isValid: Optional[bool] = Field(
        None, description='whether the credentials are valid or not'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )
    data: Dict[str, Any] = Field(..., description='google secret details')


class PrivateIntuneStoreRequest(BaseModel):
    app_category: Optional[AppCategory4] = None
    target_audience: Optional[TargetAudience4] = None
    tenant_id: Optional[str] = Field(None, description='tenant id of the intune store')


class Data14(BaseModel):
    baseUrl: str = Field(..., description='baseUrl to connect to jira instance')
    password: str = Field(..., description='password to connect to jira instance')
    username: str = Field(..., description='username to connect to jira instance')


class PrivateJiraConnectionSecretResponse(BaseModel):
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    id: str = Field(..., description='id of the shared connection')
    is2FA: Optional[bool] = Field(
        None, description='if the account is a 2FA account or not'
    )
    isValid: Optional[bool] = Field(
        None, description='whether the credentials are valid or not'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )
    data: Data14 = Field(..., description='jira secret details')


class ProvisioningProfileType(Enum):
    adhoc = 'adhoc'
    enterprise = 'enterprise'
    other = 'other'


class Status8(Enum):
    available = 'available'
    unavailable = 'unavailable'


class PrivateReleaseDetailsResponse(BaseModel):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: Optional[str] = Field(None, description="The app's display name.")
    app_icon_url: Optional[str] = Field(None, description="A URL to the app's icon.")
    app_name: Optional[str] = Field(
        None, description="The app's name (extracted from the uploaded release)."
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned. <br>\n',
    )
    device_family: Optional[str] = Field(
        None, description="The release's device family."
    )
    distribution_group_id: Optional[str] = Field(
        None, description='the destination where release is distributed'
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: Optional[int] = Field(None, description='ID identifying this unique release.')
    install_url: Optional[str] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    is_provisioning_profile_syncing: Optional[bool] = Field(
        None,
        description="A flag that determines whether the release's provisioning profile is still extracted or not.",
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    origin: Optional[Origin33] = Field(None, description="The release's origin")
    provisioning_profile_name: Optional[str] = Field(
        None, description="The release's provisioning profile name."
    )
    provisioning_profile_type: Optional[ProvisioningProfileType] = Field(
        None,
        description='The type of the provisioning profile for the requested app version.',
    )
    publishing_status: Optional[str] = Field(
        None, description='the publishing status of the distributed release'
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    secondary_download_url: Optional[str] = Field(
        None,
        description='The URL that hosts the secondary binary for this release, such as the apk file for aab releases.',
    )
    short_version: Optional[str] = Field(
        None,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[int] = Field(None, description="The release's size in bytes.")
    status: Optional[Status8] = Field(
        None,
        description="OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>\nThe release state.<br>\n<b>available</b>: The uploaded release has been distributed.<br>\n<b>unavailable</b>: The uploaded release is not visible to the user. <br>\n",
    )
    uploaded_at: Optional[str] = Field(
        None, description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: Optional[str] = Field(
        None,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class PublishingStatus(Enum):
    failed = 'failed'
    processing = 'processing'
    submitted = 'submitted'
    timeout = 'timeout'


class PrivateReleaseUpdateRequest(BaseModel):
    publishing_status: Optional[PublishingStatus] = Field(
        None, description='The store publishing status.'
    )


class PrivateSharedConnectionResponse(BaseModel):
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    id: str = Field(..., description='id of the shared connection')
    is2FA: Optional[bool] = Field(
        None, description='if the account is a 2FA account or not'
    )
    isValid: Optional[bool] = Field(
        None, description='whether the credentials are valid or not'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )


class Status9(Enum):
    uploadStarted = 'uploadStarted'
    uploadFinished = 'uploadFinished'
    readyToBePublished = 'readyToBePublished'
    malwareDetected = 'malwareDetected'
    error = 'error'


class PrivateUpdateUploadDetails(BaseModel):
    error_message: str = Field(..., description='Message of the error')
    status: Status9


class ProfileType(Enum):
    adhoc = 'adhoc'
    enterprise = 'enterprise'
    other = 'other'


class ProvisioningProfile(BaseModel):
    application_identifier: str = Field(..., description='The application identifier.')
    expired_at: str = Field(
        ...,
        description="The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z",
    )
    name: str = Field(..., description='The name of the provisioning profile.')
    profile_type: ProfileType
    team_identifier: str = Field(..., description='The team identifier.')
    udids: Optional[List[str]] = None


class ProvisioningProfileFile(BaseModel):
    fileId: Optional[str] = Field(None, description='File id from secure file storage')
    fileName: Optional[str] = Field(
        None, description='Name of uploaded provisioning profile'
    )
    targetBundleIdentifier: Optional[str] = Field(
        None, description='Target the provisioning profile is used to sign'
    )
    uploadId: Optional[str] = Field(
        None, description='Upload id to App Center File Upload Store'
    )


class Type68(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2


class ProvisioningProfileMigration(BaseModel):
    bundle_id: str = Field(..., description='The bundle/application identifier.')
    expired_at: Optional[str] = Field(
        None,
        description="The provisioning profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z.",
    )
    is_appex: bool = Field(
        ...,
        description='A boolean value that indicates whether the provisioning profile represents an app extension.',
    )
    name: str = Field(..., description='The name of the provisioning profile.')
    team_identifier: str = Field(..., description='The team identifier.')
    type: Type68 = Field(..., description='The type of provisoning profile.')
    udids: Optional[List[str]] = Field(
        None, description='A list of UDIDs of provisioned devices.'
    )
    url: Optional[str] = Field(
        None,
        description='A provisioning profile URL that indicates where to download it from.',
    )


class ProvisioningProfileResponse(BaseModel):
    appex_profiles: Optional[List[ProvisioningProfileResponse]] = Field(
        None, description='Array of provisioning profiles for any app extensions'
    )
    provisioning_bundle_id: Optional[str] = Field(
        None, description='The bundle identifier associated with the profile.'
    )
    provisioning_profile_name: Optional[str] = Field(
        None, description='The name of the provisioning profile.'
    )
    provisioning_profile_type: ProvisioningProfileType
    team_identifier: Optional[str] = Field(None, description='The team identifier.')
    udids: Optional[List[str]] = None


class PublicDistributionGroupsResponse(BaseModel):
    id: UUID = Field(..., description='The id of the distribution group')


class PublishDevicesRequest(BaseModel):
    account_service_connection_id: Optional[str] = Field(
        None,
        description='The service_connection_id of the stored Apple credentials instead of username, password.',
    )
    devices: Optional[List[str]] = Field(
        None,
        description="Array of device UDID's to be published to the Apple Developer account.",
    )
    password: Optional[str] = Field(
        None,
        description='The password for the Apple Developer account to publish the devices to.',
    )
    publish_all_devices: Optional[bool] = Field(
        None,
        description='When set to true, all unprovisioned devices will be published to the Apple Developer account.  When false, only the provided devices will be published to the Apple Developer account.',
    )
    username: Optional[str] = Field(
        None,
        description='The username for the Apple Developer account to publish the devices to.',
    )


class PublishDevicesResponse(BaseModel):
    profile_file_name: Optional[str] = Field(
        None, description='The file name for the provisioning profile.'
    )
    profiles_zip_base64: str = Field(
        ..., description='The updated provisioning profiles zip base64 encoded.'
    )


class RawCrashLog(BaseModel):
    pass


class Language15(Enum):
    JavaScript = 'JavaScript'
    CSharp = 'CSharp'
    Objective_C = 'Objective-C'
    Objective_Cpp = 'Objective-Cpp'
    Cpp = 'Cpp'
    C = 'C'
    Swift = 'Swift'
    Java = 'Java'
    Unknown = 'Unknown'


class ReasonStackFrame(BaseModel):
    app_code: Optional[bool] = Field(
        None, description="this line isn't from any framework"
    )
    class_method: Optional[bool] = Field(None, description='is a class method')
    class_name: Optional[str] = Field(None, description='name of the class')
    code_formatted: Optional[str] = Field(None, description='Formatted frame string')
    code_raw: Optional[str] = Field(None, description='Unformatted Frame string')
    exception_type: Optional[str] = Field(None, description='Exception type.')
    file: Optional[str] = Field(None, description='name of the file')
    framework_name: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language15] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    method_params: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    os_exception_type: Optional[str] = Field(
        None, description='OS exception type. (aka. SIGNAL)'
    )


class Release5(BaseModel):
    release: str = Field(..., description='Release Id.\n')


class ReleaseCount(BaseModel):
    distribution_group: Optional[str] = Field(
        None, description='Distribution group queried.\n'
    )
    release_id: str
    total_count: int = Field(..., description='Total count of downloads.\n')
    unique_count: int = Field(
        ..., description='Count of unique downloads against user id.\n'
    )


class Count1(BaseModel):
    distribution_group: Optional[str] = Field(
        None, description='Distribution group queried.\n'
    )
    release_id: str
    total_count: int = Field(..., description='Total count of downloads.\n')
    unique_count: int = Field(
        ..., description='Count of unique downloads against user id.\n'
    )


class ReleaseCounts(BaseModel):
    counts: List[Count1]
    total: Optional[int] = None


class AppexProvisioningProfile(BaseModel):
    application_identifier: str = Field(..., description='The application identifier.')
    expired_at: str = Field(
        ...,
        description="The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z",
    )
    name: str = Field(..., description='The name of the provisioning profile.')
    profile_type: ProfileType
    team_identifier: str = Field(..., description='The team identifier.')
    udids: Optional[List[str]] = None


class IpaUuid(BaseModel):
    architecture: str = Field(
        ...,
        description='The architecture that the UUID belongs to, i.e. armv7 or arm64.',
    )
    uuid: UUID = Field(..., description='The unique identifier.')


class Provision(BaseModel):
    application_identifier: str = Field(..., description='The application identifier.')
    expired_at: str = Field(
        ...,
        description="The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z",
    )
    name: str = Field(..., description='The name of the provisioning profile.')
    profile_type: ProfileType
    team_identifier: str = Field(..., description='The team identifier.')
    udids: Optional[List[str]] = None


class ReleaseCreateRequest(BaseModel):
    appex_provisioning_profiles: Optional[List[AppexProvisioningProfile]] = Field(
        None,
        description='iOS app extension provisioning profiles included in the release.',
    )
    build_version: Optional[str] = Field(
        None,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    device_family: Optional[str] = Field(
        None, description="The release's device family."
    )
    file_extension: Optional[str] = Field(
        None,
        description='The file extension of the asset. Does not include the initial period.',
    )
    fingerprint: str = Field(..., description='MD5 checksum of the release binary.')
    icon_asset_id: Optional[str] = Field(
        None,
        description='The assetId associated with the icon uploaded to app center file upload service.',
    )
    ipa_uuids: Optional[List[IpaUuid]] = Field(
        None, description='A list of UUIDs for architectures for an iOS app.'
    )
    languages: Optional[List[str]] = Field(
        None,
        description='The languages supported by the release. Limited to 510 characters in a serialized array.',
    )
    minimum_os_version: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    package_url: Optional[str] = Field(
        None, description="The URL to the release's binary."
    )
    provision: Optional[Provision] = Field(
        None,
        description='An object containing information about an iOS provisioning profile.',
    )
    proxy_flow: Optional[bool] = Field(
        None, description='If true this release was uploaded to the AKS upload proxy'
    )
    size: int = Field(..., description="The release's size in bytes.")
    unique_identifier: Optional[str] = Field(
        None, description="The identifier of the app's bundle."
    )
    upload_id: str = Field(
        ...,
        description='The upload id associated with the release, to map to the releases upload table.',
    )
    version: Optional[str] = Field(
        None,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class Session(BaseModel):
    count: Optional[int] = None
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class ReleaseDailySessions(BaseModel):
    avgSessionsPerDay: Optional[float] = None
    sessions: Optional[List[Session]] = Field(None, description='Sessions per day.')
    totalSessionCounts: Optional[int] = None


class ReleaseDestinationRequest(BaseModel):
    id: UUID = Field(..., description='Unique id of the release destination')
    mandatory_update: Optional[bool] = Field(
        None,
        description='Flag to mark the release for the provided destinations as mandatory',
    )
    notify_testers: Optional[bool] = Field(
        True, description='Flag to enable or disable notifications to testers'
    )


class ReleaseDestinationResponse(BaseModel):
    id: str = Field(..., description='Unique id for the release destination')
    mandatory_update: bool = Field(
        ...,
        description='Flag to mark the release for the provided destinations as mandatory',
    )
    provisioning_status_url: Optional[str] = Field(
        None, description='The url to check provisioning status.'
    )


class Build3(BaseModel):
    branch_name: Optional[str] = Field(
        None, description='The branch name of the build producing the release'
    )
    commit_hash: Optional[str] = Field(
        None, description='The commit hash of the build producing the release'
    )
    commit_message: Optional[str] = Field(
        None, description='The commit message of the build producing the release'
    )


class Type69(Enum):
    intune = 'intune'
    googleplay = 'googleplay'
    apple = 'apple'
    none = 'none'


class Destination3(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution group.',
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type69] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )
    destination_type: Optional[DestinationType] = Field(
        None, description='Destination can be either store or group.'
    )
    display_name: Optional[str] = Field(
        None, description='Display name for the group or tester'
    )


class DistributionGroup3(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution group.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution group.'
    )


class DistributionStore2(BaseModel):
    id: str = Field(..., description='ID identifying a unique distribution store.')
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type69] = Field(
        None,
        description='type of the distribution store currently stores type can be intune, googleplay or windows.',
    )


class ReleaseDetailsResponse(BaseModel):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: str = Field(..., description="The app's display name.")
    app_icon_url: str = Field(..., description="A URL to the app's icon.")
    app_name: str = Field(
        ..., description="The app's name (extracted from the uploaded release)."
    )
    app_os: Optional[str] = Field(None, description="The app's OS.")
    build: Optional[Build3] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    can_resign: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value determines if a release can be re-signed. When true, after a re-sign, the tester will be able to install the release from his registered devices. Will not be returned for non-iOS platforms.',
    )
    destination_type: Optional[DestinationType] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. The destination type.<br>\n<b>group</b>: The release distributed to internal groups and distribution_groups details will be returned.<br>\n<b>store</b>: The release distributed to external stores and distribution_stores details will be returned.<br>\n<b>tester</b>: The release distributed testers details will be returned.<br>\n',
    )
    destinations: Optional[List[Destination3]] = Field(
        None, description='A list of distribution groups or stores.'
    )
    device_family: Optional[str] = Field(
        None, description="The release's device family."
    )
    distribution_groups: Optional[List[DistributionGroup3]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.',
    )
    distribution_stores: Optional[List[DistributionStore2]] = Field(
        None,
        description='OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.',
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: int = Field(..., description='ID identifying this unique release.')
    install_url: Optional[str] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    is_provisioning_profile_syncing: Optional[bool] = Field(
        None,
        description="A flag that determines whether the release's provisioning profile is still extracted or not.",
    )
    is_udid_provisioned: Optional[bool] = Field(
        None,
        description='In calls that allow passing `udid` in the query string, this value will hold the provisioning status of that UDID in this release. Will be ignored for non-iOS platforms.',
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    origin: Optional[Origin33] = Field(None, description="The release's origin")
    package_hashes: Optional[List[str]] = Field(
        None, description='Hashes for the packages.'
    )
    provisioning_profile_expiry_date: Optional[str] = Field(
        None, description='expiration date of provisioning profile in UTC format.'
    )
    provisioning_profile_name: Optional[str] = Field(
        None, description="The release's provisioning profile name."
    )
    provisioning_profile_type: Optional[ProvisioningProfileType] = Field(
        None,
        description='The type of the provisioning profile for the requested app version.',
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    secondary_download_url: Optional[str] = Field(
        None,
        description='The URL that hosts the secondary binary for this release, such as the apk file for aab releases.',
    )
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[int] = Field(None, description="The release's size in bytes.")
    status: Optional[str] = Field(None, description='Status of the release.')
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class ReleaseDetailsUpdateRequest(BaseModel):
    build: Optional[Build3] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    enabled: Optional[bool] = Field(
        None, description='Toggle this release to be enable distribute/download or not.'
    )
    release_notes: Optional[str] = Field(
        None, description='Release notes for this release.'
    )


class ReleaseDetailsUpdateResponse(BaseModel):
    release_notes: Optional[str] = None


class ReleaseExternalUrlUpdateResponse(BaseModel):
    external_download_url: Optional[str] = None


class ReleaseMetadata(BaseModel):
    dsa_signature: Optional[str] = Field(
        None, description='dsa signature of the release for the sparkle feed.'
    )
    ed_signature: Optional[str] = Field(
        None, description='edDSA signature of the release for the sparkle feed.'
    )


class ReleaseProvisionResponse(BaseModel):
    status_url: Optional[str] = Field(
        None, description='The url to check provisioning status.'
    )


class ReleasePublishErrorResponse(BaseModel):
    is_log_available: Optional[bool] = Field(
        None, description='boolean property to tell if logs are available for download'
    )
    message: Optional[str] = Field(None, description='error Details')


class Status10(BaseModel):
    status: Optional[str] = Field(None, description='status from store')
    storetype: Optional[str] = Field(None, description='store type')
    track: Optional[str] = Field(None, description='track information from store')
    version: Optional[str] = Field(None, description='version of the app from store')


class ReleaseRealTimeStatusResponse(BaseModel):
    app_id: Optional[str] = Field(None, description='app id')
    release_id: Optional[str] = Field(None, description='release id')
    status: Optional[Status10] = Field(None, description='Status Data from store')


class ReleaseStoreDestinationRequest(BaseModel):
    id: UUID = Field(..., description='Unique id of the release destination')


class ReleaseStoreDestinationResponse(BaseModel):
    id: str = Field(..., description='Unique id for the release destination')


class ReleaseTesterDestinationRequest(BaseModel):
    email: str = Field(..., description="Tester's email address")
    mandatory_update: Optional[bool] = Field(
        None,
        description='Flag to mark the release for the provided destinations as mandatory',
    )
    notify_testers: Optional[bool] = Field(
        True, description='Flag to enable or disable notifications to testers'
    )


class Code7(Enum):
    BadRequest = 'BadRequest'
    Conflict = 'Conflict'
    NotAcceptable = 'NotAcceptable'
    NotFound = 'NotFound'
    InternalServerError = 'InternalServerError'
    Unauthorized = 'Unauthorized'
    TooManyRequests = 'TooManyRequests'


class Destination4(BaseModel):
    code: Optional[str] = Field(
        None,
        description='Error Codes:<br>\n<b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not valid.<br>\n<b>store_release_bad_request</b>: Proper package release details for the store is not provided.<br>\n<b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid developer credentials.<br>\n<b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the release version and already existing version in the store.<br>\n<b>store_release_promotion</b>: Release already distributed, promoting a release is not supported.<br>\n<b>store_track_deactivated</b>: One or more tracks would be deactivated with this release. This is not supported yet.<br>\n<b>store_release_not_found</b>: App with the given package name is not found in the store.<br>\n<b>store_release_not_available</b>: The release is not available.<br>\n<b>internal_server_error</b>: Failed to distribute to a destination due to an internal server error.\n',
    )
    id: Optional[str] = None
    message: Optional[str] = None
    name: Optional[str] = None


class ReleaseUpdateError(BaseModel):
    code: Code7
    message: str
    destinations: Optional[List[Destination4]] = None
    mandatory_update: Optional[bool] = None
    release_notes: Optional[str] = None


class Destination5(BaseModel):
    id: Optional[str] = Field(
        None,
        description="Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.",
    )
    name: Optional[str] = Field(
        None,
        description="Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.",
    )


class Metadata(BaseModel):
    dsa_signature: Optional[str] = Field(
        None, description='dsa signature of the release for the sparkle feed.'
    )
    ed_signature: Optional[str] = Field(
        None, description='edDSA signature of the release for the sparkle feed.'
    )


class ReleaseUpdateRequest(BaseModel):
    build: Optional[Build3] = Field(
        None,
        description='Contains metadata about the build that produced the release being uploaded',
    )
    destination_id: Optional[str] = Field(
        None,
        description="OBSOLETE. Will be removed in future releases - use destinations instead. Id of a destination. The release will be associated with this destination. If the destination doesn't exist a 400 is returned. If both destination name and id are passed, the id is taking precedence.",
    )
    destination_name: Optional[str] = Field(
        None,
        description="OBSOLETE. Will be removed in future releases - use destinations instead. Name of a destination. The release will be associated with this destination. If the destination doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.",
    )
    destination_type: Optional[str] = Field(None, description='Not used anymore.')
    destinations: Optional[List[Destination5]] = Field(
        None,
        description='Distribute this release under the following list of destinations (store groups or distribution groups).',
    )
    distribution_group_id: Optional[str] = Field(
        None,
        description="OBSOLETE. Will be removed in future releases - use destinations instead. Id of a distribution group. The release will be associated with this distribution group. If the distribution group doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.",
    )
    distribution_group_name: Optional[str] = Field(
        None,
        description="OBSOLETE. Will be removed in future releases - use destinations instead. Name of a distribution group. The release will be associated with this distribution group. If the distribution group doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.",
    )
    mandatory_update: Optional[bool] = Field(
        None,
        description='A boolean which determines whether this version should be a mandatory update or not.',
    )
    metadata: Optional[Metadata] = Field(
        None, description='An object containing all the release metadata.'
    )
    notify_testers: Optional[bool] = Field(
        True,
        description='A boolean which determines whether to notify testers of a new release, default to true.',
    )
    release_notes: Optional[str] = Field(
        None, description='Release notes for this release.'
    )


class Destination6(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None


class ReleaseUpdateResponse(BaseModel):
    destinations: Optional[List[Destination6]] = None
    enabled: Optional[bool] = None
    mandatory_update: Optional[bool] = None
    provisioning_status_url: Optional[str] = None
    release_notes: Optional[str] = None


class ReleaseWithDistributionGroup(BaseModel):
    release: str = Field(..., description='Release Id.\n')
    distribution_group: Optional[str] = Field(
        None, description='Distribution group Id.\n'
    )


class ReleaseWithDistributionGroupAndUserId(BaseModel):
    distribution_group: Optional[str] = Field(
        None, description='Distribution group Id.\n'
    )
    release: str = Field(..., description='Release Id.\n')
    user_id: Optional[UUID] = Field(
        None,
        description='Unique user Id.  Will generate a new user Id if not provided.\n',
    )


class State13(Enum):
    unauthorized = 'unauthorized'
    inactive = 'inactive'
    active = 'active'


class RepoConfig(BaseModel):
    installation_id: Optional[str] = Field(
        None,
        description='The GitHub App Installation id. Required for repositories connected from GitHub App',
    )
    external_user_id: Optional[str] = Field(
        None,
        description='The external user id from the repository provider. Required for GitLab.com repositories',
    )
    repo_id: Optional[str] = Field(
        None,
        description='The repository id from the repository provider. Required for repositories connected from GitHub App and GitLab.com',
    )
    repo_url: str = Field(
        ...,
        description="The repository's git url, must be a HTTPS URL",
        examples=['https://github.com/foo/bar.git'],
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='The id of the service connection (private). Required for GitLab self-hosted repositories',
    )
    id: str = Field(..., description='Repository configuration identifier')
    state: State13 = Field(..., description='State of the configuration')
    type: str = Field(..., description='Type of repository')
    user_email: Optional[str] = Field(
        None, description='Email of the user who linked the repository'
    )


class RepoConfigCommon(BaseModel):
    external_user_id: Optional[str] = Field(
        None,
        description='The external user id from the repository provider. Required for GitLab.com repositories',
    )
    repo_id: Optional[str] = Field(
        None,
        description='The repository id from the repository provider. Required for repositories connected from GitHub App and GitLab.com',
    )
    repo_url: Optional[str] = Field(
        None,
        description="The repository's git url, must be a HTTPS URL",
        examples=['https://github.com/foo/bar.git'],
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='The id of the service connection (private). Required for GitLab self-hosted repositories',
    )


class RepoConfigPostRequest(BaseModel):
    external_user_id: Optional[str] = Field(
        None,
        description='The external user id from the repository provider. Required for GitLab.com repositories',
    )
    repo_id: Optional[str] = Field(
        None,
        description='The repository id from the repository provider. Required for repositories connected from GitHub App and GitLab.com',
    )
    repo_url: str = Field(
        ...,
        description="The repository's git url, must be a HTTPS URL",
        examples=['https://github.com/foo/bar.git'],
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='The id of the service connection (private). Required for GitLab self-hosted repositories',
    )
    installation_id: Optional[str] = Field(
        None,
        description='The GitHub App Installation id. Required for repositories connected from GitHub App',
    )


class RepoConfig1(BaseModel):
    installation_id: Optional[str] = Field(
        None,
        description='The GitHub App Installation id. Required for repositories connected from GitHub App',
    )
    external_user_id: Optional[str] = Field(
        None,
        description='The external user id from the repository provider. Required for GitLab.com repositories',
    )
    repo_id: Optional[str] = Field(
        None,
        description='The repository id from the repository provider. Required for repositories connected from GitHub App and GitLab.com',
    )
    repo_url: str = Field(
        ...,
        description="The repository's git url, must be a HTTPS URL",
        examples=['https://github.com/foo/bar.git'],
    )
    service_connection_id: Optional[str] = Field(
        None,
        description='The id of the service connection (private). Required for GitLab self-hosted repositories',
    )
    id: str = Field(..., description='Repository configuration identifier')
    state: State13 = Field(..., description='State of the configuration')
    type: str = Field(..., description='Type of repository')
    user_email: Optional[str] = Field(
        None, description='Email of the user who linked the repository'
    )


class RepoConfigs(RootModel[List[RepoConfig1]]):
    root: List[RepoConfig1] = Field(..., description='A list of repo configurations')


class RepoInfo(BaseModel):
    external_user_id: Optional[str] = Field(None, description='The external user ID')
    repo_url: str = Field(..., description='The repository url')


class ResendVerificationRequest(BaseModel):
    name: str = Field(
        ..., description='The email or name of the user to resend verification'
    )


class ResetPasswordUsingTokenRequest(BaseModel):
    new_password: str = Field(
        ...,
        description='The new password. Needs to be at least 8 characters long and contain at least one lower- and one uppercase letter.',
    )
    token: str = Field(
        ..., description='The reset password token that was sent to the user'
    )


class ResignAttemptResponse(BaseModel):
    appId: str = Field(
        ..., description='App ID that the resign operation is being performed against.'
    )
    contextId: str = Field(..., description='Context ID for the resigning operation.')
    destinations: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='List of destinations that the resign operation is being performed against.',
    )
    errorCode: Optional[str] = Field(
        None, description='Error code associated with the exception.'
    )
    errorMessage: Optional[str] = Field(
        None, description='Error message associated with the exception.'
    )
    originalReleaseId: float = Field(
        ..., description='ID of the release which is being resigned.'
    )
    resignId: str = Field(..., description='ID of the resign operation.')
    startTime: float = Field(
        ..., description='The time that the resign operation was started.'
    )
    status: str = Field(..., description='The status of the resigning operation.')
    userId: str = Field(
        ..., description='ID of the user performing the resign operaiton.'
    )


class ResignInfo(BaseModel):
    certificate_expiration: Optional[str] = Field(
        None,
        description='The expiration date of the certificate used for the resign attempt',
    )
    certificate_name: Optional[str] = Field(
        None, description='The name of the certificate used for the resign attempt'
    )
    group_name: Optional[str] = Field(
        None, description='The group name of the resign attempt'
    )
    profile_name: Optional[str] = Field(
        None,
        description='The provisioning profile name of group for the given resign attempt',
    )
    profile_type: Optional[str] = Field(
        None,
        description='The provisioning profile type of group for the given resign attempt',
    )


class ResignStatus(BaseModel):
    error_code: Optional[str] = Field(
        None,
        description='Error code for any error that occured during the resigning operation.',
    )
    error_message: Optional[str] = Field(
        None,
        description='Error message for any error that occured during the resigning operation.',
    )
    status: str = Field(..., description='The status of the resign')


class RetentionInDays1(Enum):
    integer_28 = 28
    integer_90 = 90


class RetentionSettings(BaseModel):
    retention_in_days: RetentionInDays1


class SecretDetails(BaseModel):
    id_token: Optional[str] = Field(None, description='the id token of user')
    refresh_token: Optional[str] = Field(None, description='the refresh token for user')
    refresh_token_expiry: Optional[str] = Field(
        None, description='the expiry of refresh token'
    )


class SendNotificationRequest(BaseModel):
    userIds: List[str] = Field(..., description='user list to send email notification')


class Plan11(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class ByAccount7(BaseModel):
    count: Optional[int] = Field(
        None, description='Number of instances of the billing plan.'
    )
    plan: Optional[Plan11] = Field(None, description='Billing Plan')


class CurrentBillingPeriod6(BaseModel):
    byAccount: Optional[ByAccount7] = Field(
        None, description='Selection of a billing plan'
    )
    endTime: Optional[str] = Field(None, description='Exclusive end of the period.')
    startTime: Optional[str] = Field(None, description='Inclusive start of the period')


class ServiceBillingPlans(BaseModel):
    canSelectTrialPlan: Optional[bool] = Field(
        None,
        description='Can customer select trial plan for that service (if it exists)?',
    )
    currentBillingPeriod: Optional[CurrentBillingPeriod6] = Field(
        None, description='Billing plans for a given period'
    )
    lastTrialPlanExpirationTime: Optional[str] = Field(
        None,
        description='Expiration time of the last selected trial plan. Will be null if trial plan was not used.',
    )


class Subscription(BaseModel):
    message_count: float = Field(
        ..., description='The number of messages in the subscription'
    )
    name: str = Field(
        ..., description='The name of the subsciption (prefixed with the topic name)'
    )


class ServiceBusStatusResponse(BaseModel):
    status: str
    subscriptions: Optional[List[Subscription]] = None


class ServiceResourceUsage(BaseModel):
    currentUsagePeriod: Optional[CurrentUsagePeriod] = Field(
        None, description='Usage for a single period'
    )


class SessionCount(BaseModel):
    count: Optional[int] = Field(None, description='Count of the object.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class SessionCounts(RootModel[List[SessionCount]]):
    root: List[SessionCount]


class DistributionItem(BaseModel):
    bucket: Optional[str] = Field(None, description='The bucket name.')
    count: Optional[int] = Field(
        None, description='The count of sessions in current bucket.'
    )


class SessionDurationsDistribution(BaseModel):
    average_duration: Optional[str] = Field(
        None, description='The average session duration for current time range.'
    )
    distribution: Optional[List[DistributionItem]] = Field(
        None, description='The count of sessions in these buckets.'
    )
    previous_average_duration: Optional[str] = Field(
        None,
        description='The previous average session duration for previous time range.',
    )


class SessionsPerUserItem(BaseModel):
    count: Optional[float] = Field(None, description='Count.')
    datetime: Optional[str] = Field(None, description='The ISO 8601 datetime.')


class SessionsPerDevice(BaseModel):
    average_sessions_per_user: Optional[float] = Field(
        None, description='Average seesion per user.'
    )
    previous_average_sessions_per_user: Optional[float] = Field(
        None, description='Previous average session per user.'
    )
    previous_total_count: Optional[int] = Field(
        None, description='Previous total count.'
    )
    sessions_per_user: Optional[List[SessionsPerUserItem]] = Field(
        None, description='The session count for each interval per device.'
    )
    total_count: Optional[int] = Field(
        None, description='Total session per device count.'
    )


class SharedConnectionDetails(BaseModel):
    password: Optional[str] = Field(
        None, description='password to connect to shared connection.'
    )
    username: Optional[str] = Field(
        None, description='username to connect to shared connection.'
    )


class SharedConnectionPatchRequest(BaseModel):
    data: Dict[str, Any] = Field(
        ..., description='Represents the data for connecting to service'
    )
    displayName: Optional[str] = Field(
        None, description='Display name of the shared connection'
    )


class Data15(BaseModel):
    password: Optional[str] = Field(
        None, description='password to connect to shared connection.'
    )
    username: Optional[str] = Field(
        None, description='username to connect to shared connection.'
    )


class SharedConnectionRequest(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        'credentials',
        description='credential type of the shared connection. Values can be credentials|certificate',
    )
    data: Optional[Data15] = Field(None, description='shared connection details')
    displayName: Optional[str] = Field(
        None, description='display name of shared connection'
    )
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate',
    )


class SharedConnectionResponse(BaseModel):
    credentialType: Optional[CredentialType] = Field(
        None, description='the type of the credential'
    )
    displayName: str = Field(..., description='display name of shared connection')
    serviceType: ServiceType = Field(
        ...,
        description='service type of shared connection can be apple|gitlab|googleplay|jira',
    )


class SkipValidationRequest(BaseModel):
    skip_validation: Optional[bool] = Field(
        None, description='true if we want to skip the validation, false otherwise'
    )


class SourceRepository(BaseModel):
    clone_url: Optional[str] = Field(
        None, description='URL used to clone the repository'
    )
    name: Optional[str] = Field(None, description='The repository name')


class SourceRepositories(RootModel[List[SourceRepository]]):
    root: List[SourceRepository] = Field(
        ..., description='A list of source repositories'
    )


class StackFrame(BaseModel):
    address: Optional[str] = Field(None, description='address of the frame')
    app_code: bool = Field(..., description="this line isn't from any framework")
    class_method: Optional[bool] = Field(None, description='is a class method')
    class_name: Optional[str] = Field(None, description='name of the class')
    code_formatted: str = Field(..., description='Formatted frame string')
    code_raw: str = Field(..., description='Raw frame string')
    file: Optional[str] = Field(None, description='name of the file')
    framework_name: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language15] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    method_params: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    relevant: Optional[bool] = Field(None, description='frame should be shown always')


class Type71(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class StartServiceLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type71 = Field(..., description='Log type.\n')
    services: Optional[List[str]] = Field(
        None,
        description='The list of services of the AppCenter Start API call.',
        min_length=1,
    )


class StartServiceLogDiagnostics(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type71 = Field(..., description='Log type.\n')
    services: Optional[List[str]] = Field(
        None,
        description='The list of services of the AppCenter Start API call.',
        min_length=1,
    )


class StartSessionLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type71 = Field(..., description='Log type.\n')
    session_id: UUID = Field(..., description='Session ID.\n')


class StartSessionLogDiagnostics(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type71 = Field(..., description='Log type.\n')
    session_id: UUID = Field(..., description='Session ID.\n')


class Status11(BaseModel):
    status: str


class StatusData(BaseModel):
    status: Optional[str] = Field(None, description='status from store')
    storetype: Optional[str] = Field(None, description='store type')
    track: Optional[str] = Field(None, description='track information from store')
    version: Optional[str] = Field(None, description='version of the app from store')


class StatusResponse(BaseModel):
    status: str


class Urls(BaseModel):
    large: str
    medium: str
    original: str
    small: str


class Screenshot(BaseModel):
    landscape: bool
    rotation: float
    urls: Urls


class DeviceScreenshot(BaseModel):
    appium_log_file: Optional[str] = None
    crash_data: Optional[List[str]] = None
    device_snapshot_id: Optional[str] = None
    id: Optional[str] = None
    log_file: Optional[str] = None
    raw_crash_data: Optional[List[str]] = None
    screenshot: Optional[Screenshot] = None
    stacktrace: Optional[List[str]] = None
    status: Optional[str] = None
    title: Optional[str] = None


class StepReport(BaseModel):
    deviceScreenshots: List[DeviceScreenshot]
    finishedSnapshots: List[str]


class StoreType(Enum):
    intune = 'intune'


class StoreDestinationDetails(BaseModel):
    appId: Optional[str] = Field(None, description='app id of application.')
    dest_publish_id: Optional[str] = Field(
        None,
        description='destination ID identifying a unique id in distribution store.',
    )
    store_type: Optional[StoreType] = Field(None, description='type of store.')


class StoreNotification(BaseModel):
    service: Optional[str] = None
    status: Optional[str] = None
    valid_until: Optional[int] = None


class StorePatchRequest(BaseModel):
    service_connection_id: str = Field(
        ..., description='Service connection id to updated.'
    )


class StoreSecretResponse(BaseModel):
    id: Optional[str] = Field(None, description='Store id')
    name: Optional[str] = Field(None, description='Store Name')
    secret: Optional[str] = Field(None, description='Secret Json')
    tenant_id: Optional[str] = Field(None, description='Tenant Id for Intune')
    type: Optional[str] = Field(None, description='Store Type')


class Type75(Enum):
    intune = 'intune'
    googleplay = 'googleplay'


class StoresBasicDetails(BaseModel):
    id: Optional[str] = Field(
        None, description='ID identifying a unique distribution store.'
    )
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type75] = Field(
        None,
        description='type of the distribution store currently stores type can be intune or googleplay.',
    )


class Type76(Enum):
    googleplay = 'googleplay'
    intune = 'intune'
    apple = 'apple'


class DistributionStore3(BaseModel):
    id: Optional[str] = Field(
        None, description='ID identifying a unique distribution store.'
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution store.',
    )
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None,
        description='A status identifying the status of release in the distribution store.',
    )
    type: Optional[Type76] = Field(
        None, description='A type identifying the type of distribution store.'
    )


class StoresBasicReleaseDetails(BaseModel):
    destination_type: Optional[DestinationType] = Field(
        None, description='Destination for this release.'
    )
    distribution_stores: Optional[List[DistributionStore3]] = Field(
        None,
        description='a list of distribution stores that are associated with this release.',
    )
    id: Optional[float] = Field(None, description='ID identifying this unique release.')
    short_version: Optional[str] = Field(
        None,
        description="The release's short version.\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: Optional[str] = Field(
        None, description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: Optional[str] = Field(
        None,
        description="The release's version.\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class StoresDetails(BaseModel):
    id: Optional[str] = Field(
        None, description='ID identifying a unique distribution store.'
    )
    is_latest: Optional[bool] = Field(
        None,
        description='Is the containing release the latest one in this distribution store.',
    )
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None,
        description='A status identifying the status of release in the distribution store.',
    )
    type: Optional[Type76] = Field(
        None, description='A type identifying the type of distribution store.'
    )


class Type78(Enum):
    intune = 'intune'
    googleplay = 'googleplay'


class DistributionStore4(BaseModel):
    id: Optional[str] = Field(
        None, description='ID identifying a unique distribution store.'
    )
    name: Optional[str] = Field(
        None, description='A name identifying a unique distribution store.'
    )
    publishing_status: Optional[str] = Field(
        None, description='publishing status of the release in the store.'
    )
    type: Optional[Type78] = Field(
        None,
        description='type of the distribution store currently stores type can be intune or googleplay.',
    )


class InstallUrl(Enum):
    group = 'group'
    store = 'store'


class Status12(Enum):
    available = 'available'
    unavailable = 'unavailable'


class StoresReleaseDetails(BaseModel):
    android_min_api_level: Optional[str] = Field(
        None, description="The release's minimum required Android API level."
    )
    app_display_name: Optional[str] = Field(None, description="The app's display name.")
    app_name: Optional[str] = Field(
        None, description="The app's name (extracted from the uploaded release)."
    )
    bundle_identifier: Optional[str] = Field(
        None, description='The identifier of the apps bundle.'
    )
    distribution_stores: Optional[List[DistributionStore4]] = Field(
        None,
        description='a list of distribution stores that are associated with this release.',
    )
    download_url: Optional[str] = Field(
        None, description='The URL that hosts the binary for this release.'
    )
    fingerprint: Optional[str] = Field(
        None, description='MD5 checksum of the release binary.'
    )
    id: Optional[float] = Field(None, description='ID identifying this unique release.')
    install_url: Optional[InstallUrl] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    min_os: Optional[str] = Field(
        None, description="The release's minimum required operating system."
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    short_version: Optional[str] = Field(
        None,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    size: Optional[float] = Field(None, description="The release's size in bytes.")
    status: Optional[Status12] = Field(
        None,
        description="OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>\nThe release state.<br>\n<b>available</b>: The uploaded release has been distributed.<br>\n<b>unavailable</b>: The uploaded release is not visible to the user. <br>\n",
    )
    uploaded_at: Optional[str] = Field(
        None, description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: Optional[str] = Field(
        None,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.\nFor Android: android:versionCode from AppManifest.xml.\n",
    )


class StringProperty(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: constr(max_length=128) = Field(..., description='String property value.')


class StringPropertyDiagnostics(BaseModel):
    name: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9\-_]*$', max_length=128)
    type: str
    value: constr(max_length=128) = Field(..., description='String property value.')


class Request(Enum):
    Delete = 'Delete'
    Purge = 'Purge'
    UndoDelete = 'UndoDelete'
    Export = 'Export'


class SubmitDsrOperationRequest(BaseModel):
    accountId: Optional[str] = None
    appId: Optional[str] = None
    operationId: Optional[str] = Field(
        None,
        description='The DSR operation ID provided by the GDPR coordinator. Used for tracking only.',
    )
    request: Optional[Request] = None
    requestId: Optional[str] = Field(
        None,
        description='Request ID provided by the GDPR coordinator. Used for tracking.',
    )


class Status13(Enum):
    NotStarted = 'NotStarted'
    InProgress = 'InProgress'
    Completed = 'Completed'
    Failure = 'Failure'


class SubmitDsrOperationResponse(BaseModel):
    status: Optional[Status13] = Field(
        None, description='The status of the DSR operation'
    )


class Tier(BaseModel):
    name: Optional[str] = Field(None, description='The name of the tier')


class Subscription1(BaseModel):
    active: Optional[bool] = Field(
        None, description='Is the subscription currently active?'
    )
    concurrentDevicesLimit: Optional[int] = Field(
        None, description='Customer limits on concurrent devices'
    )
    daysLeft: Optional[float] = Field(
        None, description='The number of days left in the subscription'
    )
    endsAt: Optional[str] = Field(
        None, description='The date the subscription will end or ended'
    )
    id: Optional[UUID] = Field(None, description='Id of the subscription')
    runningDevices: Optional[int] = Field(
        None, description='Current device concurrency utilization'
    )
    startsAt: Optional[str] = Field(None, description='The date the subscription began')
    tier: Optional[Tier] = Field(None, title='Subscription Tier')


class SubscriptionMetrics(BaseModel):
    message_count: float = Field(
        ..., description='The number of messages in the subscription'
    )
    name: str = Field(
        ..., description='The name of the subsciption (prefixed with the topic name)'
    )


class SuccessResponse(BaseModel):
    message: str


class Origin36(Enum):
    System = 'System'
    User = 'User'


class Status14(Enum):
    available = 'available'
    ignored = 'ignored'


class Type79(Enum):
    Apple = 'Apple'
    JavaScript = 'JavaScript'
    Breakpad = 'Breakpad'
    AndroidProguard = 'AndroidProguard'
    UWP = 'UWP'


class Symbol(BaseModel):
    alternate_symbol_ids: List[str] = Field(
        ..., description='The other symbols in the same file'
    )
    app_id: str = Field(..., description='The application that this symbol belongs to')
    build: Optional[str] = Field(
        None, description='The build number. Optional for Apple. Required for Android.'
    )
    origin: Origin36 = Field(..., description='The origin of the symbol file')
    platform: str = Field(
        ..., description='The platform that this symbol is associated with'
    )
    status: Status14 = Field(..., description='Whether the symbol is ignored.')
    symbol_id: str = Field(..., description='The unique id for this symbol (uuid)')
    symbol_upload_id: str = Field(
        ..., description='The id of the symbol upload this symbol belongs to.'
    )
    type: Type79 = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    url: str = Field(
        ..., description='The path name of the symbol file in blob storage'
    )
    version: Optional[str] = Field(
        None,
        description='The version number. Optional for Apple. Required for Android.',
    )


class SymbolLocation(BaseModel):
    uri: str


class Status15(Enum):
    available = 'available'
    ignored = 'ignored'
    missing = 'missing'


class SymbolStatusResponse(BaseModel):
    app_id: str = Field(..., description='The application that this symbol belongs to')
    status: Status15 = Field(..., description='Whether the symbol is ignored.')
    symbol_id: str = Field(..., description='The unique id for this symbol (uuid)')


class Origin37(Enum):
    User = 'User'
    System = 'System'


class Status16(Enum):
    created = 'created'
    committed = 'committed'
    aborted = 'aborted'
    processing = 'processing'
    indexed = 'indexed'
    failed = 'failed'


class SymbolType(Enum):
    Apple = 'Apple'
    JavaScript = 'JavaScript'
    Breakpad = 'Breakpad'
    AndroidProguard = 'AndroidProguard'
    UWP = 'UWP'


class SymbolsUploadedItem(BaseModel):
    platform: str = Field(..., description='The platform the symbol is associated with')
    symbol_id: str = Field(..., description='The symbol id of the symbol binary')


class User2(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: Optional[str] = Field(None, description='The email of the user')


class SymbolUpload(BaseModel):
    app_id: str = Field(
        ..., description='The application that this symbol upload belongs to'
    )
    file_name: Optional[str] = Field(
        None, description='The file name for the symbol upload'
    )
    file_size: Optional[float] = Field(
        None,
        description='The size of the file in Mebibytes. This may be 0 until the status is indexed',
    )
    origin: Optional[Origin37] = Field(
        None, description='The origin of the symbol upload'
    )
    status: Status16 = Field(
        ..., description='The current status for the symbol upload'
    )
    symbol_type: SymbolType = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    symbol_upload_id: str = Field(
        ..., description='The id for the current symbol upload'
    )
    symbols_uploaded: Optional[List[SymbolsUploadedItem]] = Field(
        None,
        description='The symbols found in the upload. This may be empty until the status is indexed',
    )
    timestamp: Optional[datetime_aliased] = Field(
        None,
        description='When the symbol upload was committed, or last transaction time if not committed',
    )
    user: Optional[User2] = Field(
        None, description='User information of the one who intitiated the symbol upload'
    )


class SymbolUploadBeginRequest(BaseModel):
    build: Optional[str] = Field(
        None, description='The build number. Optional for Apple. Required for Android.'
    )
    client_callback: Optional[str] = Field(
        None,
        description='The callback URL that the client can optionally provide to get status updates for the current symbol upload',
    )
    file_name: Optional[str] = Field(
        None, description='The file name for the symbol upload'
    )
    symbol_type: SymbolType = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    version: Optional[str] = Field(
        None,
        description='The version number. Optional for Apple. Required for Android.',
    )


class SymbolUploadBeginResponse(BaseModel):
    expiration_date: datetime_aliased = Field(
        ..., description='Describes how long the upload_url is valid'
    )
    symbol_upload_id: str = Field(..., description='The id for the current upload')
    upload_url: str = Field(
        ..., description='The URL where the client needs to upload the symbol blob to'
    )


class Status17(Enum):
    committed = 'committed'
    aborted = 'aborted'


class SymbolUploadEndRequest(BaseModel):
    status: Status17 = Field(
        ..., description='The desired operation for the symbol upload'
    )


class SymbolUploadLocation(BaseModel):
    uri: str


class SymbolUploadUserInfo(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: Optional[str] = Field(None, description='The email of the user')


class Status18(Enum):
    created = 'created'
    committed = 'committed'
    aborted = 'aborted'
    processing = 'processing'
    indexed = 'indexed'
    failed = 'failed'


class SymbolUpload1(BaseModel):
    app_id: str = Field(
        ..., description='The application that this symbol upload belongs to'
    )
    file_name: Optional[str] = Field(
        None, description='The file name for the symbol upload'
    )
    file_size: Optional[float] = Field(
        None,
        description='The size of the file in Mebibytes. This may be 0 until the status is indexed',
    )
    origin: Optional[Origin37] = Field(
        None, description='The origin of the symbol upload'
    )
    status: Status18 = Field(
        ..., description='The current status for the symbol upload'
    )
    symbol_type: SymbolType = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    symbol_upload_id: str = Field(
        ..., description='The id for the current symbol upload'
    )
    symbols_uploaded: Optional[List[SymbolsUploadedItem]] = Field(
        None,
        description='The symbols found in the upload. This may be empty until the status is indexed',
    )
    timestamp: Optional[datetime_aliased] = Field(
        None,
        description='When the symbol upload was committed, or last transaction time if not committed',
    )
    user: Optional[User2] = Field(
        None, description='User information of the one who intitiated the symbol upload'
    )


class SymbolUploads(RootModel[List[SymbolUpload1]]):
    root: List[SymbolUpload1] = Field(
        ..., description='A set of symbol upload entities'
    )


class Origin39(Enum):
    System = 'System'
    User = 'User'


class Status19(Enum):
    available = 'available'
    ignored = 'ignored'


class Symbol1(BaseModel):
    alternate_symbol_ids: List[str] = Field(
        ..., description='The other symbols in the same file'
    )
    app_id: str = Field(..., description='The application that this symbol belongs to')
    build: Optional[str] = Field(
        None, description='The build number. Optional for Apple. Required for Android.'
    )
    origin: Origin39 = Field(..., description='The origin of the symbol file')
    platform: str = Field(
        ..., description='The platform that this symbol is associated with'
    )
    status: Status19 = Field(..., description='Whether the symbol is ignored.')
    symbol_id: str = Field(..., description='The unique id for this symbol (uuid)')
    symbol_upload_id: str = Field(
        ..., description='The id of the symbol upload this symbol belongs to.'
    )
    type: Type79 = Field(
        ..., description='The type of the symbol for the current symbol upload'
    )
    url: str = Field(
        ..., description='The path name of the symbol file in blob storage'
    )
    version: Optional[str] = Field(
        None,
        description='The version number. Optional for Apple. Required for Android.',
    )


class Symbols(RootModel[List[Symbol1]]):
    root: List[Symbol1] = Field(
        ...,
        description='A response containing the list of symbols matching the specified filter (if any was provided)',
    )


class SystemVersionNameGroup(BaseModel):
    name: Optional[str] = Field(None, description='Name of version group')
    versions: Optional[List[str]] = None


class SystemVersionNameGroups(RootModel[List[SystemVersionNameGroup]]):
    root: List[SystemVersionNameGroup] = Field(
        ..., description='A list of symbol name group entities'
    )


class TeamAppResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the team')
    display_name: str = Field(..., description='The display name of the team')
    id: UUID = Field(..., description='The internal unique id (UUID) of the team.')
    name: str = Field(..., description='The name of the team')
    permissions: Optional[List[Permission]] = Field(
        None, description='The permissions the team has for the app'
    )


class Permission7(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'


class TeamAppUpdateRequest(BaseModel):
    permissions: List[Permission7] = Field(
        ..., description='The permissions all members of the team have on the app'
    )


class TeamRequest(BaseModel):
    description: Optional[str] = Field(None, description='The description of the team')
    display_name: str = Field(..., description='The display name of the team')
    name: Optional[str] = Field(None, description='The name of the team')


class TeamResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the team')
    display_name: str = Field(..., description='The display name of the team')
    id: UUID = Field(..., description='The internal unique id (UUID) of the team.')
    name: str = Field(..., description='The name of the team')


class TeamUpdateRequest(BaseModel):
    display_name: str = Field(..., description='The new display name of the team')


class Role4(Enum):
    maintainer = 'maintainer'
    collaborator = 'collaborator'


class TeamUserResponse(BaseModel):
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    role: Role4 = Field(..., description='The role of the user has within the team')


class TestCloudErrorDetails(BaseModel):
    message: str = Field(
        ..., description='Human-readable message that describes the error'
    )
    status: str = Field(..., description='Status of the operation')


class FileType(Enum):
    dsym_file = 'dsym-file'
    app_file = 'app-file'
    test_file = 'test-file'


class TestCloudFileHash(BaseModel):
    checksum: str = Field(..., description='SHA256 hash of the file')
    fileType: FileType = Field(..., description='Type of the file')
    relativePath: str = Field(..., description='Relative path of the file')


class TestCloudFileHashDeprecated(BaseModel):
    byte_range: Optional[str] = Field(
        None, description='Range of bytes required to verify ownership of the file'
    )
    checksum: str = Field(..., description='SHA256 hash of the file')
    file_type: FileType = Field(..., description='Type of the file')
    relative_path: str = Field(..., description='Relative path of the file')


class UploadStatus3(BaseModel):
    location: Optional[str] = Field(
        None,
        description="URI that should be used to make POST request if file with given hash doesn't exist. This is set when status_code is equal to 412",
    )
    statusCode: float = Field(
        ..., description='HTTP status code that represent result of upload'
    )


class TestCloudFileHashResponse(BaseModel):
    checksum: str = Field(..., description='SHA256 hash of the file')
    fileType: FileType = Field(..., description='Type of the file')
    relativePath: Optional[str] = Field(None, description='Relative path of the file')
    uploadStatus: UploadStatus3 = Field(
        ..., description='Status of the upload', title='Test Cloud Hash Upload Status'
    )


class TestCloudHashUploadStatus(BaseModel):
    location: Optional[str] = Field(
        None,
        description="URI that should be used to make POST request if file with given hash doesn't exist. This is set when status_code is equal to 412",
    )
    statusCode: float = Field(
        ..., description='HTTP status code that represent result of upload'
    )


class FrameworkProperties(BaseModel):
    configurations: Optional[List[str]] = None


class FrameworkType(Enum):
    Appium = 'Appium'
    Calabash = 'Calabash'
    Espresso = 'Espresso'
    UITest = 'UITest'
    Generated = 'Generated'


class TestCloudProject(BaseModel):
    frameworkProperties: Optional[FrameworkProperties] = None
    frameworkType: FrameworkType
    path: str = Field(..., description='The path to the TestCloud project')


class TestCloudProjectFrameworkProperties(BaseModel):
    configurations: Optional[List[str]] = None


class TestCloudStartTestRunOptions(BaseModel):
    device_selection: str = Field(..., description='Device selection string.')
    language: Optional[str] = Field(
        None, description='Language that should be used to run tests.'
    )
    locale: Optional[str] = Field(
        None, description='Locale that should be used to run tests.'
    )
    test_framework: str = Field(..., description='Test framework used by tests.')
    test_parameters: Optional[Dict[str, Any]] = Field(
        None, description='A JSON dictionary with additional test parameters'
    )
    test_series: Optional[str] = Field(None, description='Name of the test series.')


class TestCloudStartTestRunResult(BaseModel):
    accepted_devices: Optional[List[str]] = Field(
        None, description='List with names of accepted devices'
    )
    rejected_devices: Optional[List[str]] = Field(
        None, description='List with names and descriptions of rejected devices'
    )


class Project(BaseModel):
    frameworkProperties: Optional[FrameworkProperties] = None
    frameworkType: FrameworkType
    path: str = Field(..., description='The path to the TestCloud project')


class TestCloudToolset(BaseModel):
    projects: List[Project] = Field(..., description='The TestCloud projects detected')


class TestGDPRAccount(BaseModel):
    id: Optional[UUID] = None


class TestGDPRApp(BaseModel):
    hash_files_url: Optional[str] = None


class TestGDPRFeatureFlag(BaseModel):
    name: Optional[str] = None
    target_id: Optional[UUID] = None


class TestGDPRFileSetFile(BaseModel):
    app_upload_id: Optional[UUID] = None
    hash_file_id: Optional[UUID] = None
    hash_file_url: Optional[str] = None
    path: Optional[str] = None


class TestGDPRHashFile(BaseModel):
    filename: Optional[str] = None
    id: Optional[UUID] = None


class TestGDPRPipelineTest(BaseModel):
    app_upload_id: Optional[UUID] = None
    test_parameters: Optional[Dict[str, Any]] = None


class Resource(BaseModel):
    path: Optional[str] = None
    rel: Optional[str] = None


class TestGDPRResourceList(BaseModel):
    resources: Optional[List[Resource]] = None


class TestGDPRTestRun(BaseModel):
    app_hash_file_id: Optional[UUID] = None
    app_hash_file_url: Optional[str] = None
    app_icon_url: Optional[str] = None
    dsym_hash_file_id: Optional[UUID] = None
    dsym_hash_file_url: Optional[str] = None
    id: Optional[UUID] = None
    locale: Optional[str] = None


class DeviceLog(BaseModel):
    appium_log: Optional[str] = None
    device_log: Optional[str] = None
    device_snapshot_id: Optional[str] = None
    test_log: Optional[str] = None


class StepExecution(BaseModel):
    device_snapshot_id: Optional[str] = None
    status: Optional[str] = None
    timestamp: Optional[float] = None


class Step1(BaseModel):
    failed: Optional[float] = None
    id: Optional[str] = None
    skipped: Optional[float] = None
    stepExecutions: Optional[List[StepExecution]] = None
    stepName: Optional[str] = None
    step_report_url: Optional[str] = None


class Run(BaseModel):
    failed: Optional[float] = None
    id: Optional[str] = None
    number: Optional[float] = None
    report_url: Optional[str] = None
    skipped: Optional[float] = None
    steps: Optional[List[Step1]] = None


class Test(BaseModel):
    peakDuration: Optional[float] = None
    peakMemory: Optional[float] = None
    runs: Optional[List[Run]] = None
    testName: Optional[str] = None


class Feature(BaseModel):
    failed: Optional[float] = None
    name: Optional[str] = None
    peakDuration: Optional[float] = None
    peakMemory: Optional[float] = None
    skipped: Optional[float] = None
    tests: Optional[List[Test]] = None


class SnapshotFatalError(BaseModel):
    device_snapshot_id: Optional[str] = None
    error_message: Optional[str] = None
    error_title: Optional[str] = None


class Stats(BaseModel):
    artifacts: Optional[Dict[str, str]] = None
    devices: float
    devices_failed: float
    devices_finished: float
    devices_not_runned: float
    devices_skipped: float
    failed: float
    filesize: float
    os: float
    passed: float
    skipped: float
    step_count: float
    total: float
    totalDeviceMinutes: float


class TestReport(BaseModel):
    app_upload_id: str
    date: str
    date_finished: str
    device_logs: List[DeviceLog]
    errorMessage: Optional[str] = None
    features: List[Feature]
    finished_device_snapshots: List[str]
    id: str
    platform: str
    revision: float
    schema_version: float
    snapshot_fatal_errors: Optional[List[SnapshotFatalError]] = None
    stats: Stats
    testType: str


class Stats1(BaseModel):
    devices: Optional[float] = Field(
        None, description='Number of devices running the test'
    )
    devicesFailed: Optional[float] = Field(None, description='Number of failed devices')
    devicesFinished: Optional[float] = Field(
        None, description='Number of finished devices'
    )
    failed: Optional[float] = Field(None, description='Number of failed tests')
    passed: Optional[float] = Field(None, description='Number of passed tests')
    peakMemory: Optional[float] = Field(
        None, description='The max amount of MB used during the test run'
    )
    skipped: Optional[float] = Field(None, description='Number of skipped tests')
    total: Optional[float] = Field(None, description='Number of tests in total')
    totalDeviceMinutes: Optional[float] = Field(
        None,
        description='The number of minutes of device time the test has been runnign',
    )


class TestRun(BaseModel):
    appVersion: Optional[str] = Field(
        None, description='The compiled version of the app binary'
    )
    date: Optional[str] = Field(
        None, description='The date and time the test was uploaded'
    )
    description: Optional[str] = Field(
        None, description='Human readable explanation of the current test status'
    )
    id: Optional[UUID] = Field(None, description='The unique id of the test upload')
    platform: Optional[str] = Field(
        None,
        description="The device platform targeted by the test. Possible values are 'ios' or 'android'",
    )
    resultStatus: Optional[str] = Field(None, description='The passed/failed state')
    runStatus: Optional[str] = Field(
        None,
        description='The current status of the test run, in relation to the various phases',
    )
    state: Optional[str] = Field(None, description='Deprecated. Use runStatus instead.')
    stats: Optional[Stats1] = Field(
        None,
        description='Summary single test run on Xamarin Test Cloud',
        title='Test Run Statistics',
    )
    status: Optional[str] = Field(
        None, description='Deprecated. Use resultStatus instead.'
    )
    testSeries: Optional[str] = Field(
        None,
        description='The name of the test series with which this test upload is associated',
    )
    testType: Optional[str] = Field(
        None, description='The name of the test framework used to run this test'
    )


class TestRunState(BaseModel):
    exit_code: Optional[int] = Field(
        None,
        description='The exit code that the client should use when exiting. Used for indicating status to the caller of the client.\n0: test run completes with no failing tests\n1: test run completes with at least one failing test\n2: test run failed to complete. Status for test run is unknown\n',
    )
    message: Optional[List[str]] = Field(
        None, description='Multi-line message that describes the status'
    )
    wait_time: Optional[int] = Field(
        None,
        description='Time (in seconds) that the client should wait for before checking the status again',
    )


class TestRunStatistics(BaseModel):
    devices: Optional[float] = Field(
        None, description='Number of devices running the test'
    )
    devicesFailed: Optional[float] = Field(None, description='Number of failed devices')
    devicesFinished: Optional[float] = Field(
        None, description='Number of finished devices'
    )
    failed: Optional[float] = Field(None, description='Number of failed tests')
    passed: Optional[float] = Field(None, description='Number of passed tests')
    peakMemory: Optional[float] = Field(
        None, description='The max amount of MB used during the test run'
    )
    skipped: Optional[float] = Field(None, description='Number of skipped tests')
    total: Optional[float] = Field(None, description='Number of tests in total')
    totalDeviceMinutes: Optional[float] = Field(
        None,
        description='The number of minutes of device time the test has been runnign',
    )


class TestRunSummary(BaseModel):
    completed: Optional[bool] = Field(
        None, description='Tells whether the test run has completed'
    )
    date: Optional[str] = Field(None, description='Date of the test run.')
    failed: Optional[float] = Field(None, description='Number of failed tests')
    passed: Optional[float] = Field(None, description='Number of passed tests')
    statusDescription: Optional[str] = Field(
        None, description='Human-readable status of the test run.'
    )


class TestRun1(BaseModel):
    completed: Optional[bool] = Field(
        None, description='Tells whether the test run has completed'
    )
    date: Optional[str] = Field(None, description='Date of the test run.')
    failed: Optional[float] = Field(None, description='Number of failed tests')
    passed: Optional[float] = Field(None, description='Number of passed tests')
    statusDescription: Optional[str] = Field(
        None, description='Human-readable status of the test run.'
    )


class TestSeries(BaseModel):
    mostRecentActivity: Optional[str] = Field(
        None, description='Date of the latest test run that used this test series'
    )
    name: str = Field(..., description='Name of the test series')
    slug: str = Field(
        ..., description='Unique, human-readable identifier of the test series'
    )
    testRuns: Optional[List[TestRun1]] = Field(
        None, description='Most recent test runs'
    )


class TestSeriesName(BaseModel):
    name: str = Field(..., description='Name of the new test series')


class Origin40(Enum):
    hockeyapp = 'hockeyapp'
    appcenter = 'appcenter'


class TesterAppRelease(BaseModel):
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    id: int = Field(..., description='ID identifying this unique release.')
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    mandatory_update: bool = Field(
        ...,
        description='A boolean which determines whether the release is a mandatory update or not.',
    )
    origin: Optional[Origin40] = Field(None, description="The release's origin")
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )
    install_url: Optional[str] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    size: int = Field(..., description="The release's size in bytes.")


class Type81(Enum):
    org = 'org'
    user = 'user'


class Owner14(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: str = Field(..., description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: UUID = Field(..., description='The unique id (UUID) of the owner')
    name: str = Field(
        ..., description='The unique name that used to identify the owner'
    )
    type: Type81 = Field(
        ..., description="The owner type. Can either be 'org' or 'user'"
    )


class Permission8(Enum):
    can_remove_from_app = 'can_remove_from_app'


class TesterAppResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: str = Field(..., description='The display name of the app')
    icon_source: Optional[str] = Field(
        None, description="The string representation of the source of the app's icon"
    )
    icon_url: Optional[str] = Field(
        None,
        description="The string representation of the URL pointing to the app's icon",
    )
    id: UUID = Field(..., description='The unique ID (UUID) of the app')
    name: str = Field(..., description='The name of the app used in URLs')
    os: Os = Field(..., description='The OS the app will be running on')
    owner: Owner14 = Field(..., description="The information about the app's owner")
    release_type: Optional[str] = Field(
        None,
        description='A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase',
    )
    microsoft_internal: Optional[bool] = Field(
        None, description='it indicates if the app is microsoft internal'
    )
    permissions: Optional[List[Permission8]] = Field(
        None, description='The permissions associated with the app'
    )


class Owner15(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the owner')
    display_name: Optional[str] = Field(None, description="The owner's display name")
    email: Optional[str] = Field(None, description="The owner's email address")
    id: Optional[str] = Field(None, description='The unique id (UUID) of the owner')
    name: Optional[str] = Field(
        None, description='The unique name that used to identify the owner'
    )
    type: Optional[Type81] = Field(
        None, description="The owner type. Can either be 'org' or 'user'"
    )


class Release6(BaseModel):
    enabled: bool = Field(
        ...,
        description='This value determines the whether a release currently is enabled or disabled.',
    )
    id: int = Field(..., description='ID identifying this unique release.')
    is_external_build: Optional[bool] = Field(
        None, description='This value determines if a release is external or not.'
    )
    mandatory_update: bool = Field(
        ...,
        description='A boolean which determines whether the release is a mandatory update or not.',
    )
    origin: Optional[Origin40] = Field(None, description="The release's origin")
    short_version: str = Field(
        ...,
        description="The release's short version.<br>\nFor iOS: CFBundleShortVersionString from info.plist.<br>\nFor Android: android:versionName from AppManifest.xml.\n",
    )
    uploaded_at: str = Field(
        ..., description='UTC time in ISO 8601 format of the uploaded time.'
    )
    version: str = Field(
        ...,
        description="The release's version.<br>\nFor iOS: CFBundleVersion from info.plist.<br>\nFor Android: android:versionCode from AppManifest.xml.\n",
    )
    install_url: Optional[str] = Field(
        None,
        description='The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`',
    )
    release_notes: Optional[str] = Field(
        None, description="The release's release notes."
    )
    size: int = Field(..., description="The release's size in bytes.")


class TesterAppWithReleaseResponse(BaseModel):
    description: Optional[str] = Field(None, description='The description of the app')
    display_name: Optional[str] = Field(None, description="The app's display name.")
    icon_url: Optional[str] = Field(None, description="A URL to the app's icon.")
    id: Optional[str] = Field(None, description='The unique ID (UUID) of the app')
    name: Optional[str] = Field(None, description="The app's name.")
    os: Optional[str] = Field(None, description="The app's os.")
    owner: Optional[Owner15] = Field(
        None, description="The information about the app's owner"
    )
    release: Optional[Release6] = None


class Frame3(BaseModel):
    address: Optional[str] = Field(None, description='address of the frame')
    app_code: bool = Field(..., description="this line isn't from any framework")
    class_method: Optional[bool] = Field(None, description='is a class method')
    class_name: Optional[str] = Field(None, description='name of the class')
    code_formatted: str = Field(..., description='Formatted frame string')
    code_raw: str = Field(..., description='Raw frame string')
    file: Optional[str] = Field(None, description='name of the file')
    framework_name: Optional[str] = Field(None, description='Name of the framework')
    language: Optional[Language15] = Field(
        None, description='programming language of the frame'
    )
    line: Optional[int] = Field(None, description='line number')
    method: Optional[str] = Field(None, description='name of the method')
    method_params: Optional[str] = Field(
        None, description='parameters of the frames method'
    )
    relevant: Optional[bool] = Field(None, description='frame should be shown always')


class Platform12(Enum):
    ios = 'ios'
    android = 'android'
    xamarin = 'xamarin'
    react_native = 'react-native'
    ndk = 'ndk'
    unity = 'unity'
    other = 'other'


class Thread(BaseModel):
    crashed: Optional[bool] = Field(None, description='True if this thread crashed')
    exception: Optional[Exception] = None
    frames: List[Frame3] = Field(..., description='frames of that thread')
    platform: Optional[Platform12] = Field(
        None, description='SDK/Platform this thread is beeing generated from'
    )
    relevant: Optional[bool] = Field(
        None,
        description='Shows if a thread is relevant or not. Is false if all frames are non relevant, otherwise true',
    )
    title: str = Field(..., description='name of the thread')


class TokenQueryResult(BaseModel):
    tokens: Optional[List[str]] = Field(None, description='List of tokens.')


class ToolsetProject(BaseModel):
    name: Optional[str] = None
    path: Optional[str] = None


class BuildConfiguration3(BaseModel):
    name: str = Field(
        ..., description='Name of build configuration (the same as a build type name)'
    )
    signingConfig: Optional[SigningConfig] = Field(
        None, description='Android signing config. Null if not specified'
    )


class AndroidModule2(BaseModel):
    buildConfigurations: Optional[List[BuildConfiguration3]] = Field(
        None, description='The detected build configurations of the Android module'
    )
    buildTypes: Optional[List[str]] = Field(
        None, description='The detected build types of the Android module'
    )
    buildVariants: Optional[List[str]] = Field(
        None,
        description='The detected build variants of the Android module (matrix of product flavor + build type (debug|release))',
    )
    hasBundle: Optional[bool] = Field(
        None, description='Module contains bundle settings'
    )
    isRoot: Optional[bool] = Field(
        None, description='Whether the module is at the root level of the project'
    )
    name: str = Field(..., description='Name of the Android module')
    productFlavors: Optional[List[str]] = Field(
        None, description='The product flavors of the Android module'
    )


class Android3(BaseModel):
    androidModules: List[AndroidModule2] = Field(
        ..., description='Android Gradle modules'
    )
    gradleWrapperPath: Optional[str] = Field(
        None, description='The path of the Gradle wrapper'
    )


class Javascript3(BaseModel):
    javascriptSolutions: Optional[List[JavascriptSolution]] = Field(
        None, description='The React Native solutions detected'
    )
    packageJsonPaths: List[str] = Field(
        ..., description='Paths for detected package.json files'
    )


class Project1(BaseModel):
    frameworkProperties: Optional[FrameworkProperties] = None
    frameworkType: FrameworkType
    path: str = Field(..., description='The path to the TestCloud project')


class Testcloud(BaseModel):
    projects: List[Project1] = Field(..., description='The TestCloud projects detected')


class UwpSolution(BaseModel):
    configurations: List[str] = Field(
        ..., description='The possible configurations detected for the UWP solution'
    )
    path: str = Field(..., description='The path to the UWP solution')


class Uwp(BaseModel):
    uwpSolutions: List[UwpSolution] = Field(
        ..., description='The UWP solutions detected'
    )


class XamarinSolution(BaseModel):
    configurations: List[str] = Field(..., description='Solution configurations')
    defaultConfiguration: Optional[str] = Field(
        None, description='Solution default configuration'
    )
    path: str = Field(..., description='Path to solution')


class Xamarin3(BaseModel):
    xamarinSolutions: List[XamarinSolution] = Field(
        ..., description='Xamarin solutions for the toolset'
    )


class AppExtensionTarget(BaseModel):
    name: str = Field(..., description='App extension name')
    targetBundleIdentifier: str = Field(
        ..., description='App extension bundle identifier'
    )


class ArchiveProject(BaseModel):
    archiveTargetId: str = Field(..., description='The Id of the target to archive')
    projectName: str = Field(..., description='The project to archive container name')
    projectPath: Optional[str] = Field(
        None, description='Full path of the target project'
    )


class SharedScheme(BaseModel):
    archiveConfiguration: Optional[str] = Field(
        None, description='Build configuration set in Archive action'
    )
    archiveProject: Optional[ArchiveProject] = None
    hasTestAction: bool = Field(..., description='Does scheme have a test action?')
    name: str = Field(..., description='Scheme name')


class XcodeSchemeContainer(BaseModel):
    appExtensionTargets: Optional[List[AppExtensionTarget]] = Field(
        None, description='Information regarding project app extensions, if present'
    )
    cartfilePath: Optional[str] = Field(
        None, description='Path to Carthage file, if present'
    )
    path: str = Field(..., description='Path to project')
    podfilePath: Optional[str] = Field(
        None, description='Path to CocoaPods file, if present'
    )
    sharedSchemes: List[SharedScheme] = Field(..., description='Project schemes')
    workspaceProjectPaths: Optional[str] = Field(
        None, description='Related projects paths for xcworkspace'
    )
    xcodeProjectSha: Optional[str] = Field(
        None, description='repo object Id of the pbxproject'
    )


class Xcode3(BaseModel):
    xcodeSchemeContainers: List[XcodeSchemeContainer] = Field(
        ..., description='The Xcode scheme containers'
    )


class ToolsetProjects(BaseModel):
    android: Optional[Android3] = None
    buildscripts: Optional[Any] = Field(
        None,
        description='A collection of detected pre/post buildscripts for current platform toolset',
    )
    commit: Optional[str] = Field(
        None, description='The commit hash of the analyzed commit'
    )
    javascript: Optional[Javascript3] = None
    testcloud: Optional[Testcloud] = None
    uwp: Optional[Uwp] = None
    xamarin: Optional[Xamarin3] = None
    xcode: Optional[Xcode3] = None


class NodeItem(BaseModel):
    current: Optional[bool] = Field(
        None, description='If the Node version is default for AppCenter'
    )
    name: Optional[str] = Field(None, description='The version name')


class XamarinItem(BaseModel):
    current: Optional[bool] = Field(None, description='If the SDK is latest stable')
    monoVersion: Optional[str] = Field(None, description='The Mono version')
    sdkBundle: Optional[str] = Field(None, description='The Xamarin SDK version')
    stable: Optional[bool] = Field(None, description='If the SDK is stable')
    xcodeVersions: Optional[List[str]] = Field(
        None,
        description='Specific for iOS SDK. A list of Xcode versions supported by current SDK version',
    )


class XcodeItem(BaseModel):
    current: Optional[bool] = Field(None, description='If the Xcode is latest stable')
    name: Optional[str] = Field(None, description='The version name')


class Toolsets2(BaseModel):
    node: Optional[List[NodeItem]] = Field(None, description='A list of Node versions')
    xamarin: Optional[List[XamarinItem]] = Field(
        None, description='A list of Xamarin SDK bundles'
    )
    xcode: Optional[List[XcodeItem]] = Field(
        None, description='A list of Xcode versions'
    )


class TransferAppAdminRequest(BaseModel):
    issue_id: str = Field(..., description='The id of the related Intercom issue.')
    new_owner_id: UUID = Field(
        ..., description='The internal unique id (UUID) of the user/org.'
    )
    responsible_admin_id: UUID = Field(
        ..., description='The id of the user who started transfer process.'
    )
    transfer_reason: str = Field(
        ..., description='The explanation for starting transfer process.'
    )


class TransferRepoOwnerRequest(BaseModel):
    issue_id: str = Field(..., description='The id of the related Intercom issue.')
    new_owner_id: UUID = Field(
        ..., description='The internal unique id (UUID) of the user.'
    )
    repository_url: str = Field(
        ..., description='The url of repository to have its ownership transferred.'
    )
    responsible_admin_id: UUID = Field(
        ..., description='The id of the user who started transfer process.'
    )
    transfer_reason: str = Field(
        ..., description='The explanation for starting transfer process.'
    )


class UWPSolution(BaseModel):
    configurations: List[str] = Field(
        ..., description='The possible configurations detected for the UWP solution'
    )
    path: str = Field(..., description='The path to the UWP solution')


class UWPToolset(BaseModel):
    uwpSolutions: List[UwpSolution] = Field(
        ..., description='The UWP solutions detected'
    )


class Type83(Enum):
    event = 'event'
    page = 'page'
    start_session = 'start_session'
    error = 'error'
    push_installation = 'push_installation'
    start_service = 'start_service'
    custom_properties = 'custom_properties'


class UnhandledErrorLog(BaseModel):
    device: Device = Field(..., description='Device characteristics.')
    install_id: UUID = Field(..., description='Install ID.\n')
    timestamp: datetime_aliased = Field(..., description='Log creation timestamp.\n')
    type: Type83 = Field(..., description='Log type.\n')
    error_id: UUID = Field(..., description='Error ID.\n')


class UpdateInfo1(BaseModel):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    download_url: Optional[str] = None
    is_available: bool
    label: Optional[str] = None
    package_hash: Optional[str] = None
    package_size: Optional[float] = None
    should_run_binary_version: Optional[bool] = None
    update_app_version: Optional[bool] = None


class UpdateCheckResponse(BaseModel):
    update_info: UpdateInfo1


class Destination7(BaseModel):
    name: Optional[str] = None


class UpdateDevicesRequest(BaseModel):
    account_service_connection_id: Optional[str] = Field(
        None,
        description='The service_connection_id of the stored Apple credentials instead of username, password.',
    )
    destinations: Optional[List[Destination7]] = Field(
        None,
        description='Array of distribution groups that the devices should be provisioned from.',
    )
    devices: Optional[List[str]] = Field(
        None,
        description="Array of device UDID's to be published to the Apple Developer account.",
    )
    p12_base64: Optional[str] = Field(
        None,
        description='The certificate to use for resigning the application with the updated provisioning profiles.',
    )
    p12_password: Optional[str] = Field(
        None, description='The password certificate if one is needed.'
    )
    p12_service_connection_id: Optional[str] = Field(
        None,
        description='The service_connection_id of the stored Apple certificate instead of p12_base64 value.',
    )
    password: Optional[str] = Field(
        None,
        description='The password for the Apple Developer account to publish the devices to.',
    )
    publish_all_devices: Optional[bool] = Field(
        None,
        description='When set to true, all unprovisioned devices will be published to the Apple Developer account.  When false, only the provided devices will be published to the Apple Developer account.',
    )
    release_id: Optional[float] = Field(
        None,
        description='When provided, will update the provided release with the new set of devices. By default the latest release of the distribution group is used when this property is omitted. If `release_id` is passed in the path, there is no need to pass in the body as well.',
    )
    username: Optional[str] = Field(
        None,
        description='The username for the Apple Developer account to publish the devices to.',
    )


class UpdateDevicesResponse(BaseModel):
    status_url: str = Field(
        ...,
        description='URL that can be used to check the status of the update devices operation.',
    )


class UpdateExternalUrlRequest(BaseModel):
    external_download_url: str = Field(
        ..., description="The external URL to the release's binary."
    )


class UpdateIdentityProvidersRequest(BaseModel):
    pass


class UpdateInfoData(BaseModel):
    description: Optional[str] = None
    is_disabled: Optional[bool] = None
    is_mandatory: Optional[bool] = None
    rollout: Optional[conint(ge=1, le=100)] = None
    target_binary_range: Optional[str] = None
    download_url: Optional[str] = None
    is_available: bool
    label: Optional[str] = None
    package_hash: Optional[str] = None
    package_size: Optional[float] = None
    should_run_binary_version: Optional[bool] = None
    update_app_version: Optional[bool] = None


class UpdateResignStatusRequest(BaseModel):
    error_code: Optional[str] = Field(
        None, description='Error code if an error occured in the resigning operation.'
    )
    error_message: Optional[str] = Field(
        None,
        description='Error message if an error occured in the resigning operation.',
    )
    releaseMetadata: Optional[Dict[str, Any]] = Field(
        None, description='releaseMetadata from ios resigner extractor'
    )
    status: str = Field(
        ..., description='The updated status for the resigning request.'
    )


class UpdateResignStatusResponse(BaseModel):
    profiles_zip_base64: Optional[str] = Field(
        None, description='A zip of the updated provisioning profiles. Base64 encoded.'
    )
    status: str = Field(..., description='The status.')


class UploadedSymbolInfo(BaseModel):
    platform: str = Field(..., description='The platform the symbol is associated with')
    symbol_id: str = Field(..., description='The symbol id of the symbol binary')


class UsagePeriod(BaseModel):
    byAccount: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    byApp: Optional[Dict[str, Dict[str, float]]] = Field(
        None, description='A collection of  named numeric values grouped by app'
    )
    endTime: Optional[str] = Field(
        None, description='Exclusive end time of the usage period.'
    )
    startTime: Optional[str] = Field(
        None, description='Inclusive start time of the usage period'
    )


class UsageRecordStatus(BaseModel):
    expectedLatestBuildExists: Optional[bool] = Field(
        None,
        description='Is the age of the most recent Build service usage record within expected limits',
    )
    expectedLatestTestExists: Optional[bool] = Field(
        None,
        description='Is the age of the most recent Test service usage record within expected limits',
    )
    latestBuildUsageRecordTime: Optional[str] = Field(
        None, description='The time of the most recent Build service usage record'
    )
    latestTestUsageRecordTime: Optional[str] = Field(
        None, description='The time of the most recent Test service usage record'
    )


class Permission9(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'


class UserAppPermissionsUpdateRequest(BaseModel):
    permissions: List[Permission9] = Field(
        ..., description='The permissions the user has for the app'
    )


class Origin42(Enum):
    appcenter = 'appcenter'
    hockeyapp = 'hockeyapp'
    codepush = 'codepush'


class UserAuthResponse(BaseModel):
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    external_provider: Optional[str] = Field(
        None, description='The name of the external auth provider'
    )
    external_user_id: Optional[str] = Field(
        None, description='The user ID given by the external provider'
    )
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user'
    )
    origin: Origin42 = Field(..., description='The creation origin of this user')


class UserDataResponse(BaseModel):
    avatar_url: Optional[str] = Field(
        None, description="The url at which the user's avatar can be reached"
    )
    display_name: Optional[str] = Field(
        None, description='The display name of the user'
    )
    id: Optional[UUID] = Field(None, description='The unique id (UUID) of the user')
    name: Optional[str] = Field(None, description='The name of the user')


class Role5(Enum):
    admin = 'admin'
    collaborator = 'collaborator'
    member = 'member'


class UserEmailOrgRoleRequest(BaseModel):
    role: Optional[Role5] = Field(None, description="The user's role")
    user_email: str = Field(..., description="The user's email address")


class UserEmailRequest(BaseModel):
    user_email: str = Field(..., description="The user's email address")


class UserInteractionMetricsResponse(BaseModel):
    has_more_than_1_release: Optional[bool] = Field(
        None, description="check if the user's whole apps has more than 1 releases."
    )
    less_than_100_apps: Optional[bool] = Field(
        None, description='check if the user has less than 100 apps.'
    )


class UserInvitationPermissionsUpdateRequest(BaseModel):
    permissions: List[Permission9] = Field(
        ..., description='The permissions the user has for the app in the invitation'
    )


class UserLiteProfileResponse(BaseModel):
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')


class UserNameAvailabilityResponse(BaseModel):
    available: bool = Field(
        ..., description='The availability status of the requested user name'
    )
    name: str = Field(..., description='The requested user name')


class UserNameUpdateRequest(BaseModel):
    name: Optional[str] = Field(
        None, description='The new, unique name that is used to identify.'
    )


class Permission11(Enum):
    manager = 'manager'
    developer = 'developer'
    viewer = 'viewer'
    tester = 'tester'


class UserProfileAdminResponse(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin42 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission11]] = Field(
        None, description='The permissions the user has for the app'
    )
    role: Optional[Role5] = Field(
        None, description="The user's role in the organization"
    )


class UserProfileResponse(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin42 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission11]] = Field(
        None, description='The permissions the user has for the app'
    )


class Settings1(BaseModel):
    marketing_opt_in: Optional[str] = Field(
        None, description='The marketing opt-in setting'
    )


class UserProfileResponseInternal(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin42 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission11]] = Field(
        None, description='The permissions the user has for the app'
    )
    admin_role: Optional[AdminRole] = Field(None, description='The new admin_role')
    feature_flags: Optional[List[str]] = Field(
        None, description='The feature flags that are enabled for this app'
    )
    settings: Optional[Settings1] = Field(None, description="The user's settings")


class IdentityProvider(BaseModel):
    origin: Optional[str] = Field(
        None,
        description='Whether the identity provider originated in HockeyApp or App Center',
    )
    provider_name: Optional[ProviderName] = Field(
        None, description='The name of the identity provider type'
    )


class UserProfileResponseManagement(BaseModel):
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    origin: Origin42 = Field(..., description='The creation origin of this user')
    permissions: Optional[List[Permission11]] = Field(
        None, description='The permissions the user has for the app'
    )
    admin_role: Optional[AdminRole] = Field(None, description='The new admin_role')
    feature_flags: Optional[List[str]] = Field(
        None, description='The feature flags that are enabled for this app'
    )
    settings: Optional[Settings1] = Field(None, description="The user's settings")
    identity_providers: Optional[List[IdentityProvider]] = Field(
        None, description="The identity providers associated with the user's account"
    )
    updated_at: Optional[str] = Field(
        None, description='The date when the app was last updated'
    )
    verified: Optional[bool] = Field(
        None,
        description='A boolean flag that indicates if the user is already verified',
    )


class UserProfileResponsev2(BaseModel):
    admin_role: Optional[AdminRole] = Field(None, description='The new admin_role')
    avatar_url: Optional[str] = Field(None, description='The avatar URL of the user')
    can_change_password: Optional[bool] = Field(
        None,
        description='User is required to send an old password in order to change the password.',
    )
    created_at: Optional[str] = Field(None, description='The created date of the user')
    display_name: str = Field(
        ...,
        description='The full name of the user. Might for example be first and last name',
    )
    email: str = Field(..., description='The email address of the user')
    feature_flags: Optional[List[str]] = Field(
        None, description='The feature flags that are enabled for this user'
    )
    id: UUID = Field(..., description='The unique id (UUID) of the user')
    name: str = Field(
        ..., description='The unique name that is used to identify the user.'
    )
    next_nps_survey_date: Optional[str] = Field(
        None,
        description='The date in the future when the user should be checked again for NPS eligibility',
    )
    origin: Origin42 = Field(..., description='The creation origin of this user')
    session_hash: Optional[str] = Field(
        None, description='The session hash of the user'
    )
    settings: Optional[Dict[str, Any]] = Field(None, description="The user's settings")


class UserSettingRequest(BaseModel):
    value: str = Field(..., description='The setting value')


class UserSettingResponse(BaseModel):
    marketing_opt_in: Optional[str] = Field(
        None, description='The marketing opt-in setting'
    )


class UserUpdateRequest(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )


class UserUpdateRequestInternal(BaseModel):
    display_name: Optional[str] = Field(
        None,
        description='The full name of the user. Might for example be first and last name',
    )
    email: Optional[str] = Field(None, description='The email address for this user')
    name: Optional[str] = Field(
        None, description='The new, unique name that is used to identify.'
    )
    next_nps_survey_date: Optional[str] = Field(
        None,
        description='The date in the future when the user should be checked again for NPS eligibility',
    )


class Project2(BaseModel):
    description: Optional[str] = Field(None, description='Project description')
    id: Optional[str] = Field(None, description='Project id')
    name: Optional[str] = Field(None, description='Project name')
    state: Optional[str] = Field(None, description='Project state')
    url: Optional[str] = Field(None, description='Project URL')
    visibility: Optional[str] = Field(None, description='Project visibility')


class User4(BaseModel):
    displayName: Optional[str] = Field(None, description='Profile display name')
    emailAddress: Optional[str] = Field(None, description='Profile email')
    id: Optional[str] = Field(None, description='Profile id')
    publicAlias: Optional[str] = Field(None, description='Profile alias')


class VSTSAccount(BaseModel):
    accountId: Optional[str] = Field(None, description='Account id')
    accountName: Optional[str] = Field(None, description='Account name')
    accountStatus: Optional[str] = Field(None, description='Account status')
    accountType: Optional[str] = Field(None, description='Account type')
    accountUri: Optional[str] = Field(None, description='Account uri')
    projects: Optional[List[Project2]] = Field(None, description='Account projects')
    user: Optional[User4] = Field(None, description='VSTS user profile')


class VSTSAccount1(BaseModel):
    accountId: Optional[str] = Field(None, description='Account id')
    accountName: Optional[str] = Field(None, description='Account name')
    accountStatus: Optional[str] = Field(None, description='Account status')
    accountType: Optional[str] = Field(None, description='Account type')
    accountUri: Optional[str] = Field(None, description='Account uri')
    projects: Optional[List[Project2]] = Field(None, description='Account projects')
    user: Optional[User4] = Field(None, description='VSTS user profile')


class VSTSAccounts(RootModel[List[VSTSAccount1]]):
    root: List[VSTSAccount1] = Field(
        ..., description='A list of VSTS accounts with projects'
    )


class VSTSProfile(BaseModel):
    displayName: Optional[str] = Field(None, description='Profile display name')
    emailAddress: Optional[str] = Field(None, description='Profile email')
    id: Optional[str] = Field(None, description='Profile id')
    publicAlias: Optional[str] = Field(None, description='Profile alias')


class VSTSProject(BaseModel):
    description: Optional[str] = Field(None, description='Project description')
    id: Optional[str] = Field(None, description='Project id')
    name: Optional[str] = Field(None, description='Project name')
    state: Optional[str] = Field(None, description='Project state')
    url: Optional[str] = Field(None, description='Project URL')
    visibility: Optional[str] = Field(None, description='Project visibility')


class Claim(BaseModel):
    claim_type: Optional[ClaimType] = None
    claim_value: Optional[str] = None


class ValidatedApiTokenResponse(BaseModel):
    claims: List[Claim] = Field(
        ...,
        description='Collection of attributes that describe the principal of the specified API Token',
    )
    principal_id: UUID = Field(
        ..., description='The ID of the owner of the API Token (user_id or app_id)'
    )
    principal_type: PrincipalType = Field(
        ..., description='Indicates the type of the principal (app or user)'
    )
    token_id: UUID = Field(..., description="The token's unique id (UUID)")
    token_scope: List[TokenScopeEnum] = Field(
        ..., description="The token's scope. A list of allowed roles."
    )


class ValidationErrorResponse(BaseModel):
    code: str
    id: str
    message: str


class Status20(BaseModel):
    status: Optional[str] = Field(None, description='status from store')
    storetype: Optional[str] = Field(None, description='store type')
    track: Optional[str] = Field(None, description='track information from store')
    version: Optional[str] = Field(None, description='version of the app from store')


class ValidationResponse(BaseModel):
    app_id: Optional[str] = Field(None, description='app id')
    status: Optional[Status20] = Field(None, description='Status Data from store')


class Version1(BaseModel):
    count: Optional[int] = Field(None, description='Version count.')
    previous_count: Optional[int] = Field(
        None, description='The count of previous time range of the version.'
    )
    version: Optional[str] = Field(None, description='Version.')


class VersionDiagnostics(BaseModel):
    count: Optional[int] = Field(None, description='version count')
    previous_count: Optional[int] = Field(
        None, description='the count of previous time range of the version'
    )
    version: Optional[str] = Field(None, description='version')


class Document(BaseModel):
    attributes: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='Collection of attribute values.'
    )
    id: Optional[str] = Field(None, description='The Billing Plan ID')
    limits: Optional[Dict[str, float]] = Field(
        None, description='A collection of named numeric values'
    )
    parentId: Optional[str] = None
    paymentSource: Optional[PaymentSource] = Field(
        None, description='Service that receives payments for this billing plan.'
    )
    price: Optional[float] = Field(None, description='Price of the Billing Plan')
    service: Optional[Service] = Field(
        None, description='Name of the service that the plan applies to.'
    )
    version: Optional[str] = Field(
        None, description='Version of the Billing Plan schema'
    )


class VersionedBillingPlan(BaseModel):
    document: Optional[Document] = Field(None, description='Billing Plan')
    etag: Optional[str] = Field(None, description='The version of the object')


class Versions(BaseModel):
    total: Optional[int] = Field(None, description='The total count of versions.')
    versions: Optional[List[Version1]] = Field(
        None, description='List of version count.'
    )


class Version3(BaseModel):
    count: Optional[int] = Field(None, description='version count')
    previous_count: Optional[int] = Field(
        None, description='the count of previous time range of the version'
    )
    version: Optional[str] = Field(None, description='version')


class VersionsDiagnostics(BaseModel):
    total: Optional[int] = Field(None, description='the total count of versions')
    versions: Optional[List[Version3]] = Field(
        None, description='list of version count'
    )


class WebSocketContainer(BaseModel):
    url: str = Field(..., description='WebSocket URL')


class XamarinBranchConfigurationProperties(BaseModel):
    args: Optional[str] = None
    configuration: Optional[str] = None
    isSimBuild: Optional[bool] = None
    monoVersion: Optional[str] = None
    p12File: Optional[str] = None
    p12Pwd: Optional[str] = None
    provProfile: Optional[str] = None
    sdkBundle: Optional[str] = None
    slnPath: Optional[str] = None
    symlink: Optional[str] = Field(
        None,
        description='Symlink of the SDK Bundle and Mono installation.\nThe build will use the associated Mono bundled with related Xamarin SDK. If both symlink and monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink is passed, the current stable Mono version will be configured for building.\n',
    )


class XamarinSDKBundle(BaseModel):
    current: Optional[bool] = Field(None, description='If the SDK is latest stable')
    monoVersion: Optional[str] = Field(None, description='The Mono version')
    sdkBundle: Optional[str] = Field(None, description='The Xamarin SDK version')
    stable: Optional[bool] = Field(None, description='If the SDK is stable')
    xcodeVersions: Optional[List[str]] = Field(
        None,
        description='Specific for iOS SDK. A list of Xcode versions supported by current SDK version',
    )


class XamarinSDKBundles(RootModel[List[XamarinSDKBundle]]):
    root: List[XamarinSDKBundle] = Field(
        ..., description='A list of Xamarin SDK bundles'
    )


class XamarinToolset(BaseModel):
    xamarinSolutions: List[XamarinSolution] = Field(
        ..., description='Xamarin solutions for the toolset'
    )


class XcodeArchiveProject(BaseModel):
    archiveTargetId: str = Field(..., description='The Id of the target to archive')
    projectName: str = Field(..., description='The project to archive container name')
    projectPath: Optional[str] = Field(
        None, description='Full path of the target project'
    )


class XcodeBranchConfigurationProperties(BaseModel):
    appExtensionProvisioningProfileFiles: Optional[
        List[AppExtensionProvisioningProfileFile]
    ] = None
    archiveConfiguration: Optional[str] = Field(
        None, description='The build configuration of the target to archive'
    )
    automaticSigning: Optional[bool] = None
    cartfilePath: Optional[str] = Field(
        None, description='Path to Carthage file, if present'
    )
    certificateEncoded: Optional[str] = None
    certificateFileId: Optional[str] = None
    certificateFilename: Optional[str] = None
    certificatePassword: Optional[str] = None
    certificateUploadId: Optional[str] = None
    forceLegacyBuildSystem: Optional[bool] = Field(
        None,
        description='Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.\nBy default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.\n',
    )
    podfilePath: Optional[str] = Field(
        None, description='Path to CococaPods file, if present'
    )
    projectOrWorkspacePath: Optional[str] = Field(
        None, description='Xcode project/workspace path'
    )
    provisioningProfileEncoded: Optional[str] = None
    provisioningProfileFileId: Optional[str] = None
    provisioningProfileFilename: Optional[str] = None
    provisioningProfileUploadId: Optional[str] = None
    scheme: Optional[str] = None
    targetToArchive: Optional[str] = Field(
        None, description='The target id of the selected scheme to archive'
    )
    teamId: Optional[str] = None
    xcodeProjectSha: Optional[str] = Field(
        None, description='The selected pbxproject hash to the repositroy'
    )
    xcodeVersion: Optional[str] = Field(
        None,
        description='Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default is latest stable version, at the time when the configuration is set.',
    )


class XcodeScheme(BaseModel):
    archiveConfiguration: Optional[str] = Field(
        None, description='Build configuration set in Archive action'
    )
    archiveProject: Optional[ArchiveProject] = None
    hasTestAction: bool = Field(..., description='Does scheme have a test action?')
    name: str = Field(..., description='Scheme name')


class SharedScheme1(BaseModel):
    archiveConfiguration: Optional[str] = Field(
        None, description='Build configuration set in Archive action'
    )
    archiveProject: Optional[ArchiveProject] = None
    hasTestAction: bool = Field(..., description='Does scheme have a test action?')
    name: str = Field(..., description='Scheme name')


class XcodeSchemeContainer1(BaseModel):
    appExtensionTargets: Optional[List[AppExtensionTarget]] = Field(
        None, description='Information regarding project app extensions, if present'
    )
    cartfilePath: Optional[str] = Field(
        None, description='Path to Carthage file, if present'
    )
    path: str = Field(..., description='Path to project')
    podfilePath: Optional[str] = Field(
        None, description='Path to CocoaPods file, if present'
    )
    sharedSchemes: List[SharedScheme1] = Field(..., description='Project schemes')
    workspaceProjectPaths: Optional[str] = Field(
        None, description='Related projects paths for xcworkspace'
    )
    xcodeProjectSha: Optional[str] = Field(
        None, description='repo object Id of the pbxproject'
    )


class SharedScheme2(BaseModel):
    archiveConfiguration: Optional[str] = Field(
        None, description='Build configuration set in Archive action'
    )
    archiveProject: Optional[ArchiveProject] = None
    hasTestAction: bool = Field(..., description='Does scheme have a test action?')
    name: str = Field(..., description='Scheme name')


class XcodeSchemeContainer2(BaseModel):
    appExtensionTargets: Optional[List[AppExtensionTarget]] = Field(
        None, description='Information regarding project app extensions, if present'
    )
    cartfilePath: Optional[str] = Field(
        None, description='Path to Carthage file, if present'
    )
    path: str = Field(..., description='Path to project')
    podfilePath: Optional[str] = Field(
        None, description='Path to CocoaPods file, if present'
    )
    sharedSchemes: List[SharedScheme2] = Field(..., description='Project schemes')
    workspaceProjectPaths: Optional[str] = Field(
        None, description='Related projects paths for xcworkspace'
    )
    xcodeProjectSha: Optional[str] = Field(
        None, description='repo object Id of the pbxproject'
    )


class XcodeToolset(BaseModel):
    xcodeSchemeContainers: List[XcodeSchemeContainer2] = Field(
        ..., description='The Xcode scheme containers'
    )


class XcodeVersion(BaseModel):
    current: Optional[bool] = Field(None, description='If the Xcode is latest stable')
    name: Optional[str] = Field(None, description='The version name')


class XcodeVersions(RootModel[List[XcodeVersion]]):
    root: List[XcodeVersion] = Field(..., description='A list of Xcode versions')


class V2FailureResponse(BaseModel):
    code: str
    message: str


class Status21(Enum):
    missing = 'missing'
    ignored = 'ignored'
    available = 'available'


class V2MissingSymbol(BaseModel):
    name: str = Field(..., description='symbol name')
    platform: Optional[str] = Field(None, description='symbol plarform')
    status: Status21 = Field(..., description='symbol status')
    symbol_id: str = Field(..., description='symbol id')


class MissingSymbol(BaseModel):
    name: str = Field(..., description='symbol name')
    platform: Optional[str] = Field(None, description='symbol plarform')
    status: Status21 = Field(..., description='symbol status')
    symbol_id: str = Field(..., description='symbol id')


class Status23(Enum):
    active = 'active'
    pending = 'pending'
    closed = 'closed'


class V2MissingSymbolCrashGroup(BaseModel):
    app_build: str = Field(..., description='application build')
    app_id: str = Field(..., description='application id')
    app_ver: str = Field(..., description='application version')
    crash_count: Optional[int] = Field(
        None, description='number of crashes that belong to this group'
    )
    error_count: Optional[int] = Field(
        None, description='number of errors that belong to this group'
    )
    last_modified: datetime_aliased = Field(
        ..., description='last update date for the group'
    )
    missing_symbols: List[MissingSymbol] = Field(
        ..., description='list of missing symbols'
    )
    status: Status23 = Field(..., description='group status')
    symbol_group_id: str = Field(..., description='id of the symbol group')


class V2MissingSymbolCrashGroupStatusEnum(Enum):
    active = 'active'
    pending = 'pending'
    closed = 'closed'


class Status24(Enum):
    missing = 'missing'
    ignored = 'ignored'
    available = 'available'


class MissingSymbol1(BaseModel):
    name: str = Field(..., description='symbol name')
    platform: Optional[str] = Field(None, description='symbol plarform')
    status: Status24 = Field(..., description='symbol status')
    symbol_id: str = Field(..., description='symbol id')


class Status25(Enum):
    active = 'active'
    pending = 'pending'
    closed = 'closed'


class V2MissingSymbolCrashGroup1(BaseModel):
    app_build: str = Field(..., description='application build')
    app_id: str = Field(..., description='application id')
    app_ver: str = Field(..., description='application version')
    crash_count: Optional[int] = Field(
        None, description='number of crashes that belong to this group'
    )
    error_count: Optional[int] = Field(
        None, description='number of errors that belong to this group'
    )
    last_modified: datetime_aliased = Field(
        ..., description='last update date for the group'
    )
    missing_symbols: List[MissingSymbol1] = Field(
        ..., description='list of missing symbols'
    )
    status: Status25 = Field(..., description='group status')
    symbol_group_id: str = Field(..., description='id of the symbol group')


class V2MissingSymbolCrashGroups(RootModel[List[V2MissingSymbolCrashGroup1]]):
    root: List[V2MissingSymbolCrashGroup1] = Field(
        ..., description='A list of crash groups formed by missing symbols combination'
    )


class V2MissingSymbolCrashGroupsInfoResponse(BaseModel):
    total_crash_count: int = Field(
        ..., description='total number of crashes for all missing symbol groups'
    )


class Status26(Enum):
    missing = 'missing'
    ignored = 'ignored'
    available = 'available'


class MissingSymbol2(BaseModel):
    name: str = Field(..., description='symbol name')
    platform: Optional[str] = Field(None, description='symbol plarform')
    status: Status26 = Field(..., description='symbol status')
    symbol_id: str = Field(..., description='symbol id')


class Status27(Enum):
    active = 'active'
    pending = 'pending'
    closed = 'closed'


class Group(BaseModel):
    app_build: str = Field(..., description='application build')
    app_id: str = Field(..., description='application id')
    app_ver: str = Field(..., description='application version')
    crash_count: Optional[int] = Field(
        None, description='number of crashes that belong to this group'
    )
    error_count: Optional[int] = Field(
        None, description='number of errors that belong to this group'
    )
    last_modified: datetime_aliased = Field(
        ..., description='last update date for the group'
    )
    missing_symbols: List[MissingSymbol2] = Field(
        ..., description='list of missing symbols'
    )
    status: Status27 = Field(..., description='group status')
    symbol_group_id: str = Field(..., description='id of the symbol group')


class V2MissingSymbolCrashGroupsResponse(BaseModel):
    groups: List[Group] = Field(
        ..., description='list of crash groups formed by missing symbols combination'
    )
    total_crash_count: int = Field(
        ..., description='total number of crashes for all the groups'
    )


class Status28(Enum):
    missing = 'missing'
    ignored = 'ignored'
    available = 'available'


class V2MissingSymbol1(BaseModel):
    name: str = Field(..., description='symbol name')
    platform: Optional[str] = Field(None, description='symbol plarform')
    status: Status28 = Field(..., description='symbol status')
    symbol_id: str = Field(..., description='symbol id')


class V2MissingSymbols(RootModel[List[V2MissingSymbol1]]):
    root: List[V2MissingSymbol1] = Field(..., description='A list of missing symbols')


class V2StatusResponse(BaseModel):
    status: str


class V2SymbolStatusEnum(Enum):
    missing = 'missing'
    ignored = 'ignored'
    available = 'available'


class V2SymbolUpdateInfo(BaseModel):
    app_id: str = Field(..., description='application id')
    status: Status28 = Field(..., description='symbol upload status')
    symbol_id: str = Field(..., description='UUID of the symbol')


class V2SymbolUpdateInfoArrayItem(BaseModel):
    app_id: str = Field(..., description='application id')
    status: Status28 = Field(..., description='symbol upload status')
    symbol_id: str = Field(..., description='UUID of the symbol')


class V2SymbolUpdateInfoArray(RootModel[List[V2SymbolUpdateInfoArrayItem]]):
    root: List[V2SymbolUpdateInfoArrayItem] = Field(
        ..., description='symbols update message'
    )


class FieldOrderBy(Enum):
    display_name = 'display_name'
    name = 'name'


class Versions1(RootModel[List[str]]):
    root: List[str]


class FieldInlinecount(Enum):
    allpages = 'allpages'
    none = 'none'


class EventName(RootModel[List[str]]):
    root: List[str]


class Service13(Enum):
    Test = 'Test'
    Build = 'Build'


class Period(Enum):
    Previous = 'Previous'
    Current = 'Current'
    Next = 'Next'


class Format(Enum):
    yaml = 'yaml'
    json = 'json'


class Os12(Enum):
    iOS = 'iOS'
    Android = 'Android'
    Windows = 'Windows'
    macOS = 'macOS'


class Platform13(Enum):
    Objective_C_Swift = 'Objective-C-Swift'
    React_Native = 'React-Native'
    Xamarin = 'Xamarin'
    Java = 'Java'
    UWP = 'UWP'


class DownloadType(Enum):
    build = 'build'
    symbols = 'symbols'
    logs = 'logs'
    mapping = 'mapping'
    bundle = 'bundle'


class Hashes(RootModel[List[str]]):
    root: List[str]


class GroupType2(Enum):
    GroupType1 = 'GroupType1'
    GroupType2 = 'GroupType2'


class GroupStatus(Enum):
    open = 'open'
    closed = 'closed'
    ignored = 'ignored'


class FieldOrderby(Enum):
    last_occurrence_asc = 'last_occurrence asc'
    last_occurrence_desc = 'last_occurrence desc'
    count_asc = 'count asc'
    count_desc = 'count desc'
    display_id_asc = 'display_id asc'
    display_id_desc = 'display_id desc'
    impacted_users_asc = 'impacted_users asc'
    impacted_users_desc = 'impacted_users desc'


class ErrorType(Enum):
    CrashingErrors = 'CrashingErrors'
    HandledErrors = 'HandledErrors'


class Udids(RootModel[List[str]]):
    root: List[str]


class ErrorType2(Enum):
    all = 'all'
    unhandledError = 'unhandledError'
    handledError = 'handledError'


class ErrorType6(Enum):
    unhandledError = 'unhandledError'
    handledError = 'handledError'


class ErrorType8(Enum):
    all = 'all'
    unhandledError = 'unhandledError'
    handledError = 'handledError'


class Order(Enum):
    desc = 'desc'
    asc = 'asc'


class Sort(Enum):
    matchingReportsCount = 'matchingReportsCount'
    exceptionClassName = 'exceptionClassName'
    exceptionMessage = 'exceptionMessage'
    exceptionMethod = 'exceptionMethod'
    lastOccurrence = 'lastOccurrence'


class Format2(Enum):
    json = 'json'
    txt = 'txt'


class ErrorType10(Enum):
    unhandledError = 'unhandledError'
    handledError = 'handledError'


class Sort2(Enum):
    timestamp = 'timestamp'
    errorGroupId = 'errorGroupId'
    exceptionClassName = 'exceptionClassName'
    exceptionFile = 'exceptionFile'
    exceptionLine = 'exceptionLine'
    exceptionMessage = 'exceptionMessage'
    exceptionMethod = 'exceptionMethod'
    deviceName = 'deviceName'
    osVersion = 'osVersion'
    userId = 'userId'


class Form(Enum):
    lite = 'lite'
    full = 'full'


class SourceHost(Enum):
    github = 'github'
    bitbucket = 'bitbucket'
    vsts = 'vsts'
    gitlab = 'gitlab'


class Status31(Enum):
    all = 'all'
    uploaded = 'uploaded'
    processed = 'processed'


class SymbolType3(Enum):
    AndroidProguard = 'AndroidProguard'
    Apple = 'Apple'
    Breakpad = 'Breakpad'
    JavaScript = 'JavaScript'
    UWP = 'UWP'


class Tools(Enum):
    xamarin = 'xamarin'
    xcode = 'xcode'
    node = 'node'


class DiagnosticsStackTrace(BaseModel):
    exception: Optional[DiagnosticsException] = None
    reason: Optional[str] = None
    threads: Optional[List[DiagnosticsThread]] = None
    title: Optional[str] = None


class Stacktrace(BaseModel):
    exception: Optional[Exception] = None
    reason: Optional[str] = None
    threads: Optional[List[Thread]] = None
    title: Optional[str] = None


class Crash(BaseModel):
    build: str = Field(..., description='')
    crash_id: str = Field(..., description='')
    details: Optional[Details] = None
    device: str = Field(..., description='')
    device_name: Optional[str] = Field(None, description='')
    display_id: Optional[str] = None
    new_crash_group_id: str = Field(..., description='')
    new_crash_id: str = Field(..., description='')
    os_type: Optional[str] = Field(None, description='')
    os_version: str = Field(..., description='')
    stacktrace: Optional[Stacktrace] = None
    timestamp: datetime_aliased
    user_email: Optional[str] = Field(None, description='')
    user_name: str = Field(..., description='')
    version: str = Field(..., description='')


DiagnosticsException.model_rebuild()
Exception.model_rebuild()
ProvisioningProfileResponse.model_rebuild()
